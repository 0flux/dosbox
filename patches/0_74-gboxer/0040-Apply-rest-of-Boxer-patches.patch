From 41d5f69ef945fb222563cebd0f58c86f5c9907bc Mon Sep 17 00:00:00 2001
From: Ismail Khatib <ikhatib@gmail.com>
Date: Thu, 21 Mar 2024 04:20:19 +0100
Subject: [PATCH] Apply rest of Boxer patches

---
 config_boxer.h                           | 377 ++++++++++
 include/SDL.h                            |  10 +
 include/SDL_endian.h                     |  10 +
 include/SDL_net.h                        |  10 +
 include/SDL_sound.h                      |  10 +
 include/SDL_thread.h                     |  10 +
 include/dma.h                            |   2 +-
 include/dos_system.h                     |  28 +-
 include/dosbox.h                         |   7 +-
 include/joystick.h                       |   3 +
 include/keyboard.h                       |   6 +-
 include/setup.h                          |   2 +-
 include/shell.h                          |   7 +-
 include/timer.h                          |   5 +-
 src/cpu/callback.cpp                     |   2 +-
 src/cpu/core_dyn_x86.cpp                 |   2 +-
 src/cpu/core_dyn_x86/cache.h             |   8 +-
 src/cpu/core_dyn_x86/decoder.h           |   2 +-
 src/cpu/core_dyn_x86/dyn_fpu.h           |   4 +-
 src/cpu/core_dyn_x86/dyn_fpu_dh.h        |   8 +-
 src/cpu/core_dyn_x86/risc_x86.h          |   4 +
 src/cpu/cpu.cpp                          |   3 +
 src/cpu/lazyflags.h                      |   2 +-
 src/dos/cdrom.cpp                        |  26 +
 src/dos/cdrom.h                          | 139 ++--
 src/dos/cdrom_image.cpp                  |  88 ++-
 src/dos/cdrom_ioctl_win32.cpp            |   1 -
 src/dos/dev_con.h                        |  14 +
 src/dos/dos.cpp                          |   1 +
 src/dos/dos_devices.cpp                  |  12 +-
 src/dos/dos_execute.cpp                  |   3 +
 src/dos/dos_keyboard_layout.cpp          | 105 ++-
 src/dos/dos_memory.cpp                   |  33 +-
 src/dos/dos_mscdex.cpp                   | 910 ++++++++++++-----------
 src/dos/dos_programs.cpp                 |  50 +-
 src/dos/drive_cache.cpp                  |  63 +-
 src/dos/drive_fat.cpp                    |  54 +-
 src/dos/drive_iso.cpp                    |  42 +-
 src/dos/drive_local.cpp                  | 295 +++++++-
 src/dos/drive_physfs.cpp                 |  87 +--
 src/dos/drive_virtual.cpp                |  16 +-
 src/dos/drives.cpp                       |  10 +
 src/dos/drives.h                         |  15 +-
 src/dosbox.cpp                           |  65 +-
 src/fpu/fpu_instructions_x86.h           |   8 +-
 src/gui/midi.cpp                         | 138 +++-
 src/gui/render.cpp                       |  16 +-
 src/hardware/adlib.cpp                   |  20 +-
 src/hardware/dbopl.cpp                   |  16 +-
 src/hardware/dma.cpp                     |  10 +-
 src/hardware/gus.cpp                     |  33 +-
 src/hardware/hardware.cpp                |  16 +-
 src/hardware/iohandler.cpp               |   6 +-
 src/hardware/ipx.cpp                     |   2 +-
 src/hardware/joystick.cpp                |  57 +-
 src/hardware/keyboard.cpp                |   8 +
 src/hardware/mixer.cpp                   |  37 +-
 src/hardware/opl.cpp                     |   3 +
 src/hardware/pcspeaker.cpp               |   2 +-
 src/hardware/pic.cpp                     |   2 +-
 src/hardware/serialport/directserial.cpp |   6 +-
 src/hardware/serialport/misc_util.cpp    |   6 +-
 src/hardware/serialport/nullmodem.cpp    |  16 +-
 src/hardware/serialport/serialdummy.cpp  |   6 +-
 src/hardware/serialport/softmodem.cpp    |  11 +-
 src/hardware/tandy_sound.cpp             |   6 +-
 src/hardware/vga_draw.cpp                |  33 +-
 src/hardware/vga_other.cpp               |  41 +-
 src/hardware/vga_xga.cpp                 |   1 -
 src/ints/bios.cpp                        |  49 +-
 src/ints/bios_disk.cpp                   |   6 +-
 src/ints/bios_keyboard.cpp               |  83 ++-
 src/ints/ems.cpp                         |   6 +-
 src/ints/int10_char.cpp                  |   2 +-
 src/ints/mouse.cpp                       |  21 +-
 src/misc/cross.cpp                       |   4 +-
 src/misc/messages.cpp                    |  11 +-
 src/misc/setup.cpp                       |  20 +-
 src/misc/support.cpp                     |   3 +-
 src/shell/shell.cpp                      |  98 ++-
 src/shell/shell_batch.cpp                |   8 +
 src/shell/shell_cmds.cpp                 | 152 +++-
 src/shell/shell_misc.cpp                 |  70 +-
 83 files changed, 2659 insertions(+), 925 deletions(-)
 create mode 100644 config_boxer.h
 create mode 100644 include/SDL.h
 create mode 100644 include/SDL_endian.h
 create mode 100644 include/SDL_net.h
 create mode 100644 include/SDL_sound.h
 create mode 100644 include/SDL_thread.h

diff --git a/config_boxer.h b/config_boxer.h
new file mode 100644
index 00000000..73f8c598
--- /dev/null
+++ b/config_boxer.h
@@ -0,0 +1,377 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.in by autoheader.  */
+
+/*
+Note 2009-02-26 by Alun Bestor:
+This file is normally generated by configure to specify different compile-time settings based on the current build platform and any selected compile-time options.
+	
+However, over here in XCode-land we want things to be much more clear-cut: so our compile-time options (like sound libraries) have been hardcoded, host architecture checks have been replaced with PPC/Intel switches in place, and type size checks with mappings to standard system types.
+	
+This means that this file has had too many modifications to be safely replaceable with a copy of this file from a makefile-built DOSBox. It will need manual maintenance when the next version of DOSBox is released.
+*/
+
+
+/*
+ *  Copyright (C) 2002-2007  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+/* Determines if the compilers supports always_inline attribute. */
+#undef C_ATTRIBUTE_ALWAYS_INLINE
+
+/* Determines if the compilers supports fastcall attribute. */
+#undef C_ATTRIBUTE_FASTCALL
+
+/* Define to 1 to use inlined memory functions in cpu core */
+/* #undef C_CORE_INLINE */
+#define C_CORE_INLINE 1
+
+/* Define to 1 to enable internal debugger, requires libcurses */
+/* #undef C_DEBUG */
+
+/* Define to 1 if you want serial passthrough support (Win32, Posix and OS/2). */
+#define C_DIRECTSERIAL 1
+
+
+/* Define to 1 to use x86 dynamic cpu core */
+//--Modified 2009-02-26 by Alun Bestor to enable automatically for x86
+#if defined(__i386__)
+	#define C_DYNAMIC_X86 1
+#endif
+//--End of modifications
+
+
+/* Define to 1 to use recompiling cpu core. Can not be used together with the
+   dynamic-x86 core */
+
+/* #undef C_DYNREC */
+//--Modified 2009-02-26 by Alun Bestor to enable automatically for X64
+#if defined(__x86_64__) && !defined(C_DYNAMIC_X86)
+	#define  C_DYNREC 1
+#endif
+//--End of modifications
+
+/* Define to 1 to enable floating point emulation */
+#define C_FPU 1
+
+/* Define to 1 to use a x86 assembly fpu core */
+//--Modified 2009-02-26 by Alun Bestor to force this on for Intel
+
+#if defined(__i386__) || defined(__x86_64__)
+	#define C_FPU_X86 1
+#endif
+
+//--End of modifications
+
+
+/* Determines if the compilers supports attributes for structures. */
+#define C_HAS_ATTRIBUTE 1
+
+/* Determines if the compilers supports __builtin_expect for branch
+   prediction. */
+#define C_HAS_BUILTIN_EXPECT 1
+
+/* Define to 1 if you have the mprotect function */
+#define C_HAVE_MPROTECT 1
+
+/* Define to 1 to enable heavy debugging, also have to enable C_DEBUG */
+/* #undef C_HEAVY_DEBUG */
+
+
+/* Define to 1 to enable IPX over Internet networking, requires SDL_net */
+#define C_IPX 1
+
+/* Define to 1 to enable internal modem support, requires SDL_net */
+#define C_MODEM 1
+
+/* Define to 1 to use opengl display output support */
+#define C_OPENGL 1
+
+
+/* Define to 1 to enable SDL_sound support */
+#define C_SDL_SOUND 1
+
+/* Define to 1 if you have setpriority support */
+#define C_SET_PRIORITY 1
+
+/* Define to 1 to enable screenshots, requires libpng */
+/* #undef C_SSHOT */
+//#define C_SSHOT 1
+
+
+/* The type of cpu this target has */
+//--Modified 2009-02-26 by Alun Bestor to define these manually
+#if defined(__x86_64__)
+	#define C_TARGETCPU X86_64
+#elif defined(__i386__)
+	#define C_TARGETCPU X86
+#elif defined(__ppc__) || defined(__ppc64__)
+	#define C_TARGETCPU POWERPC
+#endif
+//--End of modifications
+
+
+/* Define to 1 if your processor stores words with the most significant byte
+   first (like Motorola and SPARC, unlike Intel and VAX). */
+
+//--Modified 2009-02-26 by Alun Bestor to define this manually
+/* #undef WORDS_BIGENDIAN */
+#if defined(__BIG_ENDIAN__)
+	#define WORDS_BIGENDIAN 1
+#endif
+//--End of modifications
+
+
+/* Define to 1 to use a unaligned memory access */
+//#define C_UNALIGNED_MEMORY 1
+
+/* libm doesn't include powf */
+/* #undef DB_HAVE_NO_POWF */
+
+/* environ can be included */
+/* #undef ENVIRON_INCLUDED */
+
+/* environ can be linked */
+/* #define ENVIRON_LINKED 1 */
+#undef ENVIRON_LINKED
+
+/* Define to 1 to use ALSA for MIDI */
+/* #undef HAVE_ALSA */
+
+/* Define to 1 if you have the <ddraw.h> header file. */
+/* #undef HAVE_DDRAW_H */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `asound' library (-lasound). */
+/* #undef HAVE_LIBASOUND */
+
+/* Define to 1 if you have the `m' library (-lm). */
+#define HAVE_LIBM 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#define HAVE_NETINET_IN_H 1
+
+/* Define to 1 if you have the <pwd.h> header file. */
+#define HAVE_PWD_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Compiling on GNU/Linux */
+/* #undef LINUX */
+
+/* Compiling on Mac OS X */
+#define MACOSX 1
+
+/* Compiling on OS/2 EMX */
+/* #undef OS2 */
+
+/* Compile with PhysicalFS support */
+#define C_HAVE_PHYSFS 0
+
+#define C_PRINTER 1
+
+//--Note 2009-02-26 by Alun Bestor: I'm assuming (hoping) these lines are unused by everything except make install
+
+/* Name of package */
+#define PACKAGE "dosbox"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "dosbox"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "dosbox 0.74"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "dosbox"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "0.74"
+
+/* Version number of package */
+#define VERSION "0.74"
+
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if your <sys/time.h> declares `struct tm'. */
+/* #undef TM_IN_SYS_TIME */
+   
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* Define to `int` if you don't have socklen_t */
+/* #undef socklen_t */
+
+
+#if C_ATTRIBUTE_ALWAYS_INLINE
+#define INLINE inline __attribute__((always_inline))
+#else
+#define INLINE inline
+#endif
+
+#if C_ATTRIBUTE_FASTCALL
+#define DB_FASTCALL __attribute__((fastcall))
+#else
+#define DB_FASTCALL
+#endif
+
+#if C_HAS_ATTRIBUTE
+#define GCC_ATTRIBUTE(x) __attribute__ ((x))
+#else
+#define GCC_ATTRIBUTE(x) /* attribute not supported */
+#endif
+
+#if C_HAS_BUILTIN_EXPECT
+#define GCC_UNLIKELY(x) __builtin_expect((x),0)
+#define GCC_LIKELY(x) __builtin_expect((x),1)
+#else
+#define GCC_UNLIKELY(x) (x)
+#define GCC_LIKELY(x) (x)
+#endif
+
+
+//--Modified 2009-02-09 by Alun Bestor: instead of going through this rigmarole, we simply map DOSBox's types to the predefined system types.
+
+typedef		double		Real64;
+
+#import <stdint.h>
+
+typedef		uint8_t		Bit8u;
+typedef		int8_t		Bit8s;
+
+typedef		uint16_t	Bit16u;
+typedef		int16_t		Bit16s;
+
+typedef		uint32_t	Bit32u;
+typedef		int32_t		Bit32s;
+
+typedef		uint64_t	Bit64u;
+typedef		int64_t		Bit64s;
+
+//I'd rather map these to NSUinteger and NSInteger respectively, which would give the exact same result, but that would mean importing Obj-C headers into a C++ context and the compiler would shit itself
+#if defined(__LP64__)
+	typedef Bit64u Bitu;
+	typedef Bit64s Bits;
+#else
+	typedef Bit32u Bitu;
+	typedef Bit32s Bits;
+#endif
+
+/* The size of `int *', as computed by sizeof. */
+//#define SIZEOF_INT_P 4
+
+/* The size of `unsigned char', as computed by sizeof. */
+//#define SIZEOF_UNSIGNED_CHAR 1
+
+/* The size of `unsigned int', as computed by sizeof. */
+//#define SIZEOF_UNSIGNED_INT 4
+
+/* The size of `unsigned long', as computed by sizeof. */
+//#define SIZEOF_UNSIGNED_LONG 4
+
+/* The size of `unsigned long long', as computed by sizeof. */
+//#define SIZEOF_UNSIGNED_LONG_LONG 8
+
+/* The size of `unsigned short', as computed by sizeof. */
+//#define SIZEOF_UNSIGNED_SHORT 2
+
+/*
+#if SIZEOF_UNSIGNED_CHAR != 1
+#  error "sizeof (unsigned char) != 1"
+#else
+  typedef unsigned char Bit8u;
+  typedef   signed char Bit8s;
+#endif
+
+#if SIZEOF_UNSIGNED_SHORT != 2
+#  error "sizeof (unsigned short) != 2"
+#else
+  typedef unsigned short Bit16u;
+  typedef   signed short Bit16s;
+#endif
+
+#if SIZEOF_UNSIGNED_INT == 4
+  typedef unsigned int Bit32u;
+  typedef   signed int Bit32s;
+#elif SIZEOF_UNSIGNED_LONG == 4
+  typedef unsigned long Bit32u;
+  typedef   signed long Bit32s;
+#else
+#  error "can't find sizeof(type) of 4 bytes!"
+#endif
+
+#if SIZEOF_UNSIGNED_LONG == 8
+  typedef unsigned long Bit64u;
+  typedef   signed long Bit64s;
+#elif SIZEOF_UNSIGNED_LONG_LONG == 8
+  typedef unsigned long long Bit64u;
+  typedef   signed long long Bit64s;
+#else
+#  error "can't find data type of 8 bytes"
+#endif
+
+#if SIZEOF_INT_P == 4
+  typedef Bit32u Bitu;
+  typedef Bit32s Bits;
+ #else
+  typedef Bit64u Bitu;
+  typedef Bit64s Bits;
+ #endif
+
+*/
+//--End of modifications
diff --git a/include/SDL.h b/include/SDL.h
new file mode 100644
index 00000000..f03ad8db
--- /dev/null
+++ b/include/SDL.h
@@ -0,0 +1,10 @@
+#if __cplusplus
+extern "C" {
+#endif
+
+//This cunning file remaps DOSBox's SDL header include to our custom framework instead
+#import <SDL/SDL.h>
+
+#if __cplusplus
+} //Extern C
+#endif
diff --git a/include/SDL_endian.h b/include/SDL_endian.h
new file mode 100644
index 00000000..56918583
--- /dev/null
+++ b/include/SDL_endian.h
@@ -0,0 +1,10 @@
+#if __cplusplus
+extern "C" {
+#endif
+
+//This cunning file remaps DOSBox's SDL header include to our custom framework instead
+#import <SDL/SDL_endian.h>
+
+#if __cplusplus
+} //Extern C
+#endif
diff --git a/include/SDL_net.h b/include/SDL_net.h
new file mode 100644
index 00000000..1bbee051
--- /dev/null
+++ b/include/SDL_net.h
@@ -0,0 +1,10 @@
+#if __cplusplus
+extern "C" {
+#endif
+
+//This cunning file remaps DOSBox's SDL header include to our custom framework instead
+#import <SDL_net/SDL_net.h>
+
+#if __cplusplus
+} //Extern C
+#endif
\ No newline at end of file
diff --git a/include/SDL_sound.h b/include/SDL_sound.h
new file mode 100644
index 00000000..b084c845
--- /dev/null
+++ b/include/SDL_sound.h
@@ -0,0 +1,10 @@
+#if __cplusplus
+extern "C" {
+#endif
+
+//This cunning file remaps DOSBox's SDL_sound header include to our custom framework instead
+#import <SDL_sound/SDL_sound.h>
+
+#if __cplusplus
+} //Extern C
+#endif
diff --git a/include/SDL_thread.h b/include/SDL_thread.h
new file mode 100644
index 00000000..fc9b135e
--- /dev/null
+++ b/include/SDL_thread.h
@@ -0,0 +1,10 @@
+#if __cplusplus
+extern "C" {
+#endif
+
+//This cunning file remaps DOSBox's SDL header include to our custom framework instead
+#import <SDL/SDL_thread.h>
+
+#if __cplusplus
+} //Extern C
+#endif
diff --git a/include/dma.h b/include/dma.h
index a12615db..4270449f 100644
--- a/include/dma.h
+++ b/include/dma.h
@@ -114,6 +114,6 @@ DmaChannel * GetDMAChannel(Bit8u chan);
 void CloseSecondDMAController(void);
 bool SecondDMAControllerAvailable(void);
 
-static Bit32u dma_wrapping = 0xffff;
+extern Bit32u dma_wrapping;
 
 #endif
diff --git a/include/dos_system.h b/include/dos_system.h
index e23a26c8..5ea55086 100644
--- a/include/dos_system.h
+++ b/include/dos_system.h
@@ -79,6 +79,10 @@ public:
 	virtual void	AddRef()					{ refCtr++; };
 	virtual Bits	RemoveRef()					{ return --refCtr; };
 	virtual bool	UpdateDateTimeFromHost()	{ return true; }
+    //--Added 2011-11-03 by Alun Bestor to let Boxer inform open file handles
+    //that their physical backing media will be removed.
+    virtual void    willBecomeUnavailable()     { }
+    //--End of modifications
 	void SetDrive(Bit8u drv) { hdrive=drv;}
 	Bit8u GetDrive(void) { return hdrive;}
 	Bit32u flags;
@@ -128,7 +132,7 @@ class DOS_Drive;
 class DOS_Drive_Cache {
 public:
 	DOS_Drive_Cache					(void);
-	DOS_Drive_Cache					(const char* path, DOS_Drive *drive);
+	DOS_Drive_Cache					(const char* path, DOS_Drive *drive); 
 	~DOS_Drive_Cache				(void);
 
 	enum TDirSort { NOSORT, ALPHABETICAL, DIRALPHABETICAL, ALPHABETICALREV, DIRALPHABETICALREV };
@@ -140,7 +144,11 @@ public:
 
 	void		ExpandName			(char* path);
 	char*		GetExpandName		(const char* path);
-	bool		GetShortName		(const char* fullname, char* shortname);
+
+	//--Modified 2009-10-06 by Alun Bestor: changed function signature to correspond to new implementation in drive_cache.cpp.
+	bool		GetShortName		(const char* dirpath, const char* filename, char* shortname);
+	//bool		GetShortName		(const char* fullname, char* shortname);
+	//--End of modifications
 
 	bool		FindFirst			(char* path, Bit16u& id);
 	bool		FindNext			(Bit16u id, char* &result);
@@ -232,6 +240,7 @@ public:
 	virtual bool FileStat(const char* name, FileStat_Block * const stat_block)=0;
 	virtual Bit8u GetMediaByte(void)=0;
 	virtual void SetDir(const char* path) { strcpy(curdir,path); };
+//	virtual void EmptyCache(void) { dirCache.EmptyCache(); };
 	virtual bool isRemote(void)=0;
 	virtual bool isRemovable(void)=0;
 	virtual Bits UnMount(void)=0;
@@ -245,11 +254,22 @@ public:
 	virtual const char * GetInfo(void);
 	char curdir[DOS_PATHLENGTH];
 	char info[256];
+	
 	/* Can be overridden for example in iso images */
-	virtual char const * GetLabel() {return "NOLABEL";};
-	virtual void SetLabel(const char *label, bool iscdrom, bool updatable) {};
+	virtual char const * GetLabel() {return "NOLABEL";}; 
+	virtual void SetLabel(const char *label, bool iscdrom, bool updatable) {}; 
 	virtual void EmptyCache() {};
 
+	//--Added 2009-10-25 by Alun Bestor to access the base system path for a drive
+	char systempath[CROSS_LEN];
+	char * getSystemPath(void);
+	
+	//Added 2010-12-11 by Alun Bestor to give Boxer the ability to do directory cache lookups
+	virtual bool getShortName(const char* dirpath, const char*filename, char* shortname) { return false; };
+	//--End of modifications
+	
+	DOS_Drive_Cache dirCache;
+
 	// disk cycling functionality (request resources)
 	virtual void Activate(void) {};
 };
diff --git a/include/dosbox.h b/include/dosbox.h
index c46cf0a4..f575fef1 100644
--- a/include/dosbox.h
+++ b/include/dosbox.h
@@ -23,7 +23,12 @@
 
 #include "config.h"
 
-void E_Exit(const char * message,...) GCC_ATTRIBUTE( __format__(__printf__, 1, 2));
+//--Added 2010-05-30 by Alun Bestor to ensure sdlmain function calls are replaced throughout DOSBox
+#include "BXCoalface.h"
+//--End of modifications
+
+
+//void E_Exit(const char * message,...) GCC_ATTRIBUTE( __format__(__printf__, 1, 2));
 
 void MSG_Add(const char*,const char*); //add messages to the internal langaugefile
 const char* MSG_Get(char const *);     //get messages from the internal langaugafile
diff --git a/include/joystick.h b/include/joystick.h
index fe39e5e3..51481f6d 100644
--- a/include/joystick.h
+++ b/include/joystick.h
@@ -45,6 +45,9 @@ enum JoystickType {
 	JOY_CH
 };
 
+//--Added 2011-05-08 by Alun Bestor to let Boxer set and retrieve the gameport timing mode.
+extern bool gameport_timed;
+//--End of modifications
 extern JoystickType joytype;
 extern bool button_wrapping_enabled;
 #endif
diff --git a/include/keyboard.h b/include/keyboard.h
index 0e60f290..7d31d674 100644
--- a/include/keyboard.h
+++ b/include/keyboard.h
@@ -47,7 +47,11 @@ enum KBD_KEYS {
 	KBD_LAST
 };
 
+//--Modified 2011-04-26 by Alun Bestor to make enum declaration C-compatible
+typedef enum KBD_KEYS KBD_KEYS;
+//--End of modifications
+
 void KEYBOARD_ClrBuffer(void);
 void KEYBOARD_AddKey(KBD_KEYS keytype,bool pressed);
-
+ 
 #endif
diff --git a/include/setup.h b/include/setup.h
index db75ada8..b8da85c2 100644
--- a/include/setup.h
+++ b/include/setup.h
@@ -156,7 +156,7 @@ public:
 		min = _min;
 		max = _max;
 	}
-	void SetMinMax(Value const& min,Value const& max) {this->min = min; this->max=max;}
+	void SetMinMax(Value const& minVal,Value const& maxVal) {this->min = minVal; this->max=maxVal;}
 	void SetValue(std::string const& in);
 	~Prop_int(){ }
 	virtual bool CheckValue(Value const& in, bool warn);
diff --git a/include/shell.h b/include/shell.h
index 7d1f3c05..a8cd48d5 100644
--- a/include/shell.h
+++ b/include/shell.h
@@ -40,8 +40,13 @@ extern Bitu call_shellstop;
  * by "external" programs. (config) */
 extern Program * first_shell;
 
+
 class DOS_Shell;
 
+//--Added 2013-09-22 by Alun Bestor to let Boxer talk to the currently active shell
+extern DOS_Shell * currentShell;
+//--End of modifications
+
 class BatchFile {
 public:
 	BatchFile(DOS_Shell * host,char const* const resolved_name,char const* const entered_name, char const * const cmd_line);
@@ -66,7 +71,7 @@ private:
 
 	char *completion_start;
 	Bit16u completion_index;
-	
+    
 public:
 
 	DOS_Shell();
diff --git a/include/timer.h b/include/timer.h
index b4be740e..51cda74f 100644
--- a/include/timer.h
+++ b/include/timer.h
@@ -20,7 +20,10 @@
 #define DOSBOX_TIMER_H
 
 /* underlying clock rate in HZ */
-#include <SDL.h>
+//--Modified 2009-02-26 by Alun Bestor to change from <SDL.h>, which was the wrong notation for a locally-included file
+//#include "SDL.h"
+#include "SDL.h"
+//--End of modifications
 
 #define PIT_TICK_RATE 1193182
 
diff --git a/src/cpu/callback.cpp b/src/cpu/callback.cpp
index 4ca8e458..e93d00d3 100644
--- a/src/cpu/callback.cpp
+++ b/src/cpu/callback.cpp
@@ -65,7 +65,7 @@ void CALLBACK_Idle(void) {
 	Bit16u oldcs=SegValue(cs);
 	Bit32u oldeip=reg_eip;
 	SegSet16(cs,CB_SEG);
-	reg_eip=call_idle*CB_SIZE;
+    reg_eip=CB_SOFFSET+call_idle*CB_SIZE;
 	DOSBOX_RunMachine();
 	reg_eip=oldeip;
 	SegSet16(cs,oldcs);
diff --git a/src/cpu/core_dyn_x86.cpp b/src/cpu/core_dyn_x86.cpp
index 851a04ed..0c018d7d 100644
--- a/src/cpu/core_dyn_x86.cpp
+++ b/src/cpu/core_dyn_x86.cpp
@@ -64,7 +64,7 @@
 #if 0
 #define DYN_LOG	LOG_MSG
 #else 
-#define DYN_LOG
+#define DYN_LOG(...) do {} while (0)
 #endif
 
 #if C_FPU
diff --git a/src/cpu/core_dyn_x86/cache.h b/src/cpu/core_dyn_x86/cache.h
index b5bc7b54..8566e321 100644
--- a/src/cpu/core_dyn_x86/cache.h
+++ b/src/cpu/core_dyn_x86/cache.h
@@ -318,12 +318,12 @@ public:
 		}
 		return 0;
 	}
-	HostPt GetHostReadPt(Bitu phys_page) { 
-		hostmem=old_pagehandler->GetHostReadPt(phys_page);
+	HostPt GetHostReadPt(Bitu _phys_page) { 
+		hostmem=old_pagehandler->GetHostReadPt(_phys_page);
 		return hostmem;
 	}
-	HostPt GetHostWritePt(Bitu phys_page) { 
-		return GetHostReadPt( phys_page );
+	HostPt GetHostWritePt(Bitu _phys_page) { 
+		return GetHostReadPt( _phys_page );
 	}
 public:
 	Bit8u write_map[4096];
diff --git a/src/cpu/core_dyn_x86/decoder.h b/src/cpu/core_dyn_x86/decoder.h
index 0f024541..3661b5a7 100644
--- a/src/cpu/core_dyn_x86/decoder.h
+++ b/src/cpu/core_dyn_x86/decoder.h
@@ -1993,7 +1993,7 @@ static CacheBlock * CreateCacheBlock(CodePageHandler * codepage,PhysPt start,Bit
 /* Init a load of variables */
 	decode.code_start=start;
 	decode.code=start;
-	Bitu cycles=0;
+	//Bitu cycles=0;
 	decode.page.code=codepage;
 	decode.page.index=start&4095;
 	decode.page.wmap=codepage->write_map;
diff --git a/src/cpu/core_dyn_x86/dyn_fpu.h b/src/cpu/core_dyn_x86/dyn_fpu.h
index ab23152c..d0e55bbe 100644
--- a/src/cpu/core_dyn_x86/dyn_fpu.h
+++ b/src/cpu/core_dyn_x86/dyn_fpu.h
@@ -99,7 +99,7 @@ static void dyn_fpu_esc0(){
 	if (decode.modrm.val >= 0xc0) { 
 		dyn_fpu_top();
 		Bitu group=(decode.modrm.val >> 3) & 7;
-		Bitu sub=(decode.modrm.val & 7);
+		//Bitu sub=(decode.modrm.val & 7);
 		switch (group){
 		case 0x00:		//FADD ST,STi /
 			gen_call_function((void*)&FPU_FADD,"%Ddr%Ddr",DREG(TMPB),DREG(EA));
@@ -425,7 +425,7 @@ static void dyn_fpu_esc3(){
 static void dyn_fpu_esc4(){
 	dyn_get_modrm();  
 	Bitu group=(decode.modrm.val >> 3) & 7;
-	Bitu sub=(decode.modrm.val & 7);
+	//Bitu sub=(decode.modrm.val & 7);
 	if (decode.modrm.val >= 0xc0) { 
 		dyn_fpu_top();
 		switch(group){
diff --git a/src/cpu/core_dyn_x86/dyn_fpu_dh.h b/src/cpu/core_dyn_x86/dyn_fpu_dh.h
index cc48a02f..16b3b928 100644
--- a/src/cpu/core_dyn_x86/dyn_fpu_dh.h
+++ b/src/cpu/core_dyn_x86/dyn_fpu_dh.h
@@ -315,8 +315,8 @@ static void dh_fpu_esc3(){
 
 static void dh_fpu_esc4(){
 	dyn_get_modrm();  
-	Bitu group=(decode.modrm.val >> 3) & 7;
-	Bitu sub=(decode.modrm.val & 7);
+	//Bitu group=(decode.modrm.val >> 3) & 7;
+	//Bitu sub=(decode.modrm.val & 7);
 	if (decode.modrm.val >= 0xc0) { 
 		cache_addb(0xdc);
 		cache_addb(decode.modrm.val);
@@ -388,8 +388,8 @@ static void dh_fpu_esc5(){
 
 static void dh_fpu_esc6(){
 	dyn_get_modrm();  
-	Bitu group=(decode.modrm.val >> 3) & 7;
-	Bitu sub=(decode.modrm.val & 7);
+	//Bitu group=(decode.modrm.val >> 3) & 7;
+	//Bitu sub=(decode.modrm.val & 7);
 	if (decode.modrm.val >= 0xc0) { 
 		cache_addb(0xde);
 		cache_addb(decode.modrm.val);
diff --git a/src/cpu/core_dyn_x86/risc_x86.h b/src/cpu/core_dyn_x86/risc_x86.h
index 849b433a..b7826a8d 100644
--- a/src/cpu/core_dyn_x86/risc_x86.h
+++ b/src/cpu/core_dyn_x86/risc_x86.h
@@ -368,6 +368,7 @@ static void gen_dop_byte_imm(DualOps op,DynReg * dr1,Bit8u di1,Bitu imm) {
 					goto finish;
 	default:
 		IllegalOption("gen_dop_byte_imm");
+        return;
 	}
 	dr1->flags|=DYNFLG_CHANGED;
 nochange:
@@ -392,6 +393,7 @@ static void gen_dop_byte_imm_mem(DualOps op,DynReg * dr1,Bit8u di1,void* data) {
 	case DOP_MOV:	tmp=0x0585; break;
 	default:
 		IllegalOption("gen_dop_byte_imm_mem");
+        return;
 	}
 	dr1->flags|=DYNFLG_CHANGED;
 nochange:
@@ -544,6 +546,7 @@ static void gen_dop_word_imm(DualOps op,bool dword,DynReg * dr1,Bits imm) {
 	case DOP_MOV:	cache_addb(0xb8+(gr1->index)); dr1->flags|=DYNFLG_CHANGED; goto finish;
 	default:
 		IllegalOption("gen_dop_word_imm");
+        return;
 	}
 	dr1->flags|=DYNFLG_CHANGED;
 nochange:
@@ -572,6 +575,7 @@ static void gen_dop_word_imm_mem(DualOps op,bool dword,DynReg * dr1,void* data)
 		return;
 	default:
 		IllegalOption("gen_dop_word_imm_mem");
+        return;
 	}
 	dr1->flags|=DYNFLG_CHANGED;
 nochange:
diff --git a/src/cpu/cpu.cpp b/src/cpu/cpu.cpp
index 363b091b..aabd3d8a 100644
--- a/src/cpu/cpu.cpp
+++ b/src/cpu/cpu.cpp
@@ -1582,6 +1582,9 @@ void CPU_SET_CRX(Bitu cr,Bitu value) {
 				}
 #endif
 				CPU_AutoDetermineMode<<=CPU_AUTODETERMINE_SHIFT;
+				//--Added 2010-06-23 for Boxer to pick up on automatic changes to the CPU core
+				GFX_SetTitle(-1,-1,false);
+				//--End of modifications
 			} else {
 				cpu.pmode=false;
 				if (value & CR0_PAGING) LOG_MSG("Paging requested without PE=1");
diff --git a/src/cpu/lazyflags.h b/src/cpu/lazyflags.h
index a2a031d7..7812cb37 100644
--- a/src/cpu/lazyflags.h
+++ b/src/cpu/lazyflags.h
@@ -17,7 +17,7 @@
  */
 
 #if !defined __LAZYFLAGS_H
-#define __LAZYFLAG_H
+#define __LAZYFLAGS_H
 
 //Flag Handling
 Bit32u get_CF(void);
diff --git a/src/dos/cdrom.cpp b/src/dos/cdrom.cpp
index 2a4b7118..5e465be0 100644
--- a/src/dos/cdrom.cpp
+++ b/src/dos/cdrom.cpp
@@ -51,6 +51,14 @@ bool CDROM_Interface_SDL::SetDevice(char* path, int forceCD) {
 	int num = SDL_CDNumDrives();
 	if ((forceCD>=0) && (forceCD<num)) {
 		driveID = forceCD;
+			//--Added 2009-12-31 by Alun Bestor: shut down and restart the CDROM subsystem to reset SDL's
+			//cached file information about the CD-ROM volumes
+			//This is needed otherwise SDL persists invalid file pointers to the CD-ROM and its tracks,
+			//way to go guys
+			SDL_QuitSubSystem(SDL_INIT_CDROM);
+			SDL_Init(SDL_INIT_CDROM);
+			//--End of modifications
+		
 	        cd = SDL_CDOpen(driveID);
 	        SDL_CDStatus(cd);
 	   	return true;
@@ -60,6 +68,14 @@ bool CDROM_Interface_SDL::SetDevice(char* path, int forceCD) {
 	for (int i=0; i<num; i++) {
 		cdname = SDL_CDName(i);
 		if (strcmp(buffer,cdname)==0) {
+			//--Added 2009-12-31 by Alun Bestor: shut down and restart the CDROM subsystem to reset SDL's
+			//cached file information about the CD-ROM volumes
+			//This is needed otherwise SDL persists invalid file pointers to the CD-ROM and its tracks,
+			//way to go guys
+			SDL_QuitSubSystem(SDL_INIT_CDROM);
+			SDL_Init(SDL_INIT_CDROM);
+			//--End of modifications
+			
 			cd = SDL_CDOpen(i);
 			SDL_CDStatus(cd);
 			driveID = i;
@@ -118,8 +134,13 @@ bool CDROM_Interface_SDL::GetMediaTrayStatus(bool& mediaPresent, bool& mediaChan
 
 bool CDROM_Interface_SDL::PlayAudioSector(unsigned long start,unsigned long len) { 
 	// Has to be there, otherwise wrong cd status report (dunno why, sdl bug ?)
+	//--Disabled 2009-12-30 by Alun Bestor: no it doesn't, in fact disabling and reenabling the CD like this
+	//kills the track listing in OS X owing to another SDL bug.
+	/*
 	SDL_CDClose(cd);
 	cd = SDL_CDOpen(driveID);
+	*/
+	//--End of modifications
 	bool success = (SDL_CDPlay(cd,start+150,len)==0);
 	return success;
 }
@@ -133,8 +154,13 @@ bool CDROM_Interface_SDL::PauseAudio(bool resume) {
 
 bool CDROM_Interface_SDL::StopAudio(void) {
 	// Has to be there, otherwise wrong cd status report (dunno why, sdl bug ?)
+	//--Disabled 2009-12-30 by Alun Bestor: no it doesn't, in fact disabling and reenabling the CD like this
+	//kills the track listing in OS X owing to another SDL bug.
+	/*
 	SDL_CDClose(cd);
 	cd = SDL_CDOpen(driveID);
+	*/
+	//--End of modifications
 	bool success = (SDL_CDStop(cd)==0);
 	return success;
 }
diff --git a/src/dos/cdrom.h b/src/dos/cdrom.h
index 241839be..cecbddce 100644
--- a/src/dos/cdrom.h
+++ b/src/dos/cdrom.h
@@ -1,3 +1,21 @@
+/*
+ *  Copyright (C) 2002-2011  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
 
 #ifndef __CDROM_INTERFACE__
 #define __CDROM_INTERFACE__
@@ -31,41 +49,47 @@ typedef struct SMSF {
 	unsigned char fr;
 } TMSF;
 
+typedef struct SCtrl {
+	Bit8u	out[4];			// output channel
+	Bit8u	vol[4];			// channel volume
+} TCtrl;
+
 extern int CDROM_GetMountType(char* path, int force);
 
 class CDROM_Interface
 {
 public:
-//	CDROM_Interface						(void);
+    //	CDROM_Interface						(void);
 	virtual ~CDROM_Interface			(void) {};
-
+    
 	virtual bool	SetDevice			(char* path, int forceCD) = 0;
-
+    
 	virtual bool	GetUPC				(unsigned char& attr, char* upc) = 0;
-
+    
 	virtual bool	GetAudioTracks		(int& stTrack, int& end, TMSF& leadOut) = 0;
 	virtual bool	GetAudioTrackInfo	(int track, TMSF& start, unsigned char& attr) = 0;
 	virtual bool	GetAudioSub			(unsigned char& attr, unsigned char& track, unsigned char& index, TMSF& relPos, TMSF& absPos) = 0;
 	virtual bool	GetAudioStatus		(bool& playing, bool& pause) = 0;
 	virtual bool	GetMediaTrayStatus	(bool& mediaPresent, bool& mediaChanged, bool& trayOpen) = 0;
-
+    
 	virtual bool	PlayAudioSector		(unsigned long start,unsigned long len) = 0;
 	virtual bool	PauseAudio			(bool resume) = 0;
 	virtual bool	StopAudio			(void) = 0;
+	virtual void	ChannelControl		(TCtrl ctrl) = 0;
 	
 	virtual bool	ReadSectors			(PhysPt buffer, bool raw, unsigned long sector, unsigned long num) = 0;
-
+    
 	virtual bool	LoadUnloadMedia		(bool unload) = 0;
 	
 	virtual void	InitNewMedia		(void) {};
-};	
+};
 
 class CDROM_Interface_SDL : public CDROM_Interface
 {
 public:
 	CDROM_Interface_SDL			(void);
 	virtual ~CDROM_Interface_SDL(void);
-
+    
 	virtual bool	SetDevice			(char* path, int forceCD);
 	virtual bool	GetUPC				(unsigned char& attr, char* upc) { attr = 0; strcpy(upc,"UPC"); return true; };
 	virtual bool	GetAudioTracks		(int& stTrack, int& end, TMSF& leadOut);
@@ -76,13 +100,14 @@ public:
 	virtual bool	PlayAudioSector		(unsigned long start,unsigned long len);
 	virtual bool	PauseAudio			(bool resume);
 	virtual bool	StopAudio			(void);
+	virtual void	ChannelControl		(TCtrl ctrl) { return; };
 	virtual bool	ReadSectors			(PhysPt /*buffer*/, bool /*raw*/, unsigned long /*sector*/, unsigned long /*num*/) { return false; };
 	virtual bool	LoadUnloadMedia		(bool unload);
-
+    
 private:
 	bool	Open				(void);
 	void	Close				(void);
-
+    
 	SDL_CD*	cd;
 	int		driveID;
 	Uint32	oldLeadOut;
@@ -101,9 +126,10 @@ public:
 	bool	PlayAudioSector		(unsigned long /*start*/,unsigned long /*len*/) { return true; };
 	bool	PauseAudio			(bool /*resume*/) { return true; };
 	bool	StopAudio			(void) { return true; };
+	void	ChannelControl		(TCtrl ctrl) { return; };
 	bool	ReadSectors			(PhysPt /*buffer*/, bool /*raw*/, unsigned long /*sector*/, unsigned long /*num*/) { return true; };
 	bool	LoadUnloadMedia		(bool /*unload*/) { return true; };
-};	
+};
 
 class CDROM_Interface_Image : public CDROM_Interface
 {
@@ -126,7 +152,7 @@ private:
 		std::ifstream *file;
 	};
 	
-	#if defined(C_SDL_SOUND)
+#if defined(C_SDL_SOUND)
 	class AudioFile : public TrackFile {
 	public:
 		AudioFile(const char *filename, bool &error);
@@ -139,7 +165,7 @@ private:
 		int lastCount;
 		int lastSeek;
 	};
-	#endif
+#endif
 	
 	struct Track {
 		int number;
@@ -166,28 +192,31 @@ public:
 	bool	PlayAudioSector		(unsigned long start,unsigned long len);
 	bool	PauseAudio		(bool resume);
 	bool	StopAudio		(void);
+	void	ChannelControl		(TCtrl ctrl);
 	bool	ReadSectors		(PhysPt buffer, bool raw, unsigned long sector, unsigned long num);
 	bool	LoadUnloadMedia		(bool unload);
 	bool	ReadSector		(Bit8u *buffer, bool raw, unsigned long sector);
 	bool	HasDataTrack		(void);
 	
-static	CDROM_Interface_Image* images[26];
-
+    static	CDROM_Interface_Image* images[26];
+    
 private:
 	// player
-static	void	CDAudioCallBack(Bitu len);
+    static	void	CDAudioCallBack(Bitu len);
 	int	GetTrack(int sector);
-
-static  struct imagePlayer {
+    
+    static  struct imagePlayer {
 		CDROM_Interface_Image *cd;
 		MixerChannel   *channel;
 		SDL_mutex 	*mutex;
 		Bit8u   buffer[8192];
 		int     bufLen;
-		int     currFrame;	
+		int     currFrame;
 		int     targetFrame;
 		bool    isPlaying;
 		bool    isPaused;
+		bool    ctrlUsed;
+		TCtrl   ctrlData;
 	} player;
 	
 	void 	ClearTracks();
@@ -200,10 +229,10 @@ static  struct imagePlayer {
 	bool	GetCueFrame(int &frames, std::istream &in);
 	bool	GetCueString(std::string &str, std::istream &in);
 	bool	AddTrack(Track &curr, int &shift, int prestart, int &totalPregap, int currPregap);
-
-static	int	refCount;
+    
+    static	int	refCount;
 	std::vector<Track>	tracks;
-typedef	std::vector<Track>::iterator	track_it;
+    typedef	std::vector<Track>::iterator	track_it;
 	std::string	mcn;
 	Bit8u	subUnit;
 };
@@ -213,30 +242,31 @@ typedef	std::vector<Track>::iterator	track_it;
 #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
 
 #include <windows.h>
-#include "wnaspi32.h"			// Aspi stuff 
+#include "wnaspi32.h"			// Aspi stuff
 
 class CDROM_Interface_Aspi : public CDROM_Interface
 {
 public:
 	CDROM_Interface_Aspi		(void);
 	virtual ~CDROM_Interface_Aspi(void);
-
+    
 	bool	SetDevice			(char* path, int forceCD);
-
+    
 	bool	GetUPC				(unsigned char& attr, char* upc);
-
+    
 	bool	GetAudioTracks		(int& stTrack, int& end, TMSF& leadOut);
 	bool	GetAudioTrackInfo	(int track, TMSF& start, unsigned char& attr);
 	bool	GetAudioSub			(unsigned char& attr, unsigned char& track, unsigned char& index, TMSF& relPos, TMSF& absPos);
 	bool	GetAudioStatus		(bool& playing, bool& pause);
 	bool	GetMediaTrayStatus	(bool& mediaPresent, bool& mediaChanged, bool& trayOpen);
-
+    
 	bool	PlayAudioSector		(unsigned long start,unsigned long len);
 	bool	PauseAudio			(bool resume);
 	bool	StopAudio			(void);
+	void	ChannelControl		(TCtrl ctrl) { return; };
 	
 	bool	ReadSectors			(PhysPt buffer, bool raw, unsigned long sector, unsigned long num);
-
+    
 	bool	LoadUnloadMedia		(bool unload);
 	
 private:
@@ -247,13 +277,13 @@ private:
 	bool	ScanRegistry		(HKEY& hKeyBase);
 	BYTE	GetHostAdapter		(char* hardwareID);
 	bool	GetVendor			(BYTE HA_num, BYTE SCSI_Id, BYTE SCSI_Lun, char* szBuffer);
-		
+    
 	// ASPI stuff
 	BYTE	haId;
 	BYTE	target;
 	BYTE	lun;
 	char	letter;
-
+    
 	// Windows stuff
 	HINSTANCE	hASPI;
 	HANDLE		hEvent;											// global event
@@ -267,52 +297,53 @@ class CDROM_Interface_Ioctl : public CDROM_Interface
 public:
 	enum cdioctl_cdatype { CDIOCTL_CDA_DIO, CDIOCTL_CDA_MCI, CDIOCTL_CDA_DX };
 	cdioctl_cdatype cdioctl_cda_selected;
-
+    
 	CDROM_Interface_Ioctl		(cdioctl_cdatype ioctl_cda);
 	virtual ~CDROM_Interface_Ioctl(void);
-
+    
 	bool	SetDevice			(char* path, int forceCD);
-
+    
 	bool	GetUPC				(unsigned char& attr, char* upc);
-
+    
 	bool	GetAudioTracks		(int& stTrack, int& end, TMSF& leadOut);
 	bool	GetAudioTrackInfo	(int track, TMSF& start, unsigned char& attr);
 	bool	GetAudioSub			(unsigned char& attr, unsigned char& track, unsigned char& index, TMSF& relPos, TMSF& absPos);
 	bool	GetAudioStatus		(bool& playing, bool& pause);
 	bool	GetMediaTrayStatus	(bool& mediaPresent, bool& mediaChanged, bool& trayOpen);
-
+    
 	bool	PlayAudioSector		(unsigned long start,unsigned long len);
 	bool	PauseAudio			(bool resume);
 	bool	StopAudio			(void);
+	void	ChannelControl		(TCtrl ctrl);
 	
 	bool	ReadSector			(Bit8u *buffer, bool raw, unsigned long sector);
 	bool	ReadSectors			(PhysPt buffer, bool raw, unsigned long sector, unsigned long num);
-
+    
 	bool	LoadUnloadMedia		(bool unload);
-
+    
 	void	InitNewMedia		(void) { Close(); Open(); };
 private:
-
+    
 	bool	Open				(void);
 	void	Close				(void);
-
+    
 	char	pathname[32];
 	HANDLE	hIOCTL;
 	TMSF	oldLeadOut;
-
-
+    
+    
 	/* track start/length data */
 	bool	track_start_valid;
 	int		track_start_first,track_start_last;
 	int		track_start[128];
-
+    
 	bool	GetAudioTracksAll	(void);
-
-
+    
+    
 	/* mci audio cd interface */
 	bool	use_mciplay;
 	int		mci_devid;
-
+    
 	bool	mci_CDioctl				(UINT msg, DWORD flags, void *arg);
 	bool	mci_CDOpen				(char drive);
 	bool	mci_CDClose				(void);
@@ -322,11 +353,11 @@ private:
 	bool	mci_CDStop				(void);
 	int		mci_CDStatus			(void);
 	bool	mci_CDPosition			(int *position);
-
-
+    
+    
 	/* digital audio extraction cd interface */
 	static void dx_CDAudioCallBack(Bitu len);
-
+    
 	bool	use_dxplay;
 	static  struct dxPlayer {
 		CDROM_Interface_Ioctl *cd;
@@ -334,12 +365,14 @@ private:
 		SDL_mutex		*mutex;
 		Bit8u   buffer[8192];
 		int     bufLen;
-		int     currFrame;	
+		int     currFrame;
 		int     targetFrame;
 		bool    isPlaying;
 		bool    isPaused;
+		bool    ctrlUsed;
+		TCtrl   ctrlData;
 	} player;
-
+    
 };
 
 #endif /* WIN 32 */
@@ -350,15 +383,15 @@ class CDROM_Interface_Ioctl : public CDROM_Interface_SDL
 {
 public:
 	CDROM_Interface_Ioctl		(void);
-
+    
 	bool	SetDevice		(char* path, int forceCD);
 	bool	GetUPC			(unsigned char& attr, char* upc);
 	bool	ReadSectors		(PhysPt buffer, bool raw, unsigned long sector, unsigned long num);
-
+    
 private:
 	char	device_name[512];
 };
 
 #endif /* LINUX */
 
-#endif /* __CDROM_INTERFACE__ */
+#endif /* __CDROM_INTERFACE__ */
\ No newline at end of file
diff --git a/src/dos/cdrom_image.cpp b/src/dos/cdrom_image.cpp
index d7bcfa66..7113d1a1 100644
--- a/src/dos/cdrom_image.cpp
+++ b/src/dos/cdrom_image.cpp
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2002-2010  The DOSBox Team
+ *  Copyright (C) 2002-2011  The DOSBox Team
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -16,7 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: cdrom_image.cpp,v 1.24 2009-03-19 20:45:42 c2woody Exp $ */
 
 #include <cctype>
 #include <cmath>
@@ -131,12 +130,12 @@ int CDROM_Interface_Image::AudioFile::getLength()
 int CDROM_Interface_Image::refCount = 0;
 CDROM_Interface_Image* CDROM_Interface_Image::images[26];
 CDROM_Interface_Image::imagePlayer CDROM_Interface_Image::player = {
-	NULL, NULL, NULL, {0}, 0, 0, 0, false, false };
+	NULL, NULL, NULL, {0}, 0, 0, 0, false, false, false, {{0}} };
 
-	
-CDROM_Interface_Image::CDROM_Interface_Image(Bit8u subUnit)
+
+CDROM_Interface_Image::CDROM_Interface_Image(Bit8u _subUnit)
 {
-	images[subUnit] = this;
+	images[_subUnit] = this;
 	if (refCount == 0) {
 		player.mutex = SDL_CreateMutex();
 		if (!player.channel) {
@@ -167,11 +166,15 @@ bool CDROM_Interface_Image::SetDevice(char* path, int forceCD)
 	if (LoadCueSheet(path)) return true;
 	if (LoadIsoFile(path)) return true;
 	
+    //--Disabled 2012-11-07 by Alun Bestor: this is already covered by our own error messages.
+    /*
 	// print error message on dosbox console
 	char buf[MAX_LINE_LENGTH];
 	snprintf(buf, MAX_LINE_LENGTH, "Could not load image file: %s\n", path);
 	Bit16u size = (Bit16u)strlen(buf);
 	DOS_WriteFile(STDOUT, (Bit8u*)buf, &size);
+     */
+    //--End of modifications
 	return false;
 }
 
@@ -236,7 +239,7 @@ bool CDROM_Interface_Image::PlayAudioSector(unsigned long start,unsigned long le
 	if(track >= 0 && tracks[track].attr == 0x40) {
 		LOG(LOG_MISC,LOG_WARN)("Game tries to play the data track. Not doing this");
 		player.isPlaying = false;
-		//Unclear wether return false should be here. 
+		//Unclear wether return false should be here.
 		//specs say that this function returns at once and games should check the status wether the audio is actually playing
 		//Real drives either fail or succeed as well
 	} else player.isPlaying = true;
@@ -247,7 +250,6 @@ bool CDROM_Interface_Image::PlayAudioSector(unsigned long start,unsigned long le
 
 bool CDROM_Interface_Image::PauseAudio(bool resume)
 {
-	if (!player.isPlaying) return false;
 	player.isPaused = !resume;
 	return true;
 }
@@ -259,6 +261,12 @@ bool CDROM_Interface_Image::StopAudio(void)
 	return true;
 }
 
+void CDROM_Interface_Image::ChannelControl(TCtrl ctrl)
+{
+	player.ctrlUsed = (ctrl.out[0]!=0 || ctrl.out[1]!=1 || ctrl.vol[0]<0xfe || ctrl.vol[1]<0xfe);
+	player.ctrlData = ctrl;
+}
+
 bool CDROM_Interface_Image::ReadSectors(PhysPt buffer, bool raw, unsigned long sector, unsigned long num)
 {
 	int sectorSize = raw ? RAW_SECTOR_SIZE : COOKED_SECTOR_SIZE;
@@ -270,10 +278,10 @@ bool CDROM_Interface_Image::ReadSectors(PhysPt buffer, bool raw, unsigned long s
 		success = ReadSector(&buf[i * sectorSize], raw, sector + i);
 		if (!success) break;
 	}
-
+    
 	MEM_BlockWrite(buffer, buf, buflen);
 	delete[] buf;
-
+    
 	return success;
 }
 
@@ -306,7 +314,7 @@ bool CDROM_Interface_Image::ReadSector(Bit8u *buffer, bool raw, unsigned long se
 	if (tracks[track].sectorSize != RAW_SECTOR_SIZE && raw) return false;
 	if (tracks[track].sectorSize == RAW_SECTOR_SIZE && !tracks[track].mode2 && !raw) seek += 16;
 	if (tracks[track].mode2 && !raw) seek += 24;
-
+    
 	return tracks[track].file->read(buffer, seek, length);
 }
 
@@ -336,13 +344,29 @@ void CDROM_Interface_Image::CDAudioCallBack(Bitu len)
 		}
 	}
 	SDL_mutexV(player.mutex);
+	if (player.ctrlUsed) {
+		Bit16s sample0,sample1;
+		Bit16s * samples=(Bit16s *)&player.buffer;
+		for (Bitu pos=0;pos<len/4;pos++) {
 #if defined(WORDS_BIGENDIAN)
-	player.channel->AddSamples_s16_nonnative(len/4,(Bit16s *)player.buffer);
+			sample0=(Bit16s)host_readw((HostPt)&samples[pos*2+player.ctrlData.out[0]]);
+			sample1=(Bit16s)host_readw((HostPt)&samples[pos*2+player.ctrlData.out[1]]);
 #else
-	player.channel->AddSamples_s16(len/4,(Bit16s *)player.buffer);
+			sample0=samples[pos*2+player.ctrlData.out[0]];
+			sample1=samples[pos*2+player.ctrlData.out[1]];
 #endif
-	memmove(player.buffer, &player.buffer[len], player.bufLen - len);
-	player.bufLen -= len;
+			samples[pos*2+0]=(Bit16s)(sample0*player.ctrlData.vol[0]/255.0);
+			samples[pos*2+1]=(Bit16s)(sample1*player.ctrlData.vol[1]/255.0);
+		}
+#if defined(WORDS_BIGENDIAN)
+		player.channel->AddSamples_s16(len/4,(Bit16s *)player.buffer);
+	} else	player.channel->AddSamples_s16_nonnative(len/4,(Bit16s *)player.buffer);
+#else
+}
+player.channel->AddSamples_s16(len/4,(Bit16s *)player.buffer);
+#endif
+memmove(player.buffer, &player.buffer[len], player.bufLen - len);
+player.bufLen -= len;
 }
 
 bool CDROM_Interface_Image::LoadIsoFile(char* filename)
@@ -366,13 +390,13 @@ bool CDROM_Interface_Image::LoadIsoFile(char* filename)
 		track.mode2 = false;
 	} else if (CanReadPVD(track.file, RAW_SECTOR_SIZE, false)) {
 		track.sectorSize = RAW_SECTOR_SIZE;
-		track.mode2 = false;		
+		track.mode2 = false;
 	} else if (CanReadPVD(track.file, 2336, true)) {
 		track.sectorSize = 2336;
-		track.mode2 = true;		
+		track.mode2 = true;
 	} else if (CanReadPVD(track.file, RAW_SECTOR_SIZE, true)) {
 		track.sectorSize = RAW_SECTOR_SIZE;
-		track.mode2 = true;		
+		track.mode2 = true;
 	} else return false;
 	
 	track.length = track.file->getLength() / track.sectorSize;
@@ -385,7 +409,7 @@ bool CDROM_Interface_Image::LoadIsoFile(char* filename)
 	track.length = 0;
 	track.file = NULL;
 	tracks.push_back(track);
-
+    
 	return true;
 }
 
@@ -451,7 +475,7 @@ bool CDROM_Interface_Image::LoadCueSheet(char *cuefile)
 			track.skip = 0;
 			currPregap = 0;
 			prestart = 0;
-	
+            
 			line >> track.number;
 			string type;
 			GetCueKeyword(type, line);
@@ -500,18 +524,18 @@ bool CDROM_Interface_Image::LoadCueSheet(char *cuefile)
 			GetRealFileName(filename, pathname);
 			string type;
 			GetCueKeyword(type, line);
-
+            
 			track.file = NULL;
 			bool error = true;
 			if (type == "BINARY") {
 				track.file = new BinaryFile(filename.c_str(), error);
 			}
 #if defined(C_SDL_SOUND)
-			//The next if has been surpassed by the else, but leaving it in as not 
+			//The next if has been surpassed by the else, but leaving it in as not
 			//to break existing cue sheets that depend on this.(mine with OGG tracks specifying MP3 as type)
 			else if (type == "WAVE" || type == "AIFF" || type == "MP3") {
 				track.file = new AudioFile(filename.c_str(), error);
-			} else { 
+			} else {
 				const Sound_DecoderInfo **i;
 				for (i = Sound_AvailableDecoders(); *i != NULL; i++) {
 					if (*(*i)->extensions == type) {
@@ -530,11 +554,11 @@ bool CDROM_Interface_Image::LoadCueSheet(char *cuefile)
 		else if (command == "CATALOG") success = GetCueString(mcn, line);
 		// ignored commands
 		else if (command == "CDTEXTFILE" || command == "FLAGS" || command == "ISRC"
-			|| command == "PERFORMER" || command == "POSTGAP" || command == "REM"
-			|| command == "SONGWRITER" || command == "TITLE" || command == "") success = true;
+                 || command == "PERFORMER" || command == "POSTGAP" || command == "REM"
+                 || command == "SONGWRITER" || command == "TITLE" || command == "") success = true;
 		// failure
 		else success = false;
-
+        
 		if (!success) return false;
 	}
 	// add last track
@@ -547,7 +571,7 @@ bool CDROM_Interface_Image::LoadCueSheet(char *cuefile)
 	track.length = 0;
 	track.file = NULL;
 	if(!AddTrack(track, shift, 0, totalPregap, 0)) return false;
-
+    
 	return true;
 }
 
@@ -576,10 +600,10 @@ bool CDROM_Interface_Image::AddTrack(Track &curr, int &shift, int prestart, int
 	if (prev.file == curr.file) {
 		curr.start += shift;
 		prev.length = curr.start + totalPregap - prev.start - skip;
-		curr.skip += prev.skip + prev.length * prev.sectorSize + skip * curr.sectorSize;		
+		curr.skip += prev.skip + prev.length * prev.sectorSize + skip * curr.sectorSize;
 		totalPregap += currPregap;
 		curr.start += totalPregap;
-	// current track uses a different file as the previous track
+        // current track uses a different file as the previous track
 	} else {
 		int tmp = prev.file->getLength() - prev.skip;
 		prev.length = tmp / prev.sectorSize;
@@ -683,8 +707,8 @@ void CDROM_Interface_Image::ClearTracks()
 {
 	vector<Track>::iterator i = tracks.begin();
 	vector<Track>::iterator end = tracks.end();
-
-	TrackFile* last = NULL;	
+    
+	TrackFile* last = NULL;
 	while(i != end) {
 		Track &curr = *i;
 		if (curr.file != last) {
@@ -707,4 +731,4 @@ void CDROM_Image_Init(Section* section) {
 	Sound_Init();
 	section->AddDestroyFunction(CDROM_Image_Destroy, false);
 #endif
-}
+}
\ No newline at end of file
diff --git a/src/dos/cdrom_ioctl_win32.cpp b/src/dos/cdrom_ioctl_win32.cpp
index 9044e543..2008f86d 100644
--- a/src/dos/cdrom_ioctl_win32.cpp
+++ b/src/dos/cdrom_ioctl_win32.cpp
@@ -430,7 +430,6 @@ bool CDROM_Interface_Ioctl::PauseAudio(bool resume) {
 		return false;
 	}
 	if (use_dxplay) {
-		if (!player.isPlaying) return false;
 		player.isPaused = !resume;
 		return true;
 	}
diff --git a/src/dos/dev_con.h b/src/dos/dev_con.h
index dfd267a4..5f9fdae9 100644
--- a/src/dos/dev_con.h
+++ b/src/dos/dev_con.h
@@ -64,6 +64,15 @@ bool device_CON::Read(Bit8u * data,Bit16u * size) {
 	while (*size>count) {
 		reg_ah=(IS_EGAVGA_ARCH)?0x10:0x0;
 		CALLBACK_RunRealInt(0x16);
+        
+        //--Added 2012-08-19 by Alun Bestor to let Boxer interrupt STDIN keyboard input listening
+        if (!boxer_continueListeningForKeyEvents())
+        {
+			reg_ax=oldax;
+            return false;
+        }
+        //--End of modifications
+        
 		switch(reg_al) {
 		case 13:
 			data[count++]=0x0D;
@@ -379,6 +388,11 @@ bool device_CON::Close() {
 }
 
 Bit16u device_CON::GetInformation(void) {
+    //--Added 2012-04-15 by Alun Bestor to let Boxer inject key codes into the console.
+    if (boxer_numKeyCodesInPasteBuffer())
+        return 0x8093;
+    //--End of modifications.
+    
 	Bit16u head=mem_readw(BIOS_KEYBOARD_BUFFER_HEAD);
 	Bit16u tail=mem_readw(BIOS_KEYBOARD_BUFFER_TAIL);
 
diff --git a/src/dos/dos.cpp b/src/dos/dos.cpp
index 71cfa2fe..f126f7b7 100644
--- a/src/dos/dos.cpp
+++ b/src/dos/dos.cpp
@@ -1175,6 +1175,7 @@ public:
 		DOS_SDA(DOS_SDA_SEG,DOS_SDA_OFS).SetDrive(25); /* Else the next call gives a warning. */
 		DOS_SetDefaultDrive(25);
 	
+		
 		dos.version.major=5;
 		dos.version.minor=0;
 	
diff --git a/src/dos/dos_devices.cpp b/src/dos/dos_devices.cpp
index 7c4e2ed3..08bf1173 100644
--- a/src/dos/dos_devices.cpp
+++ b/src/dos/dos_devices.cpp
@@ -60,7 +60,9 @@ public:
 
 class device_PRN : public DOS_Device {
 public:
-   	device_PRN() { SetName("PRN");}
+	device_PRN() {
+		SetName("PRN");
+	}
 	bool Read(Bit8u * data,Bit16u * size) {
 		*size=0;
 		LOG(LOG_DOSMISC,LOG_NORMAL)("PRNDEVICE:Read called");
@@ -83,8 +85,12 @@ public:
 		*pos = 0;
 		return true;
 	}
-	Bit16u GetInformation(void) { return 0x80A0; }
-	bool Close() { return false; }
+	Bit16u GetInformation(void) {
+		return 0x80A0;
+	}
+	bool Close() {
+		return false;
+	}
 };
 
 bool DOS_Device::Read(Bit8u * data,Bit16u * size) {
diff --git a/src/dos/dos_execute.cpp b/src/dos/dos_execute.cpp
index ca9e5595..add68752 100644
--- a/src/dos/dos_execute.cpp
+++ b/src/dos/dos_execute.cpp
@@ -149,6 +149,9 @@ void DOS_Terminate(Bit16u pspseg,bool tsr,Bit8u exitcode) {
 		cpudecoder=&CPU_Core_Normal_Run;
 		CPU_CycleLeft=0;
 		CPU_Cycles=0;
+		//--Added 2010-07-02 by Alun Bestor to notify Boxer when the core mode changes
+		GFX_SetTitle(-1,-1,false);
+		//--End of modifications
 	}
 #endif
 
diff --git a/src/dos/dos_keyboard_layout.cpp b/src/dos/dos_keyboard_layout.cpp
index d6886be2..7bfbe827 100644
--- a/src/dos/dos_keyboard_layout.cpp
+++ b/src/dos/dos_keyboard_layout.cpp
@@ -84,6 +84,13 @@ public:
 	void switch_foreign_layout();
 	const char* get_layout_name();
 	const char* main_language_code();
+    
+    //--Added 2012-02-25 by Alun Bestor to support limited on-the-fly layout switching
+    bool foreign_layout_active();
+    bool is_US_layout();
+    const char *real_layout_name();
+    bool supports_language_code(const char *code);
+    //--End of modifications
 
 
 private:
@@ -749,7 +756,9 @@ Bitu keyboard_layout::read_codepage_file(const char* codepage_file_name, Bit32s
 		}
 	}
 
-	static Bit8u cpi_buf[65536];
+	//--Modified 2011-06-20 by Alun Bestor: there is no reason in the world for this to be static
+	/* static */Bit8u cpi_buf[65536];
+	//--End of modifications
 	Bit32u cpi_buf_size=0,size_of_cpxdata=0;;
 	bool upxfound=false;
 	Bit16u found_at_pos=5;
@@ -869,6 +878,11 @@ Bitu keyboard_layout::read_codepage_file(const char* codepage_file_name, Bit32s
 
 
 	start_pos=host_readd(&cpi_buf[0x13]);
+	
+	//--Added 2011-06-20 by Alun Bestor as a sanity check, preventing crashes in the event that a codepage file cannot be parsed
+	if (start_pos > cpi_buf_size) return KEYB_INVALIDCPFILE;
+	//--End of modifications
+	
 	number_of_codepages=host_readw(&cpi_buf[start_pos]);
 	start_pos+=4;
 
@@ -1025,6 +1039,27 @@ const char* keyboard_layout::main_language_code() {
 	return NULL;
 }
 
+//--Added 2012-02-25 by Alun Bestor to support limited on-the-fly layout switching
+bool keyboard_layout::supports_language_code(const char *code) {
+    Bitu code_len = strlen(code);
+    for (Bitu i=0; i<language_code_count; i++) {
+        if (!strncasecmp(code,language_codes[i],code_len)) {
+            return true;
+        }
+    }
+    return false;
+}
+
+const char* keyboard_layout::real_layout_name() {
+    return current_keyboard_file_name;
+}
+
+bool keyboard_layout::is_US_layout() {
+    return !strncasecmp(current_keyboard_file_name,"US", 2) || !strncasecmp(current_keyboard_file_name, "none", 4);
+}
+
+bool keyboard_layout::foreign_layout_active() { return use_foreign_layout; }
+//--End of modifications
 
 static keyboard_layout* loaded_layout=NULL;
 
@@ -1081,6 +1116,55 @@ const char* DOS_GetLoadedLayout(void) {
 	return NULL;
 }
 
+//--Added 2012-02-24 by Alun Bestor to let Boxer check if any layout has been loaded.
+
+const char * boxer_keyboardLayoutName()
+{
+    if (loaded_layout)
+        return loaded_layout->real_layout_name();
+    else
+        return NULL;
+}
+bool boxer_keyboardLayoutLoaded()
+{
+    return (loaded_layout != NULL);
+}
+
+bool boxer_keyboardLayoutSupported(const char *code)
+{
+    if (loaded_layout)
+    {
+        //If the current layout supports the specified language code without switching anything, yippee
+        if (loaded_layout->supports_language_code(code)) return true;
+    
+        //If we can safely swap layouts without changing codepages, yippee too
+        Bitu detectedCodepage = loaded_layout->extract_codepage(code);
+        if (detectedCodepage == dos.loaded_codepage) return true;
+    }
+    return false;
+}
+
+bool boxer_keyboardLayoutActive()
+{
+    if (loaded_layout)
+        return loaded_layout->foreign_layout_active();
+    else return false;
+}
+
+void boxer_setKeyboardLayoutActive(bool active)
+{
+    if (loaded_layout)
+    {
+        //Force-disable US layouts,
+        //to match how switch_keyboard_layout() behaves.
+        if (loaded_layout->is_US_layout()) active = false;
+        
+        if (boxer_keyboardLayoutActive() != active)
+            loaded_layout->switch_foreign_layout();
+    }
+}
+//--End of modifications
+
 
 class DOS_KeyboardLayout: public Module_base {
 public:
@@ -1090,7 +1174,7 @@ public:
 		loaded_layout=new keyboard_layout();
 
 		const char * layoutname=section->Get_string("keyboardlayout");
-
+        
 		Bits wants_dos_codepage = -1;
 		if (!strncmp(layoutname,"auto",4)) {
 #if defined (WIN32)
@@ -1237,8 +1321,14 @@ public:
 					break;
 			}
 #endif
+            
+            //--Added 2009-02-23 by Alun Bestor: if auto layout was specified, ask Boxer to provide a layout
+            const char *preferredLayout = boxer_preferredKeyboardLayout();
+            if (preferredLayout)
+                layoutname = preferredLayout;
+            //--End of modifications
 		}
-
+		
 		bool extract_codepage = true;
 		if (wants_dos_codepage>0) {
 			if ((loaded_layout->read_codepage_file("auto", (Bitu)wants_dos_codepage)) == KEYB_NOERROR) {
@@ -1251,7 +1341,7 @@ public:
 			Bitu req_codepage = loaded_layout->extract_codepage(layoutname);
 			loaded_layout->read_codepage_file("auto", req_codepage);
 		}
-
+        
 /*		if (strncmp(layoutname,"auto",4) && strncmp(layoutname,"none",4)) {
 			LOG_MSG("Loading DOS keyboard layout %s ...",layoutname);
 		} */
@@ -1265,6 +1355,13 @@ public:
 				LOG_MSG("DOS keyboard layout loaded with main language code %s for layout %s",lcode,layoutname);
 			}
 		}
+        
+        //--Added 2012-05-21 by Alun Bestor to fix US-858 layout loading up with keyboard remapping enabled.
+        if (loaded_layout->is_US_layout() && loaded_layout->foreign_layout_active())
+        {
+            loaded_layout->switch_foreign_layout();
+        }
+        //--End of modifications
 	}
 
 	~DOS_KeyboardLayout(){
diff --git a/src/dos/dos_memory.cpp b/src/dos/dos_memory.cpp
index 7bdd514d..b4730f82 100644
--- a/src/dos/dos_memory.cpp
+++ b/src/dos/dos_memory.cpp
@@ -31,9 +31,13 @@ static void DOS_CompressMemory(void) {
 	Bit16u mcb_segment=dos.firstMCB;
 	DOS_MCB mcb(mcb_segment);
 	DOS_MCB mcb_next(0);
-
-	while (mcb.GetType()!=0x5a) {
-		mcb_next.SetPt((Bit16u)(mcb_segment+mcb.GetSize()+1));
+    
+    //--Modified 2013-03-24 by Alun Bestor: safer loop in case the MCB chain
+    //has gotten corrupted. See note below under DOS_FreeProcessMemory for explanation.
+	//while (mcb.GetType()!=0x5a) {
+    while (mcb.GetType() == 0x4d) {
+    //--End of modifications
+    	mcb_next.SetPt((Bit16u)(mcb_segment+mcb.GetSize()+1));
 		if ((mcb.GetPSPSeg()==0) && (mcb_next.GetPSPSeg()==0)) {
 			mcb.SetSize(mcb.GetSize()+mcb_next.GetSize()+1);
 			mcb.SetType(mcb_next.GetType());
@@ -51,14 +55,24 @@ void DOS_FreeProcessMemory(Bit16u pspseg) {
 		if (mcb.GetPSPSeg()==pspseg) {
 			mcb.SetPSPSeg(MCB_FREE);
 		}
-		if (mcb.GetType()==0x5a) {
+        //--Modified 2013-03-24 by Alun Bestor: previous versions looped through the MCBs
+        //until they found the one explicitly marked as the last entry, but it seems at least
+        //Tyrian 2000 was occasionally fucking up the MCB chain such that the last entry
+        //isn't marked as such, causing an infinite loop.
+        //This was changed to check instead if the MCB is *not* marked as an intermediate MCB,
+        //which should break out safely in the case of memory corruption.
+        Bit8u mcbType = mcb.GetType();
+		//if (mcb.GetType()==0x5a) {
+        if (mcbType != 0x4d) {
 			/* check if currently last block reaches up to the PCJr graphics memory */
-			if ((machine==MCH_PCJR) && (mcb_segment+mcb.GetSize()==0x17fe) &&
+			if (mcbType == 0x5a && (machine==MCH_PCJR) && (mcb_segment+mcb.GetSize()==0x17fe) &&
 			   (real_readb(0x17ff,0)==0x4d) && (real_readw(0x17ff,1)==8)) {
 				/* re-enable the memory past segment 0x2000 */
 				mcb.SetType(0x4d);
 			} else break;
 		}
+        //--End of modifications
+        
 		mcb_segment+=mcb.GetSize()+1;
 		mcb.SetPt(mcb_segment);
 	}
@@ -390,11 +404,18 @@ static Bitu DOS_default_handler(void) {
 	return CBRET_NONE;
 }
 
-static	CALLBACK_HandlerObject callbackhandler;
+//--Modified 2009-12-20 by Alun Bestor to make callbackhandler a local instead of a static global,
+//to prevent CALLBACK_HandlerObject.Allocate dying with an already-installed error after shutdown-and-restart.
+//I have no idea whether this is breaking the callback or not, nor any idea how to simply 'null' this given
+//it's not a pointer. C++ noob.
+
+//static	CALLBACK_HandlerObject callbackhandler;
 void DOS_SetupMemory(void) {
 	/* Let dos claim a few bios interrupts. Makes DOSBox more compatible with 
 	 * buggy games, which compare against the interrupt table. (probably a 
 	 * broken linked list implementation) */
+	CALLBACK_HandlerObject callbackhandler;
+//--End of modifications
 	callbackhandler.Allocate(&DOS_default_handler,"DOS default int");
 	Bit16u ihseg = 0x70;
 	Bit16u ihofs = 0x08;
diff --git a/src/dos/dos_mscdex.cpp b/src/dos/dos_mscdex.cpp
index 65ab123c..1166c74b 100644
--- a/src/dos/dos_mscdex.cpp
+++ b/src/dos/dos_mscdex.cpp
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2002-2010  The DOSBox Team
+ *  Copyright (C) 2002-2011  The DOSBox Team
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -16,7 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: dos_mscdex.cpp,v 1.59 2009-04-16 12:28:30 qbix79 Exp $ */
 
 #include <string.h>
 #include <ctype.h>
@@ -52,7 +51,7 @@
 int useCdromInterface	= CDROM_USE_SDL;
 int forceCD				= -1;
 
-static Bitu MSCDEX_Strategy_Handler(void); 
+static Bitu MSCDEX_Strategy_Handler(void);
 static Bitu MSCDEX_Interrupt_Handler(void);
 
 class DOS_DeviceHeader:public MemStruct {
@@ -68,11 +67,11 @@ public:
 	void	SetName				(char const* _name)	{ MEM_BlockWrite(pt+offsetof(sDeviceHeader,name),_name,8); };
 	void	SetInterrupt		(Bit16u ofs)	{ sSave(sDeviceHeader,interrupt,ofs);			};
 	void	SetStrategy			(Bit16u ofs)	{ sSave(sDeviceHeader,strategy,ofs);			};
-
+    
 public:
-	#ifdef _MSC_VER
-	#pragma pack(1)
-	#endif
+#ifdef _MSC_VER
+#pragma pack(1)
+#endif
 	struct sDeviceHeader{
 		RealPt	nextDeviceHeader;
 		Bit16u	devAttributes;
@@ -83,30 +82,30 @@ public:
 		Bit8u	driveLetter;
 		Bit8u	numSubUnits;
 	} GCC_ATTRIBUTE(packed) TDeviceHeader;
-	#ifdef _MSC_VER
-	#pragma pack()
-	#endif
+#ifdef _MSC_VER
+#pragma pack()
+#endif
 };
 
 class CMscdex {
 public:
 	CMscdex		(void);
 	~CMscdex	(void);
-
+    
 	Bit16u		GetVersion			(void)	{ return (MSCDEX_VERSION_HIGH<<8)+MSCDEX_VERSION_LOW; };
 	Bit16u		GetNumDrives		(void)	{ return numDrives;			};
 	Bit16u		GetFirstDrive		(void)	{ return dinfo[0].drive; };
 	Bit8u		GetSubUnit			(Bit16u _drive);
 	bool		GetUPC				(Bit8u subUnit, Bit8u& attr, char* upc);
-
+    
 	void		InitNewMedia		(Bit8u subUnit);
 	bool		PlayAudioSector		(Bit8u subUnit, Bit32u start, Bit32u length);
 	bool		PlayAudioMSF		(Bit8u subUnit, Bit32u start, Bit32u length);
 	bool		StopAudio			(Bit8u subUnit);
 	bool		GetAudioStatus		(Bit8u subUnit, bool& playing, bool& pause, TMSF& start, TMSF& end);
-
+    
 	bool		GetSubChannelData	(Bit8u subUnit, Bit8u& attr, Bit8u& track, Bit8u &index, TMSF& rel, TMSF& abs);
-
+    
 	int			RemoveDrive			(Bit16u _drive);
 	int			AddDrive			(Bit16u _drive, char* physicalPath, Bit8u& subUnit);
 	bool 		HasDrive			(Bit16u drive);
@@ -134,14 +133,14 @@ public:
 	bool		LoadUnloadMedia		(Bit8u subUnit, bool unload);
 	bool		ResumeAudio			(Bit8u subUnit);
 	bool		GetMediaStatus		(Bit8u subUnit, bool& media, bool& changed, bool& trayOpen);
-
+    
 private:
-
+    
 	PhysPt		GetDefaultBuffer	(void);
 	PhysPt		GetTempBuffer		(void);
-
+    
 	Bit16u		numDrives;
-
+    
 	typedef struct SDriveInfo {
 		Bit8u	drive;			// drive letter in dosbox
 		Bit8u	physDrive;		// drive letter in system
@@ -152,21 +151,25 @@ private:
 		bool	locked;			// drive locked ?
 		bool	lastResult;		// last operation success ?
 		Bit32u	volumeSize;		// for media change
+		TCtrl	audioCtrl;		// audio channel control
 	} TDriveInfo;
-
+    
 	Bit16u				defaultBufSeg;
 	TDriveInfo			dinfo[MSCDEX_MAX_DRIVES];
 	CDROM_Interface*	cdrom[MSCDEX_MAX_DRIVES];
 	
 public:
 	Bit16u		rootDriverHeaderSeg;
+    
+	bool		ChannelControl		(Bit8u subUnit, TCtrl ctrl);
+	bool		GetChannelControl	(Bit8u subUnit, TCtrl& ctrl);
 };
 
 CMscdex::CMscdex(void) {
 	numDrives			= 0;
 	rootDriverHeaderSeg	= 0;
 	defaultBufSeg		= 0;
-
+    
 	memset(dinfo,0,sizeof(dinfo));
 	for (Bit32u i=0; i<MSCDEX_MAX_DRIVES; i++) cdrom[i] = 0;
 }
@@ -207,7 +210,7 @@ int CMscdex::RemoveDrive(Bit16u _drive)
 			break;
 		}
 	}
-
+    
 	if (idx == MSCDEX_MAX_DRIVES || (idx!=0 && idx!=GetNumDrives()-1)) return 0;
 	delete (cdrom)[idx];
 	if (idx==0) {
@@ -225,7 +228,7 @@ int CMscdex::RemoveDrive(Bit16u _drive)
 		memset(&dinfo[idx],0,sizeof(TDriveInfo));
 	}
 	numDrives--;
-
+    
 	if (GetNumDrives() == 0) {
 		DOS_DeviceHeader devHeader(PhysMake(rootDriverHeaderSeg,0));
 		Bit16u off = sizeof(DOS_DeviceHeader::sDeviceHeader);
@@ -245,75 +248,75 @@ int CMscdex::AddDrive(Bit16u _drive, char* physicalPath, Bit8u& subUnit)
 	if ((Bitu)GetNumDrives()+1>=MSCDEX_MAX_DRIVES) return 4;
 	if (GetNumDrives()) {
 		// Error check, driveletter have to be in a row
-		if (dinfo[0].drive-1!=_drive && dinfo[numDrives-1].drive+1!=_drive) 
+		if (dinfo[0].drive-1!=_drive && dinfo[numDrives-1].drive+1!=_drive)
 			return 1;
 	}
 	// Set return type to ok
 	int result = 0;
 	// Get Mounttype and init needed cdrom interface
 	switch (CDROM_GetMountType(physicalPath,forceCD)) {
-	case 0x00: {	
-		LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: Mounting physical cdrom: %s"	,physicalPath);
+        case 0x00: {
+            LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: Mounting physical cdrom: %s"	,physicalPath);
 #if defined (WIN32)
-		// Check OS
-		OSVERSIONINFO osi;
-		osi.dwOSVersionInfoSize = sizeof(osi);
-		GetVersionEx(&osi);
-		if ((osi.dwPlatformId==VER_PLATFORM_WIN32_NT) && (osi.dwMajorVersion>4)) {
-			// only WIN NT/200/XP
-			if (useCdromInterface==CDROM_USE_IOCTL_DIO) {
-				cdrom[numDrives] = new CDROM_Interface_Ioctl(CDROM_Interface_Ioctl::CDIOCTL_CDA_DIO);
-				LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: IOCTL Interface.");
-				break;
-			}
-			if (useCdromInterface==CDROM_USE_IOCTL_DX) {
-				cdrom[numDrives] = new CDROM_Interface_Ioctl(CDROM_Interface_Ioctl::CDIOCTL_CDA_DX);
-				LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: IOCTL Interface (digital audio extraction).");
-				break;
-			}
-			if (useCdromInterface==CDROM_USE_IOCTL_MCI) {
-				cdrom[numDrives] = new CDROM_Interface_Ioctl(CDROM_Interface_Ioctl::CDIOCTL_CDA_MCI);
-				LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: IOCTL Interface (media control interface).");
-				break;
-			}
-		}
-		if (useCdromInterface==CDROM_USE_ASPI) {
-			// all Wins - ASPI
-			cdrom[numDrives] = new CDROM_Interface_Aspi();
-			LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: ASPI Interface.");
-			break;
-		}
+            // Check OS
+            OSVERSIONINFO osi;
+            osi.dwOSVersionInfoSize = sizeof(osi);
+            GetVersionEx(&osi);
+            if ((osi.dwPlatformId==VER_PLATFORM_WIN32_NT) && (osi.dwMajorVersion>4)) {
+                // only WIN NT/200/XP
+                if (useCdromInterface==CDROM_USE_IOCTL_DIO) {
+                    cdrom[numDrives] = new CDROM_Interface_Ioctl(CDROM_Interface_Ioctl::CDIOCTL_CDA_DIO);
+                    LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: IOCTL Interface.");
+                    break;
+                }
+                if (useCdromInterface==CDROM_USE_IOCTL_DX) {
+                    cdrom[numDrives] = new CDROM_Interface_Ioctl(CDROM_Interface_Ioctl::CDIOCTL_CDA_DX);
+                    LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: IOCTL Interface (digital audio extraction).");
+                    break;
+                }
+                if (useCdromInterface==CDROM_USE_IOCTL_MCI) {
+                    cdrom[numDrives] = new CDROM_Interface_Ioctl(CDROM_Interface_Ioctl::CDIOCTL_CDA_MCI);
+                    LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: IOCTL Interface (media control interface).");
+                    break;
+                }
+            }
+            if (useCdromInterface==CDROM_USE_ASPI) {
+                // all Wins - ASPI
+                cdrom[numDrives] = new CDROM_Interface_Aspi();
+                LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: ASPI Interface.");
+                break;
+            }
 #endif
 #if defined (LINUX) || defined(OS2)
-		// Always use IOCTL in Linux or OS/2
-		cdrom[numDrives] = new CDROM_Interface_Ioctl();
-		LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: IOCTL Interface.");
+            // Always use IOCTL in Linux or OS/2
+            cdrom[numDrives] = new CDROM_Interface_Ioctl();
+            LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: IOCTL Interface.");
 #else
-		// Default case windows and other oses
-		cdrom[numDrives] = new CDROM_Interface_SDL();
-		LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: SDL Interface.");
+            // Default case windows and other oses
+            cdrom[numDrives] = new CDROM_Interface_SDL();
+            LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: SDL Interface.");
 #endif
 		} break;
-	case 0x01:	// iso cdrom interface	
-		LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: Mounting iso file as cdrom: %s", physicalPath);
-		cdrom[numDrives] = new CDROM_Interface_Image((Bit8u)numDrives);
-		break;
-	case 0x02:	// fake cdrom interface (directories)
-		cdrom[numDrives] = new CDROM_Interface_Fake;
-		LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: Mounting directory as cdrom: %s",physicalPath);
-		LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: You wont have full MSCDEX support !");
-		result = 5;
-		break;
-	default	:	// weird result
-		return 6;
+        case 0x01:	// iso cdrom interface
+            LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: Mounting iso file as cdrom: %s", physicalPath);
+            cdrom[numDrives] = new CDROM_Interface_Image((Bit8u)numDrives);
+            break;
+        case 0x02:	// fake cdrom interface (directories)
+            cdrom[numDrives] = new CDROM_Interface_Fake;
+            LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: Mounting directory as cdrom: %s",physicalPath);
+            LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: You wont have full MSCDEX support !");
+            result = 5;
+            break;
+        default	:	// weird result
+            return 6;
 	};
-
+    
 	if (!cdrom[numDrives]->SetDevice(physicalPath,forceCD)) {
-//		delete cdrom[numDrives] ; mount seems to delete it
+        //		delete cdrom[numDrives] ; mount seems to delete it
 		return 3;
 	}
-
-
+    
+    
 	if (rootDriverHeaderSeg==0) {
 		
 		Bit16u driverSize = sizeof(DOS_DeviceHeader::sDeviceHeader) + 10; // 10 = Bytes for 3 callbacks
@@ -326,7 +329,7 @@ int CMscdex::AddDrive(Bit16u _drive, char* physicalPath, Bit8u& subUnit)
 		devHeader.SetDriveLetter		(_drive+1);
 		devHeader.SetNumSubUnits		(1);
 		devHeader.SetName				("MSCD001 ");
-
+        
 		//Link it in the device chain
 		Bit32u start = dos_infoblock.GetDeviceChain();
 		Bit16u segm  = (Bit16u)(start>>16);
@@ -337,7 +340,7 @@ int CMscdex::AddDrive(Bit16u _drive, char* physicalPath, Bit8u& subUnit)
 			start = real_readd(segm,offm);
 		}
 		real_writed(segm,offm,seg<<16);
-
+        
 		// Create Callback Strategy
 		Bit16u off = sizeof(DOS_DeviceHeader::sDeviceHeader);
 		Bit16u call_strategy=(Bit16u)CALLBACK_Allocate();
@@ -359,7 +362,7 @@ int CMscdex::AddDrive(Bit16u _drive, char* physicalPath, Bit8u& subUnit)
 		devHeader.SetInterrupt(off);
 		
 		rootDriverHeaderSeg = seg;
-	
+        
 	} else if (GetNumDrives() == 0) {
 		DOS_DeviceHeader devHeader(PhysMake(rootDriverHeaderSeg,0));
 		Bit16u off = sizeof(DOS_DeviceHeader::sDeviceHeader);
@@ -367,26 +370,35 @@ int CMscdex::AddDrive(Bit16u _drive, char* physicalPath, Bit8u& subUnit)
 		devHeader.SetStrategy(off);
 		devHeader.SetInterrupt(off+5);
 	}
-
-	subUnit = (Bit8u)numDrives;
+    
 	// Set drive
 	DOS_DeviceHeader devHeader(PhysMake(rootDriverHeaderSeg,0));
 	devHeader.SetNumSubUnits(devHeader.GetNumSubUnits()+1);
-
+    
 	if (dinfo[0].drive-1==_drive) {
 		CDROM_Interface *_cdrom = cdrom[numDrives];
+		CDROM_Interface_Image *_cdimg = CDROM_Interface_Image::images[numDrives];
 		for (Bit16u i=GetNumDrives(); i>0; i--) {
 			dinfo[i] = dinfo[i-1];
 			cdrom[i] = cdrom[i-1];
+			CDROM_Interface_Image::images[i] = CDROM_Interface_Image::images[i-1];
 		}
 		cdrom[0] = _cdrom;
+		CDROM_Interface_Image::images[0] = _cdimg;
 		dinfo[0].drive		= (Bit8u)_drive;
 		dinfo[0].physDrive	= (Bit8u)toupper(physicalPath[0]);
+		subUnit = 0;
 	} else {
 		dinfo[numDrives].drive		= (Bit8u)_drive;
 		dinfo[numDrives].physDrive	= (Bit8u)toupper(physicalPath[0]);
+		subUnit = (Bit8u)numDrives;
 	}
 	numDrives++;
+	// init channel control
+	for (Bit8u chan=0;chan<4;chan++) {
+		dinfo[subUnit].audioCtrl.out[chan]=chan;
+		dinfo[subUnit].audioCtrl.vol[chan]=0xff;
+	}
 	// stop audio
 	StopAudio(subUnit);
 	return result;
@@ -426,8 +438,7 @@ void CMscdex::GetDriverInfo	(PhysPt data) {
 	};
 }
 
-bool CMscdex::GetCDInfo(Bit8u subUnit, Bit8u& tr1, Bit8u& tr2, TMSF& leadOut)
-{
+bool CMscdex::GetCDInfo(Bit8u subUnit, Bit8u& tr1, Bit8u& tr2, TMSF& leadOut) {
 	if (subUnit>=numDrives) return false;
 	int tr1i,tr2i;
 	// Assume Media change
@@ -443,38 +454,35 @@ bool CMscdex::GetCDInfo(Bit8u subUnit, Bit8u& tr1, Bit8u& tr2, TMSF& leadOut)
 	return dinfo[subUnit].lastResult;
 }
 
-bool CMscdex::GetTrackInfo(Bit8u subUnit, Bit8u track, Bit8u& attr, TMSF& start)
-{
+bool CMscdex::GetTrackInfo(Bit8u subUnit, Bit8u track, Bit8u& attr, TMSF& start) {
 	if (subUnit>=numDrives) return false;
-	dinfo[subUnit].lastResult = cdrom[subUnit]->GetAudioTrackInfo(track,start,attr);	
+	dinfo[subUnit].lastResult = cdrom[subUnit]->GetAudioTrackInfo(track,start,attr);
 	if (!dinfo[subUnit].lastResult) {
 		attr = 0;
 		memset(&start,0,sizeof(start));
-	};
+	}
 	return dinfo[subUnit].lastResult;
 }
 
-bool CMscdex::PlayAudioSector(Bit8u subUnit, Bit32u sector, Bit32u length)
-{
+bool CMscdex::PlayAudioSector(Bit8u subUnit, Bit32u sector, Bit32u length) {
 	if (subUnit>=numDrives) return false;
 	// If value from last stop is used, this is meant as a resume
 	// better start using resume command
-	if (dinfo[subUnit].audioPaused && (sector==dinfo[subUnit].audioStart)) {
+	if (dinfo[subUnit].audioPaused && (sector==dinfo[subUnit].audioStart) && (dinfo[subUnit].audioEnd!=0)) {
 		dinfo[subUnit].lastResult = cdrom[subUnit]->PauseAudio(true);
-	} else 
+	} else
 		dinfo[subUnit].lastResult = cdrom[subUnit]->PlayAudioSector(sector,length);
-
+    
 	if (dinfo[subUnit].lastResult) {
 		dinfo[subUnit].audioPlay	= true;
 		dinfo[subUnit].audioPaused	= false;
 		dinfo[subUnit].audioStart	= sector;
 		dinfo[subUnit].audioEnd		= length;
-	};
+	}
 	return dinfo[subUnit].lastResult;
 }
 
-bool CMscdex::PlayAudioMSF(Bit8u subUnit, Bit32u start, Bit32u length)
-{
+bool CMscdex::PlayAudioMSF(Bit8u subUnit, Bit32u start, Bit32u length) {
 	if (subUnit>=numDrives) return false;
 	Bit8u min		= (Bit8u)(start>>16) & 0xFF;
 	Bit8u sec		= (Bit8u)(start>> 8) & 0xFF;
@@ -483,48 +491,56 @@ bool CMscdex::PlayAudioMSF(Bit8u subUnit, Bit32u start, Bit32u length)
 	return dinfo[subUnit].lastResult = PlayAudioSector(subUnit,sector,length);
 }
 
-bool CMscdex::GetSubChannelData(Bit8u subUnit, Bit8u& attr, Bit8u& track, Bit8u &index, TMSF& rel, TMSF& abs)
-{
+bool CMscdex::GetSubChannelData(Bit8u subUnit, Bit8u& attr, Bit8u& track, Bit8u &index, TMSF& rel, TMSF& abs) {
 	if (subUnit>=numDrives) return false;
 	dinfo[subUnit].lastResult = cdrom[subUnit]->GetAudioSub(attr,track,index,rel,abs);
 	if (!dinfo[subUnit].lastResult) {
 		attr = track = index = 0;
 		memset(&rel,0,sizeof(rel));
 		memset(&abs,0,sizeof(abs));
-	};
+	}
 	return dinfo[subUnit].lastResult;
 }
 
-bool CMscdex::GetAudioStatus(Bit8u subUnit, bool& playing, bool& pause, TMSF& start, TMSF& end)
-{
+bool CMscdex::GetAudioStatus(Bit8u subUnit, bool& playing, bool& pause, TMSF& start, TMSF& end) {
 	if (subUnit>=numDrives) return false;
 	dinfo[subUnit].lastResult = cdrom[subUnit]->GetAudioStatus(playing,pause);
 	if (dinfo[subUnit].lastResult) {
 		// Start
 		Bit32u addr	= dinfo[subUnit].audioStart + 150;
 		start.fr	= (Bit8u)(addr%75);	addr/=75;
-		start.sec	= (Bit8u)(addr%60); 
+		start.sec	= (Bit8u)(addr%60);
 		start.min	= (Bit8u)(addr/60);
 		// End
 		addr		= dinfo[subUnit].audioEnd + 150;
 		end.fr		= (Bit8u)(addr%75);	addr/=75;
-		end.sec		= (Bit8u)(addr%60); 
+		end.sec		= (Bit8u)(addr%60);
 		end.min		= (Bit8u)(addr/60);
 	} else {
 		playing		= false;
 		pause		= false;
 		memset(&start,0,sizeof(start));
 		memset(&end,0,sizeof(end));
-	};
+	}
 	
 	return dinfo[subUnit].lastResult;
 }
 
-bool CMscdex::StopAudio(Bit8u subUnit)
-{
+bool CMscdex::StopAudio(Bit8u subUnit) {
 	if (subUnit>=numDrives) return false;
-	if (dinfo[subUnit].audioPlay)	dinfo[subUnit].lastResult = cdrom[subUnit]->PauseAudio(false);
-	else							dinfo[subUnit].lastResult = cdrom[subUnit]->StopAudio();
+	if (dinfo[subUnit].audioPlay) {
+		// Check if audio is still playing....
+		TMSF start,end;
+		bool playing,pause;
+		if (GetAudioStatus(subUnit,playing,pause,start,end))
+			dinfo[subUnit].audioPlay = playing;
+		else
+			dinfo[subUnit].audioPlay = false;
+	}
+	if (dinfo[subUnit].audioPlay)
+		dinfo[subUnit].lastResult = cdrom[subUnit]->PauseAudio(false);
+	else
+		dinfo[subUnit].lastResult = cdrom[subUnit]->StopAudio();
 	
 	if (dinfo[subUnit].lastResult) {
 		if (dinfo[subUnit].audioPlay) {
@@ -532,13 +548,13 @@ bool CMscdex::StopAudio(Bit8u subUnit)
 			GetCurrentPos(subUnit,pos);
 			dinfo[subUnit].audioStart	= pos.min*60*75+pos.sec*75+pos.fr - 150;
 			dinfo[subUnit].audioPaused  = true;
-		} else {	
+		} else {
 			dinfo[subUnit].audioPaused  = false;
 			dinfo[subUnit].audioStart	= 0;
 			dinfo[subUnit].audioEnd		= 0;
-		};
+		}
 		dinfo[subUnit].audioPlay = false;
-	};
+	}
 	return dinfo[subUnit].lastResult;
 }
 
@@ -556,12 +572,12 @@ Bit32u CMscdex::GetVolumeSize(Bit8u subUnit) {
 	return 0;
 }
 
-bool CMscdex::ReadVTOC(Bit16u drive, Bit16u volume, PhysPt data, Bit16u& error) { 
+bool CMscdex::ReadVTOC(Bit16u drive, Bit16u volume, PhysPt data, Bit16u& error) {
 	Bit8u subunit = GetSubUnit(drive);
-/*	if (subunit>=numDrives) {
-		error=MSCDEX_ERROR_UNKNOWN_DRIVE;
-		return false;
-	} */
+    /*	if (subunit>=numDrives) {
+     error=MSCDEX_ERROR_UNKNOWN_DRIVE;
+     return false;
+     } */
 	if (!ReadSectors(subunit,false,16+volume,1,data)) {
 		error=MSCDEX_ERROR_DRIVE_NOT_READY;
 		return false;
@@ -577,10 +593,10 @@ bool CMscdex::ReadVTOC(Bit16u drive, Bit16u volume, PhysPt data, Bit16u& error)
 	return true;
 }
 
-bool CMscdex::GetVolumeName(Bit8u subUnit, char* data) {	
+bool CMscdex::GetVolumeName(Bit8u subUnit, char* data) {
 	if (subUnit>=numDrives) return false;
 	Bit16u drive = dinfo[subUnit].drive;
-
+    
 	Bit16u error;
 	bool success = false;
 	PhysPt ptoc = GetTempBuffer();
@@ -590,44 +606,59 @@ bool CMscdex::GetVolumeName(Bit8u subUnit, char* data) {
 		data[31] = 0;
 		rtrim(data);
 	};
-
-	return success; 
+    
+	return success;
 }
 
-bool CMscdex::GetCopyrightName(Bit16u drive, PhysPt data) {	
+bool CMscdex::GetCopyrightName(Bit16u drive, PhysPt data) {
 	Bit16u error;
 	bool success = false;
 	PhysPt ptoc = GetTempBuffer();
 	success = ReadVTOC(drive,0x00,ptoc,error);
 	if (success) {
-		MEM_BlockCopy(data,ptoc+702,37);
-		mem_writeb(data+37,0);
+		Bitu len;
+		for (len=0;len<37;len++) {
+			Bit8u c=mem_readb(ptoc+702+len);
+			if (c==0 || c==0x20) break;
+		}
+		MEM_BlockCopy(data,ptoc+702,len);
+		mem_writeb(data+len,0);
 	};
-	return success; 
+	return success;
 }
 
-bool CMscdex::GetAbstractName(Bit16u drive, PhysPt data) { 
+bool CMscdex::GetAbstractName(Bit16u drive, PhysPt data) {
 	Bit16u error;
 	bool success = false;
 	PhysPt ptoc = GetTempBuffer();
 	success = ReadVTOC(drive,0x00,ptoc,error);
 	if (success) {
-		MEM_BlockCopy(data,ptoc+739,37);
-		mem_writeb(data+37,0);
+		Bitu len;
+		for (len=0;len<37;len++) {
+			Bit8u c=mem_readb(ptoc+739+len);
+			if (c==0 || c==0x20) break;
+		}
+		MEM_BlockCopy(data,ptoc+739,len);
+		mem_writeb(data+len,0);
 	};
-	return success; 
+	return success;
 }
 
-bool CMscdex::GetDocumentationName(Bit16u drive, PhysPt data) { 
+bool CMscdex::GetDocumentationName(Bit16u drive, PhysPt data) {
 	Bit16u error;
 	bool success = false;
 	PhysPt ptoc = GetTempBuffer();
 	success = ReadVTOC(drive,0x00,ptoc,error);
 	if (success) {
-		MEM_BlockCopy(data,ptoc+776,37);
-		mem_writeb(data+37,0);
+		Bitu len;
+		for (len=0;len<37;len++) {
+			Bit8u c=mem_readb(ptoc+776+len);
+			if (c==0 || c==0x20) break;
+		}
+		MEM_BlockCopy(data,ptoc+776,len);
+		mem_writeb(data+len,0);
 	};
-	return success; 
+	return success;
 }
 
 bool CMscdex::GetUPC(Bit8u subUnit, Bit8u& attr, char* upc)
@@ -658,13 +689,13 @@ bool CMscdex::ReadSectors(Bit16u drive, Bit32u sector, Bit16u num, PhysPt data)
 	return ReadSectors(GetSubUnit(drive),false,sector,num,data);
 }
 
-bool CMscdex::GetDirectoryEntry(Bit16u drive, bool copyFlag, PhysPt pathname, PhysPt buffer, Bit16u& error)
-{
+bool CMscdex::GetDirectoryEntry(Bit16u drive, bool copyFlag, PhysPt pathname, PhysPt buffer, Bit16u& error) {
 	char	volumeID[6] = {0};
 	char	searchName[256];
 	char	entryName[256];
 	bool	foundComplete = false;
 	bool	foundName;
+	bool	nextPart = true;
 	char*	useName = 0;
 	Bitu	entryLength,nameLength;
 	// clear error
@@ -672,12 +703,12 @@ bool CMscdex::GetDirectoryEntry(Bit16u drive, bool copyFlag, PhysPt pathname, Ph
 	MEM_StrCopy(pathname+1,searchName,mem_readb(pathname));
 	upcase(searchName);
 	char* searchPos = searchName;
-
+    
 	//strip of tailing . (XCOM APOCALYPSE)
 	size_t searchlen = strlen(searchName);
 	if (searchlen > 1 && strcmp(searchName,".."))
 		if (searchName[searchlen-1] =='.')  searchName[searchlen-1] = 0;
-
+    
 	//LOG(LOG_MISC,LOG_ERROR)("MSCDEX: Get DirEntry : Find : %s",searchName);
 	// read vtoc
 	PhysPt defBuffer = GetDefaultBuffer();
@@ -695,14 +726,15 @@ bool CMscdex::GetDirectoryEntry(Bit16u drive, bool copyFlag, PhysPt pathname, Ph
 		if (!ReadSectors(GetSubUnit(drive),false,dirEntrySector,1,defBuffer)) return false;
 		// Get string part
 		foundName	= false;
-		if (searchPos) { 
-			useName = searchPos; 
-			searchPos = strchr(searchPos,'\\'); 
+		if (nextPart) {
+			if (searchPos) {
+				useName = searchPos;
+				searchPos = strchr(searchPos,'\\');
+			}
+			if (searchPos) { *searchPos = 0; searchPos++; }
+			else foundComplete = true;
 		}
-
-	   	if (searchPos) { *searchPos = 0; searchPos++; }
-		else foundComplete = true;
-
+        
 		do {
 			entryLength = mem_readb(defBuffer+index);
 			if (entryLength==0) break;
@@ -759,18 +791,19 @@ bool CMscdex::GetDirectoryEntry(Bit16u drive, bool copyFlag, PhysPt pathname, Ph
 			// change directory
 			dirEntrySector = mem_readd(defBuffer+index+2);
 			dirSize	= mem_readd(defBuffer+index+10);
+			nextPart = true;
 		} else {
 			// continue search in next sector
 			dirSize -= 2048;
 			dirEntrySector++;
+			nextPart = false;
 		}
-	};
+	}
 	error = 2; // file not found
 	return false; // not found
 }
 
-bool CMscdex::GetCurrentPos(Bit8u subUnit, TMSF& pos)
-{
+bool CMscdex::GetCurrentPos(Bit8u subUnit, TMSF& pos) {
 	if (subUnit>=numDrives) return false;
 	TMSF rel;
 	Bit8u attr,track,index;
@@ -779,48 +812,55 @@ bool CMscdex::GetCurrentPos(Bit8u subUnit, TMSF& pos)
 	return dinfo[subUnit].lastResult;
 }
 
-bool CMscdex::GetMediaStatus(Bit8u subUnit, bool& media, bool& changed, bool& trayOpen)
-{
+bool CMscdex::GetMediaStatus(Bit8u subUnit, bool& media, bool& changed, bool& trayOpen) {
 	if (subUnit>=numDrives) return false;
 	dinfo[subUnit].lastResult = cdrom[subUnit]->GetMediaTrayStatus(media,changed,trayOpen);
 	return dinfo[subUnit].lastResult;
 }
 
-Bit32u CMscdex::GetDeviceStatus(Bit8u subUnit)
-{
+Bit32u CMscdex::GetDeviceStatus(Bit8u subUnit) {
 	if (subUnit>=numDrives) return false;
 	bool media,changed,trayOpen;
-
+    
 	dinfo[subUnit].lastResult = GetMediaStatus(subUnit,media,changed,trayOpen);
-	Bit32u status = (trayOpen << 0)					|	// Drive is open ?
-					(dinfo[subUnit].locked	<< 1)	|	// Drive is locked ?
-					(1<<2)							|	// raw + cooked sectors
-					(1<<4)							|	// Can read sudio
-					(1<<9)							|	// Red book & HSG
-					((!media) << 11);					// Drive is empty ?
+	if (dinfo[subUnit].audioPlay) {
+		// Check if audio is still playing....
+		TMSF start,end;
+		bool playing,pause;
+		if (GetAudioStatus(subUnit,playing,pause,start,end))
+			dinfo[subUnit].audioPlay = playing;
+		else
+			dinfo[subUnit].audioPlay = false;
+	}
+    
+	Bit32u status = ((trayOpen?1:0) << 0)					|	// Drive is open ?
+    ((dinfo[subUnit].locked?1:0) << 1)		|	// Drive is locked ?
+    (1<<2)									|	// raw + cooked sectors
+    (1<<4)									|	// Can read sudio
+    (1<<8)									|	// Can control audio
+    (1<<9)									|	// Red book & HSG
+    ((dinfo[subUnit].audioPlay?1:0) << 10)	|	// Audio is playing ?
+    ((media?0:1) << 11);						// Drive is empty ?
 	return status;
 }
 
-bool CMscdex::GetMediaStatus(Bit8u subUnit, Bit8u& status)
-{
+bool CMscdex::GetMediaStatus(Bit8u subUnit, Bit8u& status) {
 	if (subUnit>=numDrives) return false;
-/*	bool media,changed,open,result;
-	result = GetMediaStatus(subUnit,media,changed,open);
-	status = changed ? 0xFF : 0x01;
-	return result; */
+    /*	bool media,changed,open,result;
+     result = GetMediaStatus(subUnit,media,changed,open);
+     status = changed ? 0xFF : 0x01;
+     return result; */
 	status = getSwapRequest() ? 0xFF : 0x01;
 	return true;
 }
 
-bool CMscdex::LoadUnloadMedia(Bit8u subUnit, bool unload)
-{
+bool CMscdex::LoadUnloadMedia(Bit8u subUnit, bool unload) {
 	if (subUnit>=numDrives) return false;
 	dinfo[subUnit].lastResult = cdrom[subUnit]->LoadUnloadMedia(unload);
 	return dinfo[subUnit].lastResult;
 }
 
-bool CMscdex::SendDriverRequest(Bit16u drive, PhysPt data)
-{
+bool CMscdex::SendDriverRequest(Bit16u drive, PhysPt data) {
 	Bit8u subUnit = GetSubUnit(drive);
 	if (subUnit>=numDrives) return false;
 	// Get SubUnit
@@ -831,13 +871,12 @@ bool CMscdex::SendDriverRequest(Bit16u drive, PhysPt data)
 	return true;
 }
 
-Bit16u CMscdex::GetStatusWord(Bit8u subUnit,Bit16u status)
-{
+Bit16u CMscdex::GetStatusWord(Bit8u subUnit,Bit16u status) {
 	if (subUnit>=numDrives) return REQUEST_STATUS_ERROR | 0x02; // error : Drive not ready
-
+    
 	if (dinfo[subUnit].lastResult)	status |= REQUEST_STATUS_DONE;				// ok
-	else							status |= REQUEST_STATUS_ERROR; 
-
+	else							status |= REQUEST_STATUS_ERROR;
+    
 	if (dinfo[subUnit].audioPlay) {
 		// Check if audio is still playing....
 		TMSF start,end;
@@ -846,9 +885,9 @@ Bit16u CMscdex::GetStatusWord(Bit8u subUnit,Bit16u status)
 			dinfo[subUnit].audioPlay = playing;
 		} else
 			dinfo[subUnit].audioPlay = false;
-
+        
 		status |= (dinfo[subUnit].audioPlay<<9);
-	} 
+	}
 	dinfo[subUnit].lastResult	= true;
 	return status;
 }
@@ -860,6 +899,22 @@ void CMscdex::InitNewMedia(Bit8u subUnit) {
 	}
 }
 
+bool CMscdex::ChannelControl(Bit8u subUnit, TCtrl ctrl) {
+	if (subUnit>=numDrives) return false;
+	// adjust strange channel mapping
+	if (ctrl.out[0]>1) ctrl.out[0]=0;
+	if (ctrl.out[1]>1) ctrl.out[1]=1;
+	dinfo[subUnit].audioCtrl=ctrl;
+	cdrom[subUnit]->ChannelControl(ctrl);
+	return true;
+}
+
+bool CMscdex::GetChannelControl(Bit8u subUnit, TCtrl& ctrl) {
+	if (subUnit>=numDrives) return false;
+	ctrl=dinfo[subUnit].audioCtrl;
+	return true;
+}
+
 static CMscdex* mscdex = 0;
 static PhysPt curReqheaderPtr = 0;
 
@@ -868,212 +923,227 @@ static Bit16u MSCDEX_IOCTL_Input(PhysPt buffer,Bit8u drive_unit) {
 	MSCDEX_LOG("MSCDEX: IOCTL INPUT Subfunction %02X",ioctl_fct);
 	switch (ioctl_fct) {
 		case 0x00 : /* Get Device Header address */
-					mem_writed(buffer+1,RealMake(mscdex->rootDriverHeaderSeg,0));
-					break;
+            mem_writed(buffer+1,RealMake(mscdex->rootDriverHeaderSeg,0));
+            break;
 		case 0x01 :{/* Get current position */
-					TMSF pos;
-					mscdex->GetCurrentPos(drive_unit,pos);
-					Bit8u addr_mode = mem_readb(buffer+1);
-					if (addr_mode==0) {			// HSG
-						Bit32u frames=MSF_TO_FRAMES(pos.min, pos.sec, pos.fr);
-						if (frames<150) MSCDEX_LOG("MSCDEX: Get position: invalid position %d:%d:%d", pos.min, pos.sec, pos.fr);
-						else frames-=150;
-						mem_writed(buffer+2,frames);
-					} else if (addr_mode==1) {	// Red book
-						mem_writeb(buffer+2,pos.fr);
-						mem_writeb(buffer+3,pos.sec);
-						mem_writeb(buffer+4,pos.min);
-						mem_writeb(buffer+5,0x00);
-					} else {
-						MSCDEX_LOG("MSCDEX: Get position: invalid address mode %x",addr_mode);
-						return 0x03;		// invalid function
-					}
-				   }break;
+            TMSF pos;
+            mscdex->GetCurrentPos(drive_unit,pos);
+            Bit8u addr_mode = mem_readb(buffer+1);
+            if (addr_mode==0) {			// HSG
+                Bit32u frames=MSF_TO_FRAMES(pos.min, pos.sec, pos.fr);
+                if (frames<150) MSCDEX_LOG("MSCDEX: Get position: invalid position %d:%d:%d", pos.min, pos.sec, pos.fr);
+                else frames-=150;
+                mem_writed(buffer+2,frames);
+            } else if (addr_mode==1) {	// Red book
+                mem_writeb(buffer+2,pos.fr);
+                mem_writeb(buffer+3,pos.sec);
+                mem_writeb(buffer+4,pos.min);
+                mem_writeb(buffer+5,0x00);
+            } else {
+                MSCDEX_LOG("MSCDEX: Get position: invalid address mode %x",addr_mode);
+                return 0x03;		// invalid function
+            }
+        }break;
+		case 0x04 : /* Audio Channel control */
+            TCtrl ctrl;
+            if (!mscdex->GetChannelControl(drive_unit,ctrl)) return 0x01;
+            for (Bit8u chan=0;chan<4;chan++) {
+                mem_writeb(buffer+chan*2+1,ctrl.out[chan]);
+                mem_writeb(buffer+chan*2+2,ctrl.vol[chan]);
+            }
+            break;
 		case 0x06 : /* Get Device status */
-					mem_writed(buffer+1,mscdex->GetDeviceStatus(drive_unit)); 
-					break;
+            mem_writed(buffer+1,mscdex->GetDeviceStatus(drive_unit));
+            break;
 		case 0x07 : /* Get sector size */
-					if (mem_readb(buffer+1)==0) mem_writed(buffer+2,2048);
-					else if (mem_readb(buffer+1)==1) mem_writed(buffer+2,2352);
-					else return 0x03;		// invalid function
-					break;
+            if (mem_readb(buffer+1)==0) mem_writed(buffer+2,2048);
+            else if (mem_readb(buffer+1)==1) mem_writed(buffer+2,2352);
+            else return 0x03;		// invalid function
+            break;
 		case 0x08 : /* Get size of current volume */
-					mem_writed(buffer+1,mscdex->GetVolumeSize(drive_unit));
-					break;
+            mem_writed(buffer+1,mscdex->GetVolumeSize(drive_unit));
+            break;
 		case 0x09 : /* Media change ? */
-					Bit8u status;
-					if (!mscdex->GetMediaStatus(drive_unit,status)) {
-						status = 0;		// state unknown
-					}
-					mem_writeb(buffer+1,status);
-					break;
-		case 0x0A : /* Get Audio Disk info */	
-					Bit8u tr1,tr2; TMSF leadOut;
-					if (!mscdex->GetCDInfo(drive_unit,tr1,tr2,leadOut)) return 0x05;
-					mem_writeb(buffer+1,tr1);
-					mem_writeb(buffer+2,tr2);
-					mem_writeb(buffer+3,leadOut.fr);
-					mem_writeb(buffer+4,leadOut.sec);
-					mem_writeb(buffer+5,leadOut.min);
-					mem_writeb(buffer+6,0x00);
-					break;
+            Bit8u status;
+            if (!mscdex->GetMediaStatus(drive_unit,status)) {
+                status = 0;		// state unknown
+            }
+            mem_writeb(buffer+1,status);
+            break;
+		case 0x0A : /* Get Audio Disk info */
+            Bit8u tr1,tr2; TMSF leadOut;
+            if (!mscdex->GetCDInfo(drive_unit,tr1,tr2,leadOut)) return 0x05;
+            mem_writeb(buffer+1,tr1);
+            mem_writeb(buffer+2,tr2);
+            mem_writeb(buffer+3,leadOut.fr);
+            mem_writeb(buffer+4,leadOut.sec);
+            mem_writeb(buffer+5,leadOut.min);
+            mem_writeb(buffer+6,0x00);
+            break;
 		case 0x0B :{/* Audio Track Info */
-					Bit8u attr; TMSF start;
-					Bit8u track = mem_readb(buffer+1);
-					mscdex->GetTrackInfo(drive_unit,track,attr,start);		
-					mem_writeb(buffer+2,start.fr);
-					mem_writeb(buffer+3,start.sec);
-					mem_writeb(buffer+4,start.min);
-					mem_writeb(buffer+5,0x00);
-					mem_writeb(buffer+6,attr);
-					break; };
+            Bit8u attr; TMSF start;
+            Bit8u track = mem_readb(buffer+1);
+            mscdex->GetTrackInfo(drive_unit,track,attr,start);
+            mem_writeb(buffer+2,start.fr);
+            mem_writeb(buffer+3,start.sec);
+            mem_writeb(buffer+4,start.min);
+            mem_writeb(buffer+5,0x00);
+            mem_writeb(buffer+6,attr);
+            break; };
 		case 0x0C :{/* Get Audio Sub Channel data */
-					Bit8u attr,track,index; 
-					TMSF abs,rel;
-					mscdex->GetSubChannelData(drive_unit,attr,track,index,rel,abs);
-					mem_writeb(buffer+1,attr);
-					mem_writeb(buffer+2,track);
-					mem_writeb(buffer+3,index);
-					mem_writeb(buffer+4,rel.min);
-					mem_writeb(buffer+5,rel.sec);
-					mem_writeb(buffer+6,rel.fr);
-					mem_writeb(buffer+7,0x00);
-					mem_writeb(buffer+8,abs.min);
-					mem_writeb(buffer+9,abs.sec);
-					mem_writeb(buffer+10,abs.fr);
-					break;
-				   };
-		case 0x0E :{ /* Get UPC */	
-					Bit8u attr; char upc[8];
-					mscdex->GetUPC(drive_unit,attr,&upc[0]);
-					mem_writeb(buffer+1,attr);
-					for (int i=0; i<7; i++) mem_writeb(buffer+2+i,upc[i]);
-					mem_writeb(buffer+9,0x00);
-					break;
-				   };
-		case 0x0F :{ /* Get Audio Status */	
-					bool playing,pause;
-					TMSF resStart,resEnd;
-					mscdex->GetAudioStatus(drive_unit,playing,pause,resStart,resEnd);
-					mem_writeb(buffer+1,pause);
-					mem_writeb(buffer+3,resStart.min);
-					mem_writeb(buffer+4,resStart.sec);
-					mem_writeb(buffer+5,resStart.fr);
-					mem_writeb(buffer+6,0x00);
-					mem_writeb(buffer+7,resEnd.min);
-					mem_writeb(buffer+8,resEnd.sec);
-					mem_writeb(buffer+9,resEnd.fr);
-					mem_writeb(buffer+10,0x00);
-					break;
-				   };
+            Bit8u attr,track,index;
+            TMSF abs,rel;
+            mscdex->GetSubChannelData(drive_unit,attr,track,index,rel,abs);
+            mem_writeb(buffer+1,attr);
+            mem_writeb(buffer+2,track);
+            mem_writeb(buffer+3,index);
+            mem_writeb(buffer+4,rel.min);
+            mem_writeb(buffer+5,rel.sec);
+            mem_writeb(buffer+6,rel.fr);
+            mem_writeb(buffer+7,0x00);
+            mem_writeb(buffer+8,abs.min);
+            mem_writeb(buffer+9,abs.sec);
+            mem_writeb(buffer+10,abs.fr);
+            break;
+        };
+		case 0x0E :{ /* Get UPC */
+            Bit8u attr; char upc[8];
+            mscdex->GetUPC(drive_unit,attr,&upc[0]);
+            mem_writeb(buffer+1,attr);
+            for (int i=0; i<7; i++) mem_writeb(buffer+2+i,upc[i]);
+            mem_writeb(buffer+9,0x00);
+            break;
+        };
+		case 0x0F :{ /* Get Audio Status */
+            bool playing,pause;
+            TMSF resStart,resEnd;
+            mscdex->GetAudioStatus(drive_unit,playing,pause,resStart,resEnd);
+            mem_writeb(buffer+1,pause);
+            mem_writeb(buffer+3,resStart.min);
+            mem_writeb(buffer+4,resStart.sec);
+            mem_writeb(buffer+5,resStart.fr);
+            mem_writeb(buffer+6,0x00);
+            mem_writeb(buffer+7,resEnd.min);
+            mem_writeb(buffer+8,resEnd.sec);
+            mem_writeb(buffer+9,resEnd.fr);
+            mem_writeb(buffer+10,0x00);
+            break;
+        };
 		default :	LOG(LOG_MISC,LOG_ERROR)("MSCDEX: Unsupported IOCTL INPUT Subfunction %02X",ioctl_fct);
-					return 0x03;	// invalid function
+            return 0x03;	// invalid function
 	}
 	return 0x00;	// success
 }
 
 static Bit16u MSCDEX_IOCTL_Optput(PhysPt buffer,Bit8u drive_unit) {
 	Bitu ioctl_fct = mem_readb(buffer);
-//	MSCDEX_LOG("MSCDEX: IOCTL OUTPUT Subfunction %02X",ioctl_fct);
+    //	MSCDEX_LOG("MSCDEX: IOCTL OUTPUT Subfunction %02X",ioctl_fct);
 	switch (ioctl_fct) {
 		case 0x00 :	// Unload /eject media
-					if (!mscdex->LoadUnloadMedia(drive_unit,true)) return 0x02;
-					break;
+            if (!mscdex->LoadUnloadMedia(drive_unit,true)) return 0x02;
+            break;
 		case 0x03: //Audio Channel control
-					MSCDEX_LOG("MSCDEX: Audio Channel Control used. Not handled. Faking succes!");
-		case 0x01 : // (un)Lock door 
-					// do nothing -> report as success
-					break;
+            TCtrl ctrl;
+            for (Bit8u chan=0;chan<4;chan++) {
+                ctrl.out[chan]=mem_readb(buffer+chan*2+1);
+                ctrl.vol[chan]=mem_readb(buffer+chan*2+2);
+            }
+            if (!mscdex->ChannelControl(drive_unit,ctrl)) return 0x01;
+            break;
+		case 0x01 : // (un)Lock door
+            // do nothing -> report as success
+            break;
 		case 0x02 : // Reset Drive
-					LOG(LOG_MISC,LOG_WARN)("cdromDrive reset");
-					if (!mscdex->StopAudio(drive_unit))  return 0x02;
-					break;
+            LOG(LOG_MISC,LOG_WARN)("cdromDrive reset");
+            if (!mscdex->StopAudio(drive_unit))  return 0x02;
+            break;
 		case 0x05 :	// load media
-					if (!mscdex->LoadUnloadMedia(drive_unit,false)) return 0x02;
+            if (!mscdex->LoadUnloadMedia(drive_unit,false)) return 0x02;
+            break;
 		default	:	LOG(LOG_MISC,LOG_ERROR)("MSCDEX: Unsupported IOCTL OUTPUT Subfunction %02X",ioctl_fct);
-					return 0x03;	// invalid function
+            return 0x03;	// invalid function
 	}
 	return 0x00;	// success
 }
 
 static Bitu MSCDEX_Strategy_Handler(void) {
 	curReqheaderPtr = PhysMake(SegValue(es),reg_bx);
-//	MSCDEX_LOG("MSCDEX: Device Strategy Routine called, request header at %x",curReqheaderPtr);
+    //	MSCDEX_LOG("MSCDEX: Device Strategy Routine called, request header at %x",curReqheaderPtr);
 	return CBRET_NONE;
 }
 
 static Bitu MSCDEX_Interrupt_Handler(void) {
 	if (curReqheaderPtr==0) {
-		MSCDEX_LOG("MSCDEX: invalid call to interrupt handler");						
+		MSCDEX_LOG("MSCDEX: invalid call to interrupt handler");
 		return CBRET_NONE;
 	}
 	Bit8u	subUnit		= mem_readb(curReqheaderPtr+1);
 	Bit8u	funcNr		= mem_readb(curReqheaderPtr+2);
 	Bit16u	errcode		= 0;
 	PhysPt	buffer		= 0;
-
+    
 	MSCDEX_LOG("MSCDEX: Driver Function %02X",funcNr);
-
+    
 	if ((funcNr==0x03) || (funcNr==0x0c) || (funcNr==0x80) || (funcNr==0x82)) {
 		buffer = PhysMake(mem_readw(curReqheaderPtr+0x10),mem_readw(curReqheaderPtr+0x0E));
 	}
-
+    
  	switch (funcNr) {
 		case 0x03	: {	/* IOCTL INPUT */
-						Bit16u error=MSCDEX_IOCTL_Input(buffer,subUnit);
-						if (error) errcode = error;
-						break;
-					  };
+            Bit16u error=MSCDEX_IOCTL_Input(buffer,subUnit);
+            if (error) errcode = error;
+            break;
+        };
 		case 0x0C	: {	/* IOCTL OUTPUT */
-						Bit16u error=MSCDEX_IOCTL_Optput(buffer,subUnit);
-						if (error) errcode = error;
-						break;
-					  };
+            Bit16u error=MSCDEX_IOCTL_Optput(buffer,subUnit);
+            if (error) errcode = error;
+            break;
+        };
 		case 0x0D	:	// device open
 		case 0x0E	:	// device close - dont care :)
-						break;
+            break;
 		case 0x80	:	// Read long
 		case 0x82	: { // Read long prefetch -> both the same here :)
-						Bit32u start = mem_readd(curReqheaderPtr+0x14);
-						Bit16u len	 = mem_readw(curReqheaderPtr+0x12);
-						bool raw	 = (mem_readb(curReqheaderPtr+0x18)==1);
-						if (mem_readb(curReqheaderPtr+0x0D)==0x00) // HSG
-							mscdex->ReadSectors(subUnit,raw,start,len,buffer);
-						else 
-							mscdex->ReadSectorsMSF(subUnit,raw,start,len,buffer);
-						break;
-					  };
+            Bit32u start = mem_readd(curReqheaderPtr+0x14);
+            Bit16u len	 = mem_readw(curReqheaderPtr+0x12);
+            bool raw	 = (mem_readb(curReqheaderPtr+0x18)==1);
+            if (mem_readb(curReqheaderPtr+0x0D)==0x00) // HSG
+                mscdex->ReadSectors(subUnit,raw,start,len,buffer);
+            else
+                mscdex->ReadSectorsMSF(subUnit,raw,start,len,buffer);
+            break;
+        };
 		case 0x83	:	// Seek - dont care :)
-						break;
+            break;
 		case 0x84	: {	/* Play Audio Sectors */
-						Bit32u start = mem_readd(curReqheaderPtr+0x0E);
-						Bit32u len	 = mem_readd(curReqheaderPtr+0x12);
-						if (mem_readb(curReqheaderPtr+0x0D)==0x00) // HSG
-							mscdex->PlayAudioSector(subUnit,start,len);
-						else // RED BOOK
-							mscdex->PlayAudioMSF(subUnit,start,len);
-						break;
-					  };
+            Bit32u start = mem_readd(curReqheaderPtr+0x0E);
+            Bit32u len	 = mem_readd(curReqheaderPtr+0x12);
+            if (mem_readb(curReqheaderPtr+0x0D)==0x00) // HSG
+                mscdex->PlayAudioSector(subUnit,start,len);
+            else // RED BOOK
+                mscdex->PlayAudioMSF(subUnit,start,len);
+            break;
+        };
 		case 0x85	:	/* Stop Audio */
-						mscdex->StopAudio(subUnit);
-						break;
+            mscdex->StopAudio(subUnit);
+            break;
 		case 0x88	:	/* Resume Audio */
-						mscdex->ResumeAudio(subUnit);
-						break;
+            mscdex->ResumeAudio(subUnit);
+            break;
 		default		:	LOG(LOG_MISC,LOG_ERROR)("MSCDEX: Unsupported Driver Request %02X",funcNr);
-						break;
-	
+            break;
+            
 	};
 	
 	// Set Statusword
 	mem_writew(curReqheaderPtr+3,mscdex->GetStatusWord(subUnit,errcode));
-	MSCDEX_LOG("MSCDEX: Status : %04X",mem_readw(curReqheaderPtr+3));						
+	MSCDEX_LOG("MSCDEX: Status : %04X",mem_readw(curReqheaderPtr+3));
 	return CBRET_NONE;
 }
 
 static bool MSCDEX_Handler(void) {
 	if(reg_ah == 0x11) {
-		if(reg_al == 0x00) { 
+		if(reg_al == 0x00) {
 			PhysPt check = PhysMake(SegValue(ss),reg_sp);
 			if(mem_readw(check+6) == 0xDADA) {
 				//MSCDEX sets word on stack to ADAD if it DADA on entry.
@@ -1088,120 +1158,120 @@ static bool MSCDEX_Handler(void) {
 			return true;
 		}
 	}
-
+    
 	if (reg_ah!=0x15) return false;		// not handled here, continue chain
-
+    
 	PhysPt data = PhysMake(SegValue(es),reg_bx);
 	MSCDEX_LOG("MSCDEX: INT 2F %04X BX= %04X CX=%04X",reg_ax,reg_bx,reg_cx);
 	switch (reg_ax) {
-	
+            
 		case 0x1500:	/* Install check */
-						reg_bx = mscdex->GetNumDrives();
-						if (reg_bx>0) reg_cx = mscdex->GetFirstDrive();
-						reg_al = 0xff;
-						return true;
+            reg_bx = mscdex->GetNumDrives();
+            if (reg_bx>0) reg_cx = mscdex->GetFirstDrive();
+            reg_al = 0xff;
+            return true;
 		case 0x1501:	/* Get cdrom driver info */
-						mscdex->GetDriverInfo(data);
-						return true;
+            mscdex->GetDriverInfo(data);
+            return true;
 		case 0x1502:	/* Get Copyright filename */
-						if (mscdex->GetCopyrightName(reg_cx,data)) {
-							CALLBACK_SCF(false);
-						} else {
-							reg_ax = MSCDEX_ERROR_UNKNOWN_DRIVE;
-							CALLBACK_SCF(true);							
-						};
-						return true;		
+            if (mscdex->GetCopyrightName(reg_cx,data)) {
+                CALLBACK_SCF(false);
+            } else {
+                reg_ax = MSCDEX_ERROR_UNKNOWN_DRIVE;
+                CALLBACK_SCF(true);
+            };
+            return true;
 		case 0x1503:	/* Get Abstract filename */
-						if (mscdex->GetAbstractName(reg_cx,data)) {
-							CALLBACK_SCF(false);
-						} else {
-							reg_ax = MSCDEX_ERROR_UNKNOWN_DRIVE;
-							CALLBACK_SCF(true);							
-						};
-						return true;		
+            if (mscdex->GetAbstractName(reg_cx,data)) {
+                CALLBACK_SCF(false);
+            } else {
+                reg_ax = MSCDEX_ERROR_UNKNOWN_DRIVE;
+                CALLBACK_SCF(true);
+            };
+            return true;
 		case 0x1504:	/* Get Documentation filename */
-						if (mscdex->GetDocumentationName(reg_cx,data)) {
-							CALLBACK_SCF(false);
-						} else {
-							reg_ax = MSCDEX_ERROR_UNKNOWN_DRIVE;
-							CALLBACK_SCF(true);							
-						};
-						return true;		
-		case 0x1505: {	// read vtoc 
-						Bit16u error = 0;
-						if (mscdex->ReadVTOC(reg_cx,reg_dx,data,error)) {
-//							reg_ax = error;	// return code
-							CALLBACK_SCF(false);
-						} else {
-							reg_ax = error;
-							CALLBACK_SCF(true);							
-						};
-					 };
-						return true;
-		case 0x1508: {	// read sectors 
-						Bit32u sector = (reg_si<<16)+reg_di;
-						if (mscdex->ReadSectors(reg_cx,sector,reg_dx,data)) {
-							reg_ax = 0;
-							CALLBACK_SCF(false);
-						} else {
-							// possibly: MSCDEX_ERROR_DRIVE_NOT_READY if sector is beyond total length
-							reg_ax = MSCDEX_ERROR_UNKNOWN_DRIVE;
-							CALLBACK_SCF(true);
-						};
-						return true;
-					 };
-		case 0x1509:	// write sectors - not supported 
-						reg_ax = MSCDEX_ERROR_INVALID_FUNCTION;
-						CALLBACK_SCF(true);
-						return true;
+            if (mscdex->GetDocumentationName(reg_cx,data)) {
+                CALLBACK_SCF(false);
+            } else {
+                reg_ax = MSCDEX_ERROR_UNKNOWN_DRIVE;
+                CALLBACK_SCF(true);
+            };
+            return true;
+		case 0x1505: {	// read vtoc
+            Bit16u error = 0;
+            if (mscdex->ReadVTOC(reg_cx,reg_dx,data,error)) {
+                //							reg_ax = error;	// return code
+                CALLBACK_SCF(false);
+            } else {
+                reg_ax = error;
+                CALLBACK_SCF(true);
+            };
+        };
+            return true;
+		case 0x1508: {	// read sectors
+            Bit32u sector = (reg_si<<16)+reg_di;
+            if (mscdex->ReadSectors(reg_cx,sector,reg_dx,data)) {
+                reg_ax = 0;
+                CALLBACK_SCF(false);
+            } else {
+                // possibly: MSCDEX_ERROR_DRIVE_NOT_READY if sector is beyond total length
+                reg_ax = MSCDEX_ERROR_UNKNOWN_DRIVE;
+                CALLBACK_SCF(true);
+            };
+            return true;
+        };
+		case 0x1509:	// write sectors - not supported
+            reg_ax = MSCDEX_ERROR_INVALID_FUNCTION;
+            CALLBACK_SCF(true);
+            return true;
 		case 0x150B:	/* Valid CDROM drive ? */
-						reg_ax = (mscdex->IsValidDrive(reg_cx) ? 0x5ad8 : 0x0000);
-						reg_bx = 0xADAD;
-						return true;
+            reg_ax = (mscdex->IsValidDrive(reg_cx) ? 0x5ad8 : 0x0000);
+            reg_bx = 0xADAD;
+            return true;
 		case 0x150C:	/* Get MSCDEX Version */
-						reg_bx = mscdex->GetVersion();
-						return true;
+            reg_bx = mscdex->GetVersion();
+            return true;
 		case 0x150D:	/* Get drives */
-						mscdex->GetDrives(data);
-						return true;
+            mscdex->GetDrives(data);
+            return true;
 		case 0x150E:	/* Get/Set Volume Descriptor Preference */
-						if (mscdex->IsValidDrive(reg_cx)) {
-							if (reg_bx == 0) {
-								// get preference
-								reg_dx = 0x100;	// preference?
-								CALLBACK_SCF(false);
-							} else if (reg_bx == 1) {
-								// set preference
-								if (reg_dh == 1) {
-									// valid
-									CALLBACK_SCF(false);
-								} else {
-									reg_ax = MSCDEX_ERROR_INVALID_FUNCTION;
-									CALLBACK_SCF(true);
-								}
-							} else {
-								reg_ax = MSCDEX_ERROR_INVALID_FUNCTION;
-								CALLBACK_SCF(true);
-							}
-						} else {
-							reg_ax = MSCDEX_ERROR_UNKNOWN_DRIVE;
-							CALLBACK_SCF(true);
-						}
-						return true;
+            if (mscdex->IsValidDrive(reg_cx)) {
+                if (reg_bx == 0) {
+                    // get preference
+                    reg_dx = 0x100;	// preference?
+                    CALLBACK_SCF(false);
+                } else if (reg_bx == 1) {
+                    // set preference
+                    if (reg_dh == 1) {
+                        // valid
+                        CALLBACK_SCF(false);
+                    } else {
+                        reg_ax = MSCDEX_ERROR_INVALID_FUNCTION;
+                        CALLBACK_SCF(true);
+                    }
+                } else {
+                    reg_ax = MSCDEX_ERROR_INVALID_FUNCTION;
+                    CALLBACK_SCF(true);
+                }
+            } else {
+                reg_ax = MSCDEX_ERROR_UNKNOWN_DRIVE;
+                CALLBACK_SCF(true);
+            }
+            return true;
 		case 0x150F: {	// Get directory entry
-						Bit16u error;
-						bool success = mscdex->GetDirectoryEntry(reg_cl,reg_ch&1,data,PhysMake(reg_si,reg_di),error);
-						reg_ax = error;
-						CALLBACK_SCF(!success);
-					 };	return true;
+            Bit16u error;
+            bool success = mscdex->GetDirectoryEntry(reg_cl,reg_ch&1,data,PhysMake(reg_si,reg_di),error);
+            reg_ax = error;
+            CALLBACK_SCF(!success);
+        };	return true;
 		case 0x1510:	/* Device driver request */
-						if (mscdex->SendDriverRequest(reg_cx,data)) {
-							CALLBACK_SCF(false);
-						} else {
-							reg_ax = MSCDEX_ERROR_UNKNOWN_DRIVE;
-							CALLBACK_SCF(true);
-						}
-						return true;
+            if (mscdex->SendDriverRequest(reg_cx,data)) {
+                CALLBACK_SCF(false);
+            } else {
+                reg_ax = MSCDEX_ERROR_UNKNOWN_DRIVE;
+                CALLBACK_SCF(true);
+            }
+            return true;
 	};
 	LOG(LOG_MISC,LOG_ERROR)("MSCDEX: Unknwon call : %04X",reg_ax);
 	return true;
@@ -1211,7 +1281,7 @@ class device_MSCDEX : public DOS_Device {
 public:
 	device_MSCDEX() { SetName("MSCD001"); }
 	bool Read (Bit8u * /*data*/,Bit16u * /*size*/) { return false;}
-	bool Write(Bit8u * /*data*/,Bit16u * /*size*/) { 
+	bool Write(Bit8u * /*data*/,Bit16u * /*size*/) {
 		LOG(LOG_ALL,LOG_NORMAL)("Write to mscdex device");	
 		return false;
 	}
@@ -1221,7 +1291,7 @@ public:
 	bool ReadFromControlChannel(PhysPt bufptr,Bit16u size,Bit16u * retcode);
 	bool WriteToControlChannel(PhysPt bufptr,Bit16u size,Bit16u * retcode);
 private:
-//	Bit8u cache;
+    //	Bit8u cache;
 };
 
 bool device_MSCDEX::ReadFromControlChannel(PhysPt bufptr,Bit16u size,Bit16u * retcode) { 
@@ -1270,7 +1340,7 @@ bool MSCDEX_GetVolumeName(Bit8u subUnit, char* name)
 bool MSCDEX_HasMediaChanged(Bit8u subUnit)
 {
 	static TMSF leadOut[MSCDEX_MAX_DRIVES];
-
+    
 	TMSF leadnew;
 	Bit8u tr1,tr2;
 	if (mscdex->GetCDInfo(subUnit,tr1,tr2,leadnew)) {
@@ -1313,4 +1383,4 @@ void MSCDEX_Init(Section* sec) {
 	DOS_AddMultiplexHandler(MSCDEX_Handler);
 	/* Create MSCDEX */
 	mscdex = new CMscdex;
-}
+}
\ No newline at end of file
diff --git a/src/dos/dos_programs.cpp b/src/dos/dos_programs.cpp
index a98683d9..b659e7d9 100644
--- a/src/dos/dos_programs.cpp
+++ b/src/dos/dos_programs.cpp
@@ -37,7 +37,6 @@
 #include "setup.h"
 #include "control.h"
 
-
 #if defined(OS2)
 #define INCL DOSFILEMGR
 #define INCL_DOSERRORS
@@ -91,6 +90,10 @@ public:
 						if(i_drive == DOS_GetDefaultDrive()) 
 							DOS_SetDrive(toupper('Z') - 'A');
 						WriteOut(MSG_Get("PROGRAM_MOUNT_UMOUNT_SUCCESS"),umount[0]);
+							
+						//--Added 2010-01-18 by Alun Bestor: let Boxer know that the drive state has changed
+						boxer_driveDidUnmount(i_drive);
+						//--End of modifications
 						break;
 					case 1:
 						WriteOut(MSG_Get("PROGRAM_MOUNT_UMOUNT_NO_VIRTUAL"));
@@ -226,14 +229,14 @@ public:
 				DosClose(cdrom_fd);
 				if (rc != NO_ERROR && rc != ERROR_NOT_READY) {
 #if C_HAVE_PHYSFS
-					// Make it a physfs then...
-					is_physfs = true;
-					temp_line.insert(0, 1, ':');
+				// Make it a physfs then...
+				is_physfs = true;
+				temp_line.insert(0, 1, ':');
 #else
-					WriteOut(MSG_Get("PROGRAM_MOUNT_ERROR_2"),temp_line.c_str());
-					return;
+				WriteOut(MSG_Get("PROGRAM_MOUNT_ERROR_2"),temp_line.c_str());
+				return;
 #endif
-				}
+			}
 #else
 #if C_HAVE_PHYSFS
 				// Make it a physfs then...
@@ -311,7 +314,12 @@ public:
 				    (temp_line == "c:/") || (temp_line == "C:/")    )	
 					WriteOut(MSG_Get("PROGRAM_MOUNT_WARNING_WIN"));
 #else
-				if(temp_line == "/") WriteOut(MSG_Get("PROGRAM_MOUNT_WARNING_OTHER"));
+				//--Modified 2009-02-20 by Alun Bestor: we now prohibit this altogether and produce our own contextual warning.
+				//if(temp_line == "/") WriteOut(MSG_Get("PROGRAM_MOUNT_WARNING_OTHER"));
+				
+				if(!boxer_shouldMountPath(temp_line.c_str())) return;
+				
+				//--End of modifications
 #endif
 				if (is_physfs) {
 #if C_HAVE_PHYSFS
@@ -320,7 +328,7 @@ public:
 					LOG_MSG("ERROR:This build does not support physfs");
 #endif
 				} else {
-					newdrive = new localDrive(temp_line.c_str(),sizes[0],bit8size,sizes[2],sizes[3],mediaid);
+					newdrive=new localDrive(temp_line.c_str(),sizes[0],bit8size,sizes[2],sizes[3],mediaid);
 				}
 			}
 		} else {
@@ -338,17 +346,22 @@ public:
 		mem_writeb(Real2Phys(dos.tables.mediaid)+(drive-'A')*2,newdrive->GetMediaByte());
 		WriteOut(MSG_Get("PROGRAM_MOUNT_STATUS_2"),drive,newdrive->GetInfo());
 		/* check if volume label is given and don't allow it to updated in the future */
-		if (cmd->FindString("-label",label,true)) newdrive->dirCache.SetLabel(label.c_str(),iscdrom,false);
+		if (cmd->FindString("-label",label,true)) newdrive->SetLabel(label.c_str(),iscdrom,false);
 		/* For hard drives set the label to DRIVELETTER_Drive.
 		 * For floppy drives set the label to DRIVELETTER_Floppy.
 		 * This way every drive except cdroms should get a label.*/
 		else if(type == "dir") { 
 			label = drive; label += "_DRIVE";
-			newdrive->dirCache.SetLabel(label.c_str(),iscdrom,false);
+			newdrive->SetLabel(label.c_str(),iscdrom,true);
 		} else if(type == "floppy") {
 			label = drive; label += "_FLOPPY";
-			newdrive->dirCache.SetLabel(label.c_str(),iscdrom,true);
+			newdrive->SetLabel(label.c_str(),iscdrom,true);
 		}
+		
+		//--Added 2010-01-18 by Alun Bestor: let Boxer know that the drive state has changed
+		boxer_driveDidMount(drive-'A');
+		//--End of modifications
+		
 		return;
 showusage:
 #if defined (WIN32) || defined(OS2)
@@ -1025,6 +1038,11 @@ public:
 						if (i_drive == DOS_GetDefaultDrive()) 
 							DOS_SetDrive(toupper('Z') - 'A');
 						WriteOut(MSG_Get("PROGRAM_MOUNT_UMOUNT_SUCCESS"),umount[0]);
+						
+						//--Added 2010-01-18 by Alun Bestor: let Boxer know that the drive state has changed
+						boxer_driveDidUnmount(i_drive);
+						//--End of modifications
+							
 						break;
 					case 1:
 						WriteOut(MSG_Get("PROGRAM_MOUNT_UMOUNT_NO_VIRTUAL"));
@@ -1289,6 +1307,10 @@ public:
 			WriteOut(MSG_Get("PROGRAM_IMGMOUNT_MOUNT_NUMBER"),drive-'0',temp_line.c_str());
 		}
 
+		//--Added 2010-01-18 by Alun Bestor: let Boxer know that the drive state has changed
+		boxer_driveDidMount(drive-'A');
+		//--End of modifications
+		
 		// check if volume label is given. becareful for cdrom
 		//if (cmd->FindString("-label",label,true)) newdrive->dirCache.SetLabel(label.c_str());
 		return;
@@ -1574,7 +1596,9 @@ void DOS_SetupPrograms(void) {
 	PROGRAMS_MakeFile("MEM.COM",MEM_ProgramStart);
 	PROGRAMS_MakeFile("LOADFIX.COM",LOADFIX_ProgramStart);
 	PROGRAMS_MakeFile("RESCAN.COM",RESCAN_ProgramStart);
-	PROGRAMS_MakeFile("INTRO.COM",INTRO_ProgramStart);
+    //--Disabled 2012-01-06 by Alun Bestor: Boxer no longer uses the INTRO command.
+	//PROGRAMS_MakeFile("INTRO.COM",INTRO_ProgramStart);
+    //--End of modifications
 	PROGRAMS_MakeFile("BOOT.COM",BOOT_ProgramStart);
 #if C_DEBUG
 	PROGRAMS_MakeFile("LDGFXROM.COM", LDGFXROM_ProgramStart);
diff --git a/src/dos/drive_cache.cpp b/src/dos/drive_cache.cpp
index e67e7e46..41e2832f 100644
--- a/src/dos/drive_cache.cpp
+++ b/src/dos/drive_cache.cpp
@@ -23,6 +23,10 @@
 #include "support.h"
 #include "cross.h"
 
+//--Added 2009-12-26 by Alun Bestor to allow Boxer to hook into DOSBox internals
+#include "BXCoalface.h"
+//--End of modifications
+
 // STL stuff
 #include <vector>
 #include <iterator>
@@ -80,7 +84,7 @@ DOS_Drive_Cache::DOS_Drive_Cache(const char* path, DOS_Drive *drv) {
 	nextFreeFindFirst	= 0;
 	for (Bit32u i=0; i<MAX_OPENDIRS; i++) { dirSearch[i] = 0; free[i] = true; dirFindFirst[i] = 0; };
 	SetDirSort(DIRALPHABETICAL);
-	SetBaseDir(path, drv);
+	SetBaseDir(path,drv);
 	updatelabel = true;
 }
 
@@ -102,7 +106,7 @@ void DOS_Drive_Cache::EmptyCache(void) {
 	save_dir	= 0;
 	srchNr		= 0;
 	for (Bit32u i=0; i<MAX_OPENDIRS; i++) free[i] = true; 
-	SetBaseDir(basePath, drive);
+	SetBaseDir(basePath,drive);
 }
 
 void DOS_Drive_Cache::SetLabel(const char* vname,bool cdrom,bool allowupdate) {
@@ -125,7 +129,7 @@ Bit16u DOS_Drive_Cache::GetFreeID(CFileInfo* dir) {
 void DOS_Drive_Cache::SetBaseDir(const char* baseDir, DOS_Drive *drv) {
 	Bit16u id;
 	strcpy(basePath,baseDir);
-	drive = drv;
+	this->drive = drv;
 	if (OpenDir(baseDir,id)) {
 		char* result = 0;
 		ReadDir(id,result);
@@ -134,18 +138,18 @@ void DOS_Drive_Cache::SetBaseDir(const char* baseDir, DOS_Drive *drv) {
 #if defined (WIN32) || defined (OS2)
 	bool cdrom = false;
 	char labellocal[256]={ 0 };
-	char drivePath[4] = "C:\\";
-	drivePath[0] = basePath[0];
+	char drives[4] = "C:\\";
+	drives[0] = basePath[0];
 #if defined (WIN32)
-	if (GetVolumeInformation(drivePath,labellocal,256,NULL,NULL,NULL,NULL,0)) {
-	UINT test = GetDriveType(drivePath);
+	if (GetVolumeInformation(drives,labellocal,256,NULL,NULL,NULL,NULL,0)) {
+	UINT test = GetDriveType(drives);
 	if(test == DRIVE_CDROM) cdrom = true;
 #else // OS2
 	//TODO determine wether cdrom or not!
 	FSINFO fsinfo;
-	ULONG drivenumber = drivePath[0];
+	ULONG drivenumber = drive[0];
 	if (drivenumber > 26) { // drive letter was lowercase
-		drivenumber = drivePath[0] - 'a' + 1;
+		drivenumber = drive[0] - 'a' + 1;
 	}
 	APIRET rc = DosQueryFSInfo(drivenumber, FSIL_VOLSER, &fsinfo, sizeof(FSINFO));
 	if (rc == NO_ERROR) {
@@ -275,22 +279,42 @@ bool DOS_Drive_Cache::IsCachedIn(CFileInfo* curDir) {
 	return (curDir->fileList.size()>0);
 }
 
+//--Modified 2009-10-06 by Alun Bestor: this function is unused by DOSBox but provides a useful way for Boxer to look up short filenames.
+//However, in its original state it didn't work properly: it was comparing a filename to a full OS path, instead of a filename to a filename. This has now been modified to produce the intended result.
+bool DOS_Drive_Cache::GetShortName(const char* dirpath, const char*filename, char* shortname) {
 
-bool DOS_Drive_Cache::GetShortName(const char* fullname, char* shortname) {
 	// Get Dir Info
 	char expand[CROSS_LEN] = {0};
-	CFileInfo* curDir = FindDirInfo(fullname,expand);
+	CFileInfo* theDir = FindDirInfo(dirpath,expand);
+	//printf("\nScanning folder: %s (expanded to: %s)\n\n", dirpath, expand);
 
-	std::vector<CFileInfo*>::size_type filelist_size = curDir->longNameList.size();
+	std::vector<CFileInfo*>::size_type filelist_size = theDir->longNameList.size();
 	if (GCC_UNLIKELY(filelist_size<=0)) return false;
 
+	Bits i, numfiles = (Bits)(filelist_size);
+
+	for (i=0; i < numfiles; i++) {
+		//printf("Testing filename: %s\n", theDir->longNameList[i]->orgname);
+		
+		if (!strcmp(filename,theDir->longNameList[i]->orgname))
+		{
+			
+			//printf("Found match: %s\n", theDir->longNameList[i]->shortname);
+			strcpy(shortname,theDir->longNameList[i]->shortname);
+			return true;
+		};
+	}
+	
+	/*
+	//This binary-search code would have been much more efficient than the above,
+	//but it was broken enough to skip element and I haven't debugged it yet
+	//to figure out which detail is wrong.
 	Bits low		= 0;
 	Bits high		= (Bits)(filelist_size-1);
 	Bits mid, res;
-
 	while (low<=high) {
 		mid = (low+high)/2;
-		res = strcmp(fullname,curDir->longNameList[mid]->orgname);
+		res = strcmp(filename,curDir->longNameList[mid]->orgname);
 		if (res>0)	low  = mid+1; else
 		if (res<0)	high = mid-1; 
 		else {
@@ -298,8 +322,10 @@ bool DOS_Drive_Cache::GetShortName(const char* fullname, char* shortname) {
 			return true;
 		};
 	}
+	*/
 	return false;
 }
+//--End of modifications
 
 int DOS_Drive_Cache::CompareShortname(const char* compareName, const char* shortName) {
 	char const* cpos = strchr(shortName,'~');
@@ -539,6 +565,7 @@ DOS_Drive_Cache::CFileInfo* DOS_Drive_Cache::FindDirInfo(const char* path, char*
 		Bits nextDir = GetLongName(curDir,dir);
 		strcat(expandedPath,dir);
 
+		
 		// Error check
 /*		if ((errorcheck) && (nextDir<0)) {
 			LOG_DEBUG("DIR: Error: %s not found.",expandedPath);
@@ -569,7 +596,6 @@ DOS_Drive_Cache::CFileInfo* DOS_Drive_Cache::FindDirInfo(const char* path, char*
 	strcpy(save_path,path);
 	strcpy(save_expanded,expandedPath);
 	save_dir = curDir;
-
 	return curDir;
 }
 
@@ -584,6 +610,7 @@ bool DOS_Drive_Cache::OpenDir(const char* path, Bit16u& id) {
 }
 
 bool DOS_Drive_Cache::OpenDir(CFileInfo* dir, const char* expand, Bit16u& id) {
+	if (!drive) return false; //FIXME!! this should never happen
 	id = GetFreeID(dir);
 	dirSearch[id] = dir;
 	char expandcopy [CROSS_LEN];
@@ -597,7 +624,7 @@ bool DOS_Drive_Cache::OpenDir(CFileInfo* dir, const char* expand, Bit16u& id) {
 		void* dirp = drive->opendir(expandcopy);
 		if (dirp) { 
 			// Reset it..
-			if (dirp) drive->closedir(dirp);
+			drive->closedir(dirp);
 			strcpy(dirPath,expandcopy);
 			free[id] = false;
 			return true;
@@ -607,6 +634,10 @@ bool DOS_Drive_Cache::OpenDir(CFileInfo* dir, const char* expand, Bit16u& id) {
 }
 
 void DOS_Drive_Cache::CreateEntry(CFileInfo* dir, const char* name, bool is_directory) {
+	//--Added 2009-12-26 by Alun Bestor to allow Boxer to hide OSX metadata files
+	if (!boxer_shouldShowFileWithName(name)) return;
+	//--End of modifications
+	
 	CFileInfo* info = new CFileInfo;
 	strcpy(info->orgname, name);				
 	info->shortNr = 0;
diff --git a/src/dos/drive_fat.cpp b/src/dos/drive_fat.cpp
index a1d6a10c..480ee0ea 100644
--- a/src/dos/drive_fat.cpp
+++ b/src/dos/drive_fat.cpp
@@ -29,6 +29,11 @@
 #include "cross.h"
 #include "bios.h"
 
+//--Added 2011-04-18 by Alun Bestor to fix FAT image endianness bugs
+#import "BXCoalfaceDrives.h"
+//--endif
+
+
 #define IMGTYPE_FLOPPY 0
 #define IMGTYPE_ISO    1
 #define IMGTYPE_HDD	   2
@@ -628,6 +633,10 @@ bool fatDrive::allocateCluster(Bit32u useCluster, Bit32u prevCluster) {
 }
 
 fatDrive::fatDrive(const char *sysFilename, Bit32u bytesector, Bit32u cylsector, Bit32u headscyl, Bit32u cylinders, Bit32u startSector) {
+	//--Added 2009-10-25 by Alun Bestor to allow Boxer to track the system path for DOSBox drives
+	strcpy(systempath, sysFilename);
+	//--End of modifications
+	
 	created_successfully = true;
 	FILE *diskfile;
 	Bit32u filesize;
@@ -657,7 +666,19 @@ fatDrive::fatDrive(const char *sysFilename, Bit32u bytesector, Bit32u cylsector,
 
 		loadedDisk->Read_Sector(0,0,1,&mbrData);
 
-		if(mbrData.magic1!= 0x55 ||	mbrData.magic2!= 0xaa) LOG_MSG("Possibly invalid partition table in disk image.");
+        //--Added 2011-07-23 by Alun Bestor to correct byte order for PowerPC endianness
+        mbrData = boxer_FATPartitionTableLittleToHost(mbrData);
+        //--End of modifications
+        
+		if(mbrData.magic1!= 0x55 ||	mbrData.magic2!= 0xaa)
+        {
+            LOG_MSG("Possibly invalid partition table in disk image.");
+            
+            //--Added 2011-07-22 by Alun Bestor to bail out of reading invalid images
+            created_successfully = false;
+            return;
+            //--End of modifications
+        }
 
 		startSector = 63;
 		int m;
@@ -679,9 +700,19 @@ fatDrive::fatDrive(const char *sysFilename, Bit32u bytesector, Bit32u cylsector,
 	}
 
 	loadedDisk->Read_AbsoluteSector(0+partSectOff,&bootbuffer);
+    
+    //--Added 2011-07-22 by Alun Bestor to correct byte order for PowerPC endianness
+    bootbuffer = boxer_FATBootstrapLittleToHost(bootbuffer);
+    //--End of modifications
+    
 	if ((bootbuffer.magic1 != 0x55) || (bootbuffer.magic2 != 0xaa)) {
 		/* Not a FAT filesystem */
 		LOG_MSG("Loaded image has no valid magicnumbers at the end!");
+        
+        //--Added 2011-07-22 by Alun Bestor to bail out of reading invalid images
+		created_successfully = false;
+		return;
+        //--End of modifications
 	}
 
 	if(!bootbuffer.sectorsperfat) {
@@ -927,6 +958,10 @@ nextfile:
 	dirPos++;
 	dta.SetDirID(dirPos);
 
+    //--Added 2011-07-23 by Alun Bestor to correct byte order for PowerPC endianness.
+    sectbuf[entryoffset] = boxer_FATDirEntryLittleToHost(sectbuf[entryoffset]);
+    //--End of modifications
+    
 	/* Deleted file entry */
 	if (sectbuf[entryoffset].entryname[0] == 0xe5) goto nextfile;
 
@@ -1018,7 +1053,10 @@ bool fatDrive::directoryBrowse(Bit32u dirClustNumber, direntry *useEntry, Bit32s
 			loadedDisk->Read_AbsoluteSector(tmpsector,sectbuf);
 		}
 		dirPos++;
-
+        
+        //--Added 2011-07-23 by Alun Bestor to correct byte order for PowerPC endianness.
+        sectbuf[entryoffset] = boxer_FATDirEntryLittleToHost(sectbuf[entryoffset]);
+        //--End of modifications
 
 		/* End of directory list */
 		if (sectbuf[entryoffset].entryname[0] == 0x00) return false;
@@ -1053,13 +1091,17 @@ bool fatDrive::directoryChange(Bit32u dirClustNumber, direntry *useEntry, Bit32s
 		}
 		dirPos++;
 
-
 		/* End of directory list */
 		if (sectbuf[entryoffset].entryname[0] == 0x00) return false;
 		--entNum;
 	}
 	if(tmpsector != 0) {
         memcpy(&sectbuf[entryoffset], useEntry, sizeof(direntry));
+        
+        //--Added 2011-07-23 by Alun Bestor to correct byte order for PowerPC endianness.
+        sectbuf[entryoffset] = boxer_FATDirEntryHostToLittle(sectbuf[entryoffset]);
+        //--End of modifications
+        
 		loadedDisk->Write_AbsoluteSector(tmpsector, sectbuf);
         return true;
 	} else {
@@ -1100,7 +1142,13 @@ bool fatDrive::addDirectoryEntry(Bit32u dirClustNumber, direntry useEntry) {
 
 		/* Deleted file entry or end of directory list */
 		if ((sectbuf[entryoffset].entryname[0] == 0xe5) || (sectbuf[entryoffset].entryname[0] == 0x00)) {
+            
 			sectbuf[entryoffset] = useEntry;
+            
+            //--Added 2011-07-23 by Alun Bestor to correct byte order coming from PowerPC endianness.
+            sectbuf[entryoffset] = boxer_FATDirEntryHostToLittle(sectbuf[entryoffset]);
+            //--End of modifications
+            
 			loadedDisk->Write_AbsoluteSector(tmpsector,sectbuf);
 			break;
 		}
diff --git a/src/dos/drive_iso.cpp b/src/dos/drive_iso.cpp
index cfe21006..385397d9 100644
--- a/src/dos/drive_iso.cpp
+++ b/src/dos/drive_iso.cpp
@@ -46,8 +46,8 @@ private:
 	Bit16u info;
 };
 
-isoFile::isoFile(isoDrive *drive, const char *name, FileStat_Block *stat, Bit32u offset) {
-	this->drive = drive;
+isoFile::isoFile(isoDrive *drv, const char *filename, FileStat_Block *stat, Bit32u offset) {
+	this->drive = drv;
 	time = stat->time;
 	date = stat->date;
 	attr = stat->attr;
@@ -57,7 +57,7 @@ isoFile::isoFile(isoDrive *drive, const char *name, FileStat_Block *stat, Bit32u
 	cachedSector = -1;
 	open = true;
 	this->name = NULL;
-	SetName(name);
+	SetName(filename);
 }
 
 bool isoFile::Read(Bit8u *data, Bit16u *size) {
@@ -137,54 +137,58 @@ void MSCDEX_ReplaceDrive(CDROM_Interface* cdrom, Bit8u subUnit);
 bool MSCDEX_HasDrive(char driveLetter);
 bool MSCDEX_GetVolumeName(Bit8u subUnit, char* name);
 
-isoDrive::isoDrive(char driveLetter, const char *fileName, Bit8u mediaid, int &error) {
+isoDrive::isoDrive(char letter, const char *name, Bit8u _mediaid, int &error) {
 	nextFreeDirIterator = 0;
 	memset(dirIterators, 0, sizeof(dirIterators));
 	memset(sectorHashEntries, 0, sizeof(sectorHashEntries));
 	memset(&rootEntry, 0, sizeof(isoDirEntry));
 	
-	safe_strncpy(this->fileName, fileName, CROSS_LEN);
-	error = UpdateMscdex(driveLetter, fileName, subUnit);
+	safe_strncpy(this->fileName, name, CROSS_LEN);
+	error = UpdateMscdex(letter, name, subUnit);
 
 	if (!error) {
 		if (loadImage()) {
 			strcpy(info, "isoDrive ");
-			strcat(info, fileName);
-			this->driveLetter = driveLetter;
-			this->mediaid = mediaid;
+			strcat(info, name);
+			this->driveLetter = letter;
+			this->mediaid = _mediaid;
 			char buffer[32] = { 0 };
 			if (!MSCDEX_GetVolumeName(subUnit, buffer)) strcpy(buffer, "");
 			Set_Label(buffer,discLabel,true);
 
 		} else if (CDROM_Interface_Image::images[subUnit]->HasDataTrack() == false) { //Audio only cdrom
 			strcpy(info, "isoDrive ");
-			strcat(info, fileName);
-			this->driveLetter = driveLetter;
-			this->mediaid = mediaid;
+			strcat(info, name);
+			this->driveLetter = letter;
+			this->mediaid = _mediaid;
 			char buffer[32] = { 0 };
 			strcpy(buffer, "Audio_CD");
 			Set_Label(buffer,discLabel,true);
 		} else error = 6; //Corrupt image
 	}
+	
+	//--Added 2009-10-25 by Alun Bestor to allow Boxer to track the system path for DOSBox drives
+	strcpy(systempath, name);
+	//--End of modifications
 }
 
 isoDrive::~isoDrive() { }
 
-int isoDrive::UpdateMscdex(char driveLetter, const char* path, Bit8u& subUnit) {
-	if (MSCDEX_HasDrive(driveLetter)) {
-		CDROM_Interface_Image* oldCdrom = CDROM_Interface_Image::images[subUnit];
-		CDROM_Interface* cdrom = new CDROM_Interface_Image(subUnit);
+int isoDrive::UpdateMscdex(char letter, const char* path, Bit8u& _subUnit) {
+	if (MSCDEX_HasDrive(letter)) {
+		CDROM_Interface_Image* oldCdrom = CDROM_Interface_Image::images[_subUnit];
+		CDROM_Interface* cdrom = new CDROM_Interface_Image(_subUnit);
 		char pathCopy[CROSS_LEN];
 		safe_strncpy(pathCopy, path, CROSS_LEN);
 		if (!cdrom->SetDevice(pathCopy, 0)) {
-			CDROM_Interface_Image::images[subUnit] = oldCdrom;
+			CDROM_Interface_Image::images[_subUnit] = oldCdrom;
 			delete cdrom;
 			return 3;
 		}
-		MSCDEX_ReplaceDrive(cdrom, subUnit);
+		MSCDEX_ReplaceDrive(cdrom, _subUnit);
 		return 0;
 	} else {
-		return MSCDEX_AddDrive(driveLetter, path, subUnit);
+		return MSCDEX_AddDrive(letter, path, _subUnit);
 	}
 }
 
diff --git a/src/dos/drive_local.cpp b/src/dos/drive_local.cpp
index cf8426b4..9c14636f 100644
--- a/src/dos/drive_local.cpp
+++ b/src/dos/drive_local.cpp
@@ -41,6 +41,10 @@ public:
 	Bit16u GetInformation(void);
 	bool UpdateDateTimeFromHost(void);   
 	void FlagReadOnlyMedium(void);
+    //--Added 2011-11-03 by Alun Bestor to let Boxer inform open file handles
+    //that their physical backing media will be removed.
+    void willBecomeUnavailable(void);
+    //--End of modifications
 private:
 	FILE * fhandle;
 	bool read_only_medium;
@@ -58,14 +62,28 @@ bool localDrive::FileCreate(DOS_File * * file,const char * name,Bit16u /*attribu
 	/* Test if file exists (so we need to truncate it). don't add to dirCache then */
 	bool existing_file=false;
 	
-	FILE * test=fopen(temp_name,"rb+");
+	//--Added 2010-01-18 by Alun Bestor to allow Boxer to selectively deny write access to files
+	if (!boxer_shouldAllowWriteAccessToPath((const char *)newname, this))
+	{
+		DOS_SetError(DOSERR_ACCESS_DENIED);
+		return false;
+	}
+	//--End of modifications
+	
+    //-- Modified 2012-07-24 by Alun Bestor to allow Boxer to shadow local file access
+	//FILE * test=fopen(temp_name,"rb+");
+    FILE * test=boxer_openLocalFile(temp_name, this, "rb+");
+    //--End of modifications
 	if(test) {
 		fclose(test);
 		existing_file=true;
 
 	}
 	
-	FILE * hand=fopen(temp_name,"wb+");
+    //-- Modified 2012-07-24 by Alun Bestor to allow Boxer to shadow local file access
+	//FILE * hand=fopen(temp_name,"wb+");
+    FILE * hand=boxer_openLocalFile(temp_name, this, "wb+");
+    //--End of modifications
 	if (!hand){
 		LOG_MSG("Warning: file creation failed: %s",newname);
 		return false;
@@ -81,6 +99,11 @@ bool localDrive::FileCreate(DOS_File * * file,const char * name,Bit16u /*attribu
 	/* Make the 16 bit device information */
 	*file=new localFile(name,hand);
 	(*file)->flags=OPEN_READWRITE;
+	
+	
+	//--Added 2010-08-21 by Alun Bestor to let Boxer monitor DOSBox's file operations
+	boxer_didCreateLocalFile(temp_name, this);
+	//--End of modifications
 
 	return true;
 }
@@ -101,11 +124,36 @@ bool localDrive::FileOpen(DOS_File * * file,const char * name,Bit32u flags) {
 	CROSS_FILENAME(newname);
 	dirCache.ExpandName(newname);
 
-	FILE * hand=fopen(newname,type);
+	//--Added 2010-01-18 by Alun Bestor to allow Boxer to selectively deny write access to files
+	if (!strcmp(type, "rb+"))
+	{
+		if (!boxer_shouldAllowWriteAccessToPath((const char *)newname, this))
+		{
+			//Copy-pasted from cdromDrive::FileOpen
+			if ((flags&3)==OPEN_READWRITE) {
+				flags &= ~OPEN_READWRITE;
+			} else {
+				DOS_SetError(DOSERR_ACCESS_DENIED);
+				return false;
+			}			
+		}
+	}
+	//--End of modifications
+    
+    //-- Modified 2012-07-24 by Alun Bestor to allow Boxer to shadow local file access
+	//FILE * hand=fopen(newname,type);
+    FILE * hand=boxer_openLocalFile(newname, this, type);
+    //--End of modifications
+    
 //	Bit32u err=errno;
 	if (!hand) { 
 		if((flags&0xf) != OPEN_READ) {
-			FILE * hmm=fopen(newname,"rb");
+            
+            //-- Modified 2012-07-24 by Alun Bestor to allow Boxer to shadow local file access
+            //FILE * hmm=fopen(newname,"rb");
+            FILE * hmm=boxer_openLocalFile(newname, this, "rb");
+            //--End of modifications
+            
 			if (hmm) {
 				fclose(hmm);
 				LOG_MSG("Warning: file %s exists and failed to open in write mode.\nPlease Remove write-protection",newname);
@@ -127,8 +175,11 @@ FILE * localDrive::GetSystemFilePtr(char const * const name, char const * const
 	strcat(newname,name);
 	CROSS_FILENAME(newname);
 	dirCache.ExpandName(newname);
-
-	return fopen(newname,type);
+    
+    //-- Modified 2012-07-24 by Alun Bestor to allow Boxer to shadow local file access
+	//return fopen(newname,type);
+    return boxer_openLocalFile(newname, this, type);
+    //--End of modifications
 }
 
 bool localDrive::GetSystemFilename(char *sysName, char const * const dosName) {
@@ -146,12 +197,26 @@ bool localDrive::FileUnlink(const char * name) {
 	strcat(newname,name);
 	CROSS_FILENAME(newname);
 	char *fullname = dirCache.GetExpandName(newname);
-	if (unlink(fullname)) {
+	
+	//--Added 2010-12-29 by Alun Bestor to let Boxer selectively prevent file operations
+	if (!boxer_shouldAllowWriteAccessToPath((const char *)fullname, this))
+	{
+		DOS_SetError(DOSERR_ACCESS_DENIED);
+		return false;
+	}
+	//--End of modifications
+	
+    //-- Modified 2012-07-24 by Alun Bestor to allow Boxer to shadow local file access
+	//if (unlink(fullname)) {
+    if (!boxer_removeLocalFile(fullname, this)) {
 		//Unlink failed for some reason try finding it.
 		struct stat buffer;
-		if(stat(fullname,&buffer)) return false; // File not found.
-
-		FILE* file_writable = fopen(fullname,"rb+");
+        //if(stat(fullname,&buffer)) return false; // File not found.
+        if (!boxer_getLocalPathStats(fullname, this, &buffer)) return false;
+		
+		//FILE* file_writable = fopen(fullname,"rb+");
+        FILE* file_writable = boxer_openLocalFile(fullname, this, "rb+");
+        
 		if(!file_writable) return false; //No acces ? ERROR MESSAGE NOT SET. FIXME ?
 		fclose(file_writable);
 
@@ -170,13 +235,23 @@ bool localDrive::FileUnlink(const char * name) {
 			}
 		}
 		if(!found_file) return false;
-		if (!unlink(fullname)) {
+		//if (!unlink(fullname)) {
+        if (boxer_removeLocalFile(fullname, this)) {
 			dirCache.DeleteEntry(newname);
+			
+			//--Added 2010-08-21 by Alun Bestor to let Boxer monitor DOSBox's file operations
+			boxer_didRemoveLocalFile(fullname, this);
+			//--End of modifications
 			return true;
 		}
-		return false;
+		return false;        
+//--End of modifications
 	} else {
 		dirCache.DeleteEntry(newname);
+		
+		//--Added 2010-08-21 by Alun Bestor to let Boxer monitor DOSBox's file operations
+		boxer_didRemoveLocalFile(fullname, this);
+		//--End of modifications
 		return true;
 	}
 }
@@ -261,7 +336,10 @@ again:
 	//and due to its design dir_ent might be lost.)
 	//Copying dir_ent first
 	strcpy(dir_entcopy,dir_ent);
-	if (stat(dirCache.GetExpandName(full_name),&stat_block)!=0) { 
+    //Modified 2012-07-24 by Alun Bestor to wrap local file operations
+	//if (stat(dirCache.GetExpandName(full_name),&stat_block)!=0) { 
+    if (!boxer_getLocalPathStats(dirCache.GetExpandName(full_name), this, &stat_block)) {
+    //--End of modifications
 		goto again;//No symlinks and such
 	}	
 
@@ -298,7 +376,11 @@ bool localDrive::GetFileAttr(const char * name,Bit16u * attr) {
 	dirCache.ExpandName(newname);
 
 	struct stat status;
-	if (stat(newname,&status)==0) {
+    
+    //Modified 2012-07-24 by Alun Bestor to wrap local file operations
+	//if (stat(newname,&status)==0) { 
+    if (boxer_getLocalPathStats(newname, this, &status)) {
+    //--End of modifications
 		*attr=DOS_ATTR_ARCHIVE;
 		if(status.st_mode & S_IFDIR) *attr|=DOS_ATTR_DIRECTORY;
 		return true;
@@ -312,14 +394,33 @@ bool localDrive::MakeDir(const char * dir) {
 	strcpy(newdir,basedir);
 	strcat(newdir,dir);
 	CROSS_FILENAME(newdir);
-#if defined (WIN32)						/* MS Visual C++ */
-	int temp=mkdir(dirCache.GetExpandName(newdir));
-#else
-	int temp=mkdir(dirCache.GetExpandName(newdir),0700);
-#endif
-	if (temp==0) dirCache.CacheOut(newdir,true);
+	char * fullname=dirCache.GetExpandName(newdir);
+	
+	//--Modified 2010-12-29 by Alun Bestor to allow Boxer to selectively prevent file operations,
+	//and to prevent DOSBox from creating folders with the wrong file permissions.
+	/*
+	 #if defined (WIN32)						// MS Visual C++
+	 int temp=mkdir(fullname);
+	 #else
+	 int temp=mkdir(fullname,0700);
+	 #endif
+	 */
+	
+	if (!boxer_shouldAllowWriteAccessToPath((const char *)fullname, this))
+	{
+		DOS_SetError(DOSERR_ACCESS_DENIED);
+		return false;
+	}
 
-	return (temp==0);// || ((temp!=0) && (errno==EEXIST));
+	//int temp=mkdir(fullname, 0777);
+	//if (temp==0) dirCache.CacheOut(newdir,true);
+	//return (temp==0);// || ((temp!=0) && (errno==EEXIST));
+    
+    bool created = boxer_createLocalDir(fullname, this);
+    if (created) dirCache.CacheOut(newdir,true);
+    return created;
+	//--End of modifications
+	
 }
 
 bool localDrive::RemoveDir(const char * dir) {
@@ -327,9 +428,24 @@ bool localDrive::RemoveDir(const char * dir) {
 	strcpy(newdir,basedir);
 	strcat(newdir,dir);
 	CROSS_FILENAME(newdir);
-	int temp=rmdir(dirCache.GetExpandName(newdir));
-	if (temp==0) dirCache.DeleteEntry(newdir,true);
-	return (temp==0);
+	
+	//--Modified 2010-12-29 by Alun Bestor to allow Boxer to selectively prevent file operations
+	char *fullname = dirCache.GetExpandName(newdir);
+	
+	if (!boxer_shouldAllowWriteAccessToPath((const char *)fullname, this))
+	{
+		DOS_SetError(DOSERR_ACCESS_DENIED);
+		return false;
+	}
+	
+	//int temp=rmdir(fullname);
+	//if (temp==0) dirCache.DeleteEntry(newdir,true);
+    //return (temp==0);
+    
+    bool removed = boxer_removeLocalDir(fullname, this);
+	if (removed) dirCache.DeleteEntry(newdir,true);
+    return removed;
+    //--End of modifications
 }
 
 bool localDrive::TestDir(const char * dir) {
@@ -338,6 +454,9 @@ bool localDrive::TestDir(const char * dir) {
 	strcat(newdir,dir);
 	CROSS_FILENAME(newdir);
 	dirCache.ExpandName(newdir);
+    
+	//--Modified 2012-04-27 by Alun Bestor to wrap local file operations
+    /*
 	// Skip directory test, if "\"
 	size_t len = strlen(newdir);
 	if (len && (newdir[len-1]!='\\')) {
@@ -348,6 +467,9 @@ bool localDrive::TestDir(const char * dir) {
 	};
 	int temp=access(newdir,F_OK);
 	return (temp==0);
+     */
+    return boxer_localDirectoryExists(newdir, this);
+	//--End of modifications
 }
 
 bool localDrive::Rename(const char * oldname,const char * newname) {
@@ -361,9 +483,23 @@ bool localDrive::Rename(const char * oldname,const char * newname) {
 	strcpy(newnew,basedir);
 	strcat(newnew,newname);
 	CROSS_FILENAME(newnew);
-	int temp=rename(newold,dirCache.GetExpandName(newnew));
-	if (temp==0) dirCache.CacheOut(newnew);
-	return (temp==0);
+	char *fullname = dirCache.GetExpandName(newnew);
+	
+	//--Modified 2012-04-27 by Alun Bestor to wrap local file operations
+	if (!boxer_shouldAllowWriteAccessToPath((const char *)newold, this) ||
+		!boxer_shouldAllowWriteAccessToPath((const char *)fullname, this))
+	{
+		DOS_SetError(DOSERR_ACCESS_DENIED);
+		return false;
+	}
+	
+	//int temp=rename(newold,fullname);
+    //if (temp==0) dirCache.CacheOut(newnew);
+	//return (temp==0);
+    bool moved = boxer_moveLocalFile(newold, fullname, this);
+    if (moved) dirCache.CacheOut(newnew);
+    return moved;
+	//End of modifications
 
 }
 
@@ -383,10 +519,14 @@ bool localDrive::FileExists(const char* name) {
 	strcat(newname,name);
 	CROSS_FILENAME(newname);
 	dirCache.ExpandName(newname);
-	FILE* Temp=fopen(newname,"rb");
-	if(Temp==NULL) return false;
-	fclose(Temp);
-	return true;
+    
+	//--Modified 2012-04-27 by Alun Bestor to wrap local file operations
+	//FILE* Temp=fopen(newname,"rb");
+	//if(Temp==NULL) return false;
+	//fclose(Temp);
+	//return true;
+    return boxer_localFileExists(newname, this);
+    //--End of modifications
 }
 
 bool localDrive::FileStat(const char* name, FileStat_Block * const stat_block) {
@@ -396,7 +536,12 @@ bool localDrive::FileStat(const char* name, FileStat_Block * const stat_block) {
 	CROSS_FILENAME(newname);
 	dirCache.ExpandName(newname);
 	struct stat temp_stat;
-	if(stat(newname,&temp_stat)!=0) return false;
+    
+	//--Modified 2012-04-27 by Alun Bestor to wrap local file operations
+	//if(stat(newname,&temp_stat)!=0) return false;
+    if (!boxer_getLocalPathStats(newname, this, &temp_stat)) return false;
+    //--End of modifications
+    
 	/* Convert the stat to a FileStat */
 	struct tm *time;
 	if((time=localtime(&temp_stat.st_mtime))!=0) {
@@ -428,21 +573,27 @@ Bits localDrive::UnMount(void) {
 }
 
 /* helper functions for drive cache */
+//--Modified 2012-07-25 by Alun Bestor to wrap local filesystem access
 void *localDrive::opendir(const char *name) {
-	return open_directory(name);
+	//return open_directory(name);
+    return boxer_openLocalDirectory(name, this);
 }
 
 void localDrive::closedir(void *handle) {
-	close_directory((dir_information*)handle);
+	//close_directory((dir_information*)handle);
+    boxer_closeLocalDirectory(handle);
 }
 
 bool localDrive::read_directory_first(void *handle, char* entry_name, bool& is_directory) {
-	return ::read_directory_first((dir_information*)handle, entry_name, is_directory);
+	//return ::read_directory_first((dir_information*)handle, entry_name, is_directory);
+    return boxer_getNextDirectoryEntry(handle, entry_name, is_directory);
 }
 
 bool localDrive::read_directory_next(void *handle, char* entry_name, bool& is_directory) {
-	return ::read_directory_next((dir_information*)handle, entry_name, is_directory);
+	//return ::read_directory_next((dir_information*)handle, entry_name, is_directory);
+    return boxer_getNextDirectoryEntry(handle, entry_name, is_directory);
 }
+//--End of modifications
 
 localDrive::localDrive(const char * startdir,Bit16u _bytes_sector,Bit8u _sectors_cluster,Bit16u _total_clusters,Bit16u _free_clusters,Bit8u _mediaid) {
 	strcpy(basedir,startdir);
@@ -452,7 +603,11 @@ localDrive::localDrive(const char * startdir,Bit16u _bytes_sector,Bit8u _sectors
 	allocation.total_clusters=_total_clusters;
 	allocation.free_clusters=_free_clusters;
 	allocation.mediaid=_mediaid;
-
+	
+	//--Added 2009-10-25 by Alun Bestor to allow Boxer to track the system path for DOSBox drives
+	strcpy(systempath, startdir);
+	//--End of modifications
+	
 	dirCache.SetBaseDir(basedir,this);
 }
 
@@ -463,6 +618,19 @@ bool localFile::Read(Bit8u * data,Bit16u * size) {
 		DOS_SetError(DOSERR_ACCESS_DENIED);
 		return false;
 	}
+    
+    //--Added 2011-11-03 by Alun Bestor to avoid errors on files
+    //whose backing media has disappeared
+    if (!fhandle)
+    {
+        *size = 0;
+        //IMPLEMENTATION NOTE: you might think we ought to return false here,
+        //but no! We return true to be consistent with DOSBox's behaviour,
+        //which appears to be the behaviour expected by DOS.
+        return true;
+    }
+    //--End of modifications
+    
 	if (last_action==WRITE) fseek(fhandle,ftell(fhandle),SEEK_SET);
 	last_action=READ;
 	*size=(Bit16u)fread(data,1,*size,fhandle);
@@ -479,6 +647,19 @@ bool localFile::Write(Bit8u * data,Bit16u * size) {
 		DOS_SetError(DOSERR_ACCESS_DENIED);
 		return false;
 	}
+    
+    //--Added 2011-11-03 by Alun Bestor to avoid errors on files
+    //whose backing media has disappeared
+    if (!fhandle)
+    {
+        *size = 0;
+        //IMPLEMENTATION NOTE: you might think we ought to return false here,
+        //but no! We return true to be consistent with DOSBox's behaviour,
+        //which appears to be the behaviour expected by DOS.
+        return true;
+    }
+    //--End of modifications
+    
 	if (last_action==READ) fseek(fhandle,ftell(fhandle),SEEK_SET);
 	last_action=WRITE;
 	if(*size==0){  
@@ -493,6 +674,7 @@ bool localFile::Write(Bit8u * data,Bit16u * size) {
 
 bool localFile::Seek(Bit32u * pos,Bit32u type) {
 	int seektype;
+    
 	switch (type) {
 	case DOS_SEEK_SET:seektype=SEEK_SET;break;
 	case DOS_SEEK_CUR:seektype=SEEK_CUR;break;
@@ -501,6 +683,19 @@ bool localFile::Seek(Bit32u * pos,Bit32u type) {
 	//TODO Give some doserrorcode;
 		return false;//ERROR
 	}
+    
+    //--Added 2011-11-03 by Alun Bestor to avoid errors on files
+    //whose backing media has disappeared
+    if (!fhandle)
+    {
+        *pos = 0;
+        //IMPLEMENTATION NOTE: you might think we ought to return false here,
+        //but no! We return true to be consistent with DOSBox's behaviour,
+        //which appears to be the behaviour expected by DOS.
+        return true;
+    }
+    //--End of modifications
+    
 	int ret=fseek(fhandle,*reinterpret_cast<Bit32s*>(pos),seektype);
 	if (ret!=0) {
 		// Out of file range, pretend everythings ok 
@@ -552,6 +747,11 @@ void localFile::FlagReadOnlyMedium(void) {
 
 bool localFile::UpdateDateTimeFromHost(void) {
 	if(!open) return false;
+    
+    //--Added 2011-11-03 by Alun Bestor to avoid errors on closed files
+    if (!fhandle) return false;
+    //--End of modifications
+    
 	struct stat temp_stat;
 	fstat(fileno(fhandle),&temp_stat);
 	struct tm * ltime;
@@ -564,6 +764,21 @@ bool localFile::UpdateDateTimeFromHost(void) {
 	return true;
 }
 
+//--Added 2011-11-03 by Alun Bestor to let Boxer inform open file handles
+//that their physical backing media will be removed.
+void localFile::willBecomeUnavailable()
+{
+    //If the real file is about to become unavailable, then close
+    //our file handle but leave the DOS file flagged as 'open'.
+    if (fhandle)
+    {
+		fclose(fhandle);
+		fhandle = 0;
+    }
+}
+//--End of modification
+
+
 
 // ********************************************
 // CDROM DRIVE
@@ -575,13 +790,13 @@ bool MSCDEX_HasMediaChanged(Bit8u subUnit);
 bool MSCDEX_GetVolumeName(Bit8u subUnit, char* name);
 
 
-cdromDrive::cdromDrive(const char driveLetter, const char * startdir,Bit16u _bytes_sector,Bit8u _sectors_cluster,Bit16u _total_clusters,Bit16u _free_clusters,Bit8u _mediaid, int& error)
+cdromDrive::cdromDrive(const char letter, const char * startdir,Bit16u _bytes_sector,Bit8u _sectors_cluster,Bit16u _total_clusters,Bit16u _free_clusters,Bit8u _mediaid, int& error)
 		   :localDrive(startdir,_bytes_sector,_sectors_cluster,_total_clusters,_free_clusters,_mediaid) {
 	// Init mscdex
-	error = MSCDEX_AddDrive(driveLetter,startdir,subUnit);
+	error = MSCDEX_AddDrive(letter,startdir,subUnit);
 	strcpy(info, "CDRom ");
 	strcat(info, startdir);
-	this->driveLetter = driveLetter;
+	this->driveLetter = letter;
 	// Get Volume Label
 	char name[32];
 	if (MSCDEX_GetVolumeName(subUnit,name)) dirCache.SetLabel(name,true,true);
diff --git a/src/dos/drive_physfs.cpp b/src/dos/drive_physfs.cpp
index a082c0f0..11bacc18 100644
--- a/src/dos/drive_physfs.cpp
+++ b/src/dos/drive_physfs.cpp
@@ -25,7 +25,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
-#include <physfs.h>
+#include <PhysFS/physfs.h>
 #include "dos_inc.h"
 #include "drives.h"
 #include "support.h"
@@ -57,7 +57,7 @@ public:
 	bool prepareWrite();
 	bool Close();
 	Bit16u GetInformation(void);
-	bool UpdateDateTimeFromHost(void);
+	bool UpdateDateTimeFromHost(void);   
 private:
 	PHYSFS_file * fhandle;
 	enum { READ,WRITE } last_action;
@@ -94,10 +94,9 @@ bool physfsDrive::FileCreate(DOS_File * * file,const char * name,Bit16u attribut
 
 	/* Test if file exists, don't add to dirCache then */
 	bool existing_file=PHYSFS_exists(newname);
-
+	
 	char *slash = strrchr(newname,'/');
 	if (slash && slash != newname) {
-		char file[CROSS_LEN];
 		*slash = 0;
 		if (!PHYSFS_isDirectory(newname)) return false;
 		PHYSFS_mkdir(newname);
@@ -131,7 +130,7 @@ bool physfsDrive::FileOpen(DOS_File * * file,const char * name,Bit32u flags) {
 	normalize(newname,basedir);
 
 	PHYSFS_file * hand;
-
+	
 	if (!PHYSFS_exists(newname)) return false;
 	if ((flags&0xf) == OPEN_READ) {
 		hand = PHYSFS_openRead(newname);
@@ -141,7 +140,7 @@ bool physfsDrive::FileOpen(DOS_File * * file,const char * name,Bit32u flags) {
 		hand = PHYSFS_openRead(newname);
 	}
 
-	if (!hand) {
+	if (!hand) { 
 		if((flags&0xf) != OPEN_READ) {
 			PHYSFS_file *hmm = PHYSFS_openRead(newname);
 			if (hmm) {
@@ -151,7 +150,7 @@ bool physfsDrive::FileOpen(DOS_File * * file,const char * name,Bit32u flags) {
 		}
 		return false;
 	}
-
+   
 	*file=new physfsFile(name,hand,0x202,newname,false);
 	(*file)->flags=flags;  //for the inheritance flag and maybe check for others.
 	return true;
@@ -182,7 +181,7 @@ bool physfsDrive::FindFirst(const char * _dir,DOS_DTA & dta,bool fcb_findfirst)
 
 	char end[2]={CROSS_FILESPLIT,0};
 	if (tempDir[strlen(tempDir)-1]!=CROSS_FILESPLIT) strcat(tempDir,end);
-
+	
 	Bit16u id;
 	if (!dirCache.FindFirst(tempDir,id))
 	{
@@ -191,7 +190,7 @@ bool physfsDrive::FindFirst(const char * _dir,DOS_DTA & dta,bool fcb_findfirst)
 	}
 	strcpy(srchInfo[id].srch_dir,tempDir);
 	dta.SetDirID(id);
-
+	
 	Bit8u sAttr;
 	dta.GetSearchParams(sAttr,tempDir);
 
@@ -203,7 +202,7 @@ bool physfsDrive::FindFirst(const char * _dir,DOS_DTA & dta,bool fcb_findfirst)
 		}
 		dta.SetResult(dirCache.GetLabel(),0,0,0,DOS_ATTR_VOLUME);
 		return true;
-	} else if ((sAttr & DOS_ATTR_VOLUME)  && (*_dir == 0) && !fcb_findfirst) {
+	} else if ((sAttr & DOS_ATTR_VOLUME)  && (*_dir == 0) && !fcb_findfirst) { 
 	//should check for a valid leading directory instead of 0
 	//exists==true if the volume label matches the searchmask and the path is valid
 		if ( strcmp(dirCache.GetLabel(), "") == 0 ) {
@@ -228,7 +227,7 @@ bool physfsDrive::FindNext(DOS_DTA & dta) {
 	Bit8u find_attr;
 
 	dta.GetSearchParams(srch_attr,srch_pattern);
-
+	
 	Bitu id = dta.GetDirID();
 
 again:
@@ -242,26 +241,26 @@ again:
 	if(strlen(dir_ent)<DOS_NAMELENGTH_ASCII){
 		strcpy(find_name,dir_ent);
 		upcase(find_name);
-	}
+	} 
 
 	strcpy(full_name,srchInfo[id].srch_dir);
 	strcat(full_name,dir_ent);
 	dirCache.ExpandName(full_name);
 	normalize(full_name,basedir);
-
+	
 	if (PHYSFS_isDirectory(full_name)) find_attr=DOS_ATTR_DIRECTORY|DOS_ATTR_ARCHIVE;
 	else find_attr=DOS_ATTR_ARCHIVE;
-	if (~srch_attr & find_attr & (DOS_ATTR_DIRECTORY | DOS_ATTR_HIDDEN | DOS_ATTR_SYSTEM)) goto again;
-
+ 	if (~srch_attr & find_attr & (DOS_ATTR_DIRECTORY | DOS_ATTR_HIDDEN | DOS_ATTR_SYSTEM)) goto again;
+	
 	/*file is okay, setup everything to be copied in DTA Block */
 	find_size=(Bit32u)PHYSFS_fileLength(full_name);
-	time_t mytime = PHYSFS_getLastModTime(full_name);
+	time_t mytime = (time_t)PHYSFS_getLastModTime(full_name);
 	struct tm *time;
 	if((time=localtime(&mytime))!=0){
 		find_date=DOS_PackDate((Bit16u)(time->tm_year+1900),(Bit16u)(time->tm_mon+1),(Bit16u)time->tm_mday);
 		find_time=DOS_PackTime((Bit16u)time->tm_hour,(Bit16u)time->tm_min,(Bit16u)time->tm_sec);
 	} else {
-		find_time=6;
+		find_time=6; 
 		find_date=4;
 	}
 	dta.SetResult(find_name,find_size,find_date,find_time,find_attr);
@@ -332,7 +331,7 @@ bool physfsDrive::Rename(const char * oldname,const char * newname) {
 	CROSS_FILENAME(newold);
 	dirCache.ExpandName(newold);
 	normalize(newold,basedir);
-
+	
 	char newnew[CROSS_LEN];
 	strcpy(newnew,basedir);
 	strcat(newnew,newname);
@@ -372,7 +371,7 @@ bool physfsDrive::FileStat(const char* name, FileStat_Block * const stat_block)
 	CROSS_FILENAME(newname);
 	dirCache.ExpandName(newname);
 	normalize(newname,basedir);
-	time_t mytime = PHYSFS_getLastModTime(newname);
+	time_t mytime = (time_t)PHYSFS_getLastModTime(newname);
 	/* Convert the stat to a FileStat */
 	struct tm *time;
 	if((time=localtime(&mytime))!=0) {
@@ -415,7 +414,7 @@ void *physfsDrive::opendir(const char *name) {
 	char myname[CROSS_LEN];
 	strcpy(myname,name);
 	normalize(myname,basedir);
-	if (!PHYSFS_isDirectory(myname)) return false;
+	if (!PHYSFS_isDirectory(myname)) return NULL;
 
 	struct opendirinfo *oinfo = (struct opendirinfo *)malloc(sizeof(struct opendirinfo));
 	oinfo->files = PHYSFS_enumerateFiles(myname);
@@ -476,7 +475,7 @@ physfsDrive::physfsDrive(const char * startdir,Bit16u _bytes_sector,Bit8u _secto
 		strcpy(newname,startdir);
 	}
 
-	CROSS_FILENAME(newname);
+	CROSS_FILENAME(newname);	
 	if (!physfs_used) {
 		PHYSFS_init("");
 		PHYSFS_permitSymbolicLinks(1);
@@ -510,7 +509,7 @@ physfsDrive::physfsDrive(const char * startdir,Bit16u _bytes_sector,Bit8u _secto
 			PHYSFS_setWriteDir(oldwrite);
 	}
 	if (oldwrite) free((char *)oldwrite);
-
+	
 	strcpy(basedir,lastdir);
 
 	allocation.bytes_sector=_bytes_sector;
@@ -559,7 +558,7 @@ bool physfsFile::Read(Bit8u * data,Bit16u * size) {
 	}
 	if (last_action==WRITE) prepareRead();
 	last_action=READ;
-	PHYSFS_sint64 mysize = PHYSFS_read(fhandle,data,1,(PHYSFS_uint64)*size);
+	PHYSFS_sint64 mysize = PHYSFS_read(fhandle,data,1,(PHYSFS_uint32)*size);
 	//LOG_MSG("Read %i bytes (wanted %i) at %i of %s (%s)",(int)mysize,(int)*size,(int)PHYSFS_tell(fhandle),name,PHYSFS_getLastError());
 	*size = (Bit16u)mysize;
 	return true;
@@ -575,13 +574,14 @@ bool physfsFile::Write(Bit8u * data,Bit16u * size) {
 	if (*size==0) {
 		if (PHYSFS_tell(fhandle) == 0) {
 			PHYSFS_close(PHYSFS_openWrite(pname));
+            return false;
 			//LOG_MSG("Truncate %s (%s)",name,PHYSFS_getLastError());
 		} else {
-			LOG_MSG("PHYSFS TODO: truncate not yet implemented (%s at %i)",pname,PHYSFS_tell(fhandle));
+			LOG_MSG("PHYSFS TODO: truncate not yet implemented (%s at %lld)",pname,PHYSFS_tell(fhandle));
 			return false;
 		}
 	} else {
-		PHYSFS_sint64 mysize = PHYSFS_write(fhandle,data,1,(PHYSFS_uint64)*size);
+		PHYSFS_sint64 mysize = PHYSFS_write(fhandle,data,1,(PHYSFS_uint32)*size);
 		//LOG_MSG("Wrote %i bytes (wanted %i) at %i of %s (%s)",(int)mysize,(int)*size,(int)PHYSFS_tell(fhandle),name,PHYSFS_getLastError());
 		*size = (Bit16u)mysize;
 		return true;
@@ -592,14 +592,14 @@ bool physfsFile::Seek(Bit32u * pos,Bit32u type) {
 	switch (type) {
 	case DOS_SEEK_SET:break;
 	case DOS_SEEK_CUR:mypos += PHYSFS_tell(fhandle); break;
-	case DOS_SEEK_END:mypos += PHYSFS_fileLength(fhandle);-mypos; break;
+	case DOS_SEEK_END:mypos += PHYSFS_fileLength(fhandle); break;
 	default:
 	//TODO Give some doserrorcode;
 		return false;//ERROR
 	}
 
 	if (!PHYSFS_seek(fhandle,mypos)) {
-		// Out of file range, pretend everythings ok
+		// Out of file range, pretend everythings ok 
 		// and move file pointer top end of file... ?! (Black Thorne)
 		PHYSFS_seek(fhandle,PHYSFS_fileLength(fhandle));
 	};
@@ -615,6 +615,7 @@ bool physfsFile::prepareRead() {
 	fhandle = PHYSFS_openRead(pname);
 	PHYSFS_seek(fhandle, pos);
 	//LOG_MSG("Goto read (%s at %i)",pname,PHYSFS_tell(fhandle));
+    return true;
 }
 
 #ifndef WIN32
@@ -648,7 +649,7 @@ bool physfsFile::prepareWrite() {
 		PHYSFS_sint64 size;
 		PHYSFS_seek(fhandle, 0);
 		while ((size = PHYSFS_read(fhandle,buffer,1,65536)) > 0) {
-			if (PHYSFS_write(whandle,buffer,1,size) != size) {
+			if (PHYSFS_write(whandle,buffer,1,(PHYSFS_uint32)size) != size) {
 				LOG_MSG("PHYSFS copy-on-write failed: %s.",PHYSFS_getLastError());
 				PHYSFS_close(whandle);
 				return false;
@@ -662,7 +663,7 @@ bool physfsFile::prepareWrite() {
 		PHYSFS_close(fhandle);
 		fhandle = PHYSFS_openAppend(pname);
 #ifndef WIN32
-		int rc = fcntl(**(int**)fhandle->opaque,F_SETFL,0);
+		fcntl(**(int**)fhandle->opaque,F_SETFL,0);
 #endif
 		PHYSFS_seek(fhandle, pos);
 	}
@@ -682,18 +683,18 @@ bool physfsFile::Close() {
 Bit16u physfsFile::GetInformation(void) {
 	return info;
 }
-
+	
 
 physfsFile::physfsFile(const char* _name, PHYSFS_file * handle,Bit16u devinfo, const char* physname, bool write) {
 	fhandle=handle;
 	info=devinfo;
 	strcpy(pname,physname);
-	time_t mytime = PHYSFS_getLastModTime(pname);
+	time_t mytime = (time_t)PHYSFS_getLastModTime(pname);
 	/* Convert the stat to a FileStat */
-	struct tm *time;
-	if((time=localtime(&mytime))!=0) {
-		this->time=DOS_PackTime((Bit16u)time->tm_hour,(Bit16u)time->tm_min,(Bit16u)time->tm_sec);
-		this->date=DOS_PackDate((Bit16u)(time->tm_year+1900),(Bit16u)(time->tm_mon+1),(Bit16u)time->tm_mday);
+	struct tm *lctime;
+	if((lctime=localtime(&mytime))!=0) {
+		this->time=DOS_PackTime((Bit16u)lctime->tm_hour,(Bit16u)lctime->tm_min,(Bit16u)lctime->tm_sec);
+		this->date=DOS_PackDate((Bit16u)(lctime->tm_year+1900),(Bit16u)(lctime->tm_mon+1),(Bit16u)lctime->tm_mday);
 	} else {
 		this->time=DOS_PackTime(0,0,0);
 		this->date=DOS_PackDate(1980,1,1);
@@ -709,12 +710,12 @@ physfsFile::physfsFile(const char* _name, PHYSFS_file * handle,Bit16u devinfo, c
 
 bool physfsFile::UpdateDateTimeFromHost(void) {
 	if(!open) return false;
-	time_t mytime = PHYSFS_getLastModTime(pname);
+	time_t mytime = (time_t)PHYSFS_getLastModTime(pname);
 	/* Convert the stat to a FileStat */
-	struct tm *time;
-	if((time=localtime(&mytime))!=0) {
-		this->time=DOS_PackTime((Bit16u)time->tm_hour,(Bit16u)time->tm_min,(Bit16u)time->tm_sec);
-		this->date=DOS_PackDate((Bit16u)(time->tm_year+1900),(Bit16u)(time->tm_mon+1),(Bit16u)time->tm_mday);
+	struct tm *lctime;
+	if((lctime=localtime(&mytime))!=0) {
+		this->time=DOS_PackTime((Bit16u)lctime->tm_hour,(Bit16u)lctime->tm_min,(Bit16u)lctime->tm_sec);
+		this->date=DOS_PackDate((Bit16u)(lctime->tm_year+1900),(Bit16u)(lctime->tm_mon+1),(Bit16u)lctime->tm_mday);
 	} else {
 		this->time=DOS_PackTime(0,0,0);
 		this->date=DOS_PackDate(1980,1,1);
@@ -732,11 +733,11 @@ bool MSCDEX_HasMediaChanged(Bit8u subUnit);
 bool MSCDEX_GetVolumeName(Bit8u subUnit, char* name);
 
 
-physfscdromDrive::physfscdromDrive(const char driveLetter, const char * startdir,Bit16u _bytes_sector,Bit8u _sectors_cluster,Bit16u _total_clusters,Bit16u _free_clusters,Bit8u _mediaid, int& error)
+physfscdromDrive::physfscdromDrive(const char letter, const char * startdir,Bit16u _bytes_sector,Bit8u _sectors_cluster,Bit16u _total_clusters,Bit16u _free_clusters,Bit8u _mediaid, int& error)
 		   :physfsDrive(startdir,_bytes_sector,_sectors_cluster,_total_clusters,_free_clusters,_mediaid)
 {
 	// Init mscdex
-	error = MSCDEX_AddDrive(driveLetter,startdir,subUnit);
+	error = MSCDEX_AddDrive(letter,startdir,subUnit);
 	// Get Volume Label
 	char name[32];
 	if (MSCDEX_GetVolumeName(subUnit,name)) dirCache.SetLabel(name,true,true);
@@ -835,7 +836,7 @@ bool physfscdromDrive::isRemovable(void) {
 }
 
 Bits physfscdromDrive::UnMount(void) {
-	return true;
+	return 0;
 }
 
 #endif // C_HAVE_PHYSFS
diff --git a/src/dos/drive_virtual.cpp b/src/dos/drive_virtual.cpp
index d3a584d8..7a871677 100644
--- a/src/dos/drive_virtual.cpp
+++ b/src/dos/drive_virtual.cpp
@@ -155,19 +155,19 @@ bool Virtual_Drive::FileOpen(DOS_File * * file,const char * name,Bit32u flags) {
 	return false;
 }
 
-bool Virtual_Drive::FileCreate(DOS_File * * /*file*/,const char * /*name*/,Bit16u /*attributes*/) {
+bool Virtual_Drive::FileCreate(DOS_File * * file,const char * name,Bit16u attributes) {
 	return false;
 }
 
-bool Virtual_Drive::FileUnlink(const char * /*name*/) {
+bool Virtual_Drive::FileUnlink(const char * name) {
 	return false;
 }
 
-bool Virtual_Drive::RemoveDir(const char * /*dir*/) {
+bool Virtual_Drive::RemoveDir(const char * dir) {
 	return false;
 }
 
-bool Virtual_Drive::MakeDir(const char * /*dir*/) {
+bool Virtual_Drive::MakeDir(const char * dir) {
 	return false;
 }
 
@@ -200,8 +200,8 @@ bool Virtual_Drive::FileExists(const char* name){
 	return false;
 }
 
-bool Virtual_Drive::FindFirst(const char * /*_dir*/,DOS_DTA & dta,bool fcb_findfirst) {
-	search_file = first_file;
+bool Virtual_Drive::FindFirst(const char * _dir,DOS_DTA & dta,bool fcb_findfirst) {
+	search_file=first_file;
 	Bit8u attr;char pattern[DOS_NAMELENGTH_ASCII];
 	dta.GetSearchParams(attr,pattern);
 	if (attr == DOS_ATTR_VOLUME) {
@@ -232,7 +232,7 @@ bool Virtual_Drive::FindNext(DOS_DTA & dta) {
 }
 
 bool Virtual_Drive::GetFileAttr(const char * name,Bit16u * attr) {
-	VFILE_Block * cur_file = first_file;
+	VFILE_Block * cur_file=first_file;
 	while (cur_file) {
 		if (strcasecmp(name,cur_file->name)==0) { 
 			*attr = DOS_ATTR_ARCHIVE;	//Maybe readonly ?
@@ -243,7 +243,7 @@ bool Virtual_Drive::GetFileAttr(const char * name,Bit16u * attr) {
 	return false;
 }
 
-bool Virtual_Drive::Rename(const char * /*oldname*/,const char * /*newname*/) {
+bool Virtual_Drive::Rename(const char * oldname,const char * newname) {
 	return false;
 }
 
diff --git a/src/dos/drives.cpp b/src/dos/drives.cpp
index 1ff73e08..42f7d68b 100644
--- a/src/dos/drives.cpp
+++ b/src/dos/drives.cpp
@@ -112,12 +112,22 @@ void Set_Label(char const * const input, char * const output, bool cdrom) {
 DOS_Drive::DOS_Drive() {
 	curdir[0]=0;
 	info[0]=0;
+	//--Added 2009-10-25 by Alun Bestor to record the base system path for a drive
+	systempath[0]=0;
+	//--End of modifications
 }
 
 const char * DOS_Drive::GetInfo(void) {
 	return info;
 }
 
+//--Added 2009-10-25 by Alun Bestor to retrieve the base system path for a drive
+char * DOS_Drive::getSystemPath(void) {
+	return systempath;
+}
+//--End of modifications
+
+
 // static members variables
 int DriveManager::currentDrive;
 DriveManager::DriveInfo DriveManager::driveInfos[26];
diff --git a/src/dos/drives.h b/src/dos/drives.h
index bcef9a22..d589fc1e 100644
--- a/src/dos/drives.h
+++ b/src/dos/drives.h
@@ -53,8 +53,8 @@ class localDrive : public DOS_Drive {
 public:
 	localDrive(const char * startdir,Bit16u _bytes_sector,Bit8u _sectors_cluster,Bit16u _total_clusters,Bit16u _free_clusters,Bit8u _mediaid);
 	virtual bool FileOpen(DOS_File * * file,const char * name,Bit32u flags);
-	virtual FILE *GetSystemFilePtr(char const * const name, char const * const type);
-	virtual bool GetSystemFilename(char* sysName, char const * const dosName);
+	virtual FILE *GetSystemFilePtr(char const * const name, char const * const type); 
+	virtual bool GetSystemFilename(char* sysName, char const * const dosName); 
 	virtual bool FileCreate(DOS_File * * file,const char * name,Bit16u attributes);
 	virtual bool FileUnlink(const char * name);
 	virtual bool RemoveDir(const char * dir);
@@ -71,15 +71,20 @@ public:
 	virtual bool isRemote(void);
 	virtual bool isRemovable(void);
 	virtual Bits UnMount(void);
-	// const char* getBasedir() {return basedir;};
 	virtual char const * GetLabel(){return dirCache.GetLabel();};
 	virtual void SetLabel(const char *label, bool iscdrom, bool updatable) { dirCache.SetLabel(label,iscdrom,updatable); };
 	virtual void *opendir(const char *dir);
 	virtual void closedir(void *handle);
 	virtual bool read_directory_first(void *handle, char* entry_name, bool& is_directory);
 	virtual bool read_directory_next(void *handle, char* entry_name, bool& is_directory);
+
 	virtual void EmptyCache(void) { dirCache.EmptyCache(); };
-private:
+
+	//Added 2010-12-11 by Alun Bestor to give Boxer the ability to do directory cache lookups
+	virtual bool getShortName(const char* dirpath, const char*filename, char* shortname) { return dirCache.GetShortName(dirpath, filename, shortname); };
+	//End of modifications
+	
+protected:
 	DOS_Drive_Cache dirCache;
 	char basedir[CROSS_LEN];
 	friend void DOS_Shell::CMD_SUBST(char* args); 	
@@ -216,8 +221,6 @@ public:
 	imageDisk *loadedDisk;
 	bool created_successfully;
 private:
-	Bit32u partSectOff;
-	DOS_Drive_Cache dirCache;
 	Bit32u getClusterValue(Bit32u clustNum);
 	void setClusterValue(Bit32u clustNum, Bit32u clustValue);
 	Bit32u getClustFirstSect(Bit32u clustNum);
diff --git a/src/dosbox.cpp b/src/dosbox.cpp
index 85097647..b89fde81 100644
--- a/src/dosbox.cpp
+++ b/src/dosbox.cpp
@@ -131,6 +131,10 @@ bool ticksLocked;
 static Bitu Normal_Loop(void) {
 	Bits ret;
 	while (1) {
+		//--Added 2009-12-27 by Alun Bestor to short-circuit the emulation loop when we need to
+		if (!boxer_runLoopShouldContinue()) return 1;
+		//--End of modifications
+		
 		if (PIC_RunQueue()) {
 			ret=(*cpudecoder)();
 			if (GCC_UNLIKELY(ret<0)) return 1;
@@ -143,6 +147,9 @@ static Bitu Normal_Loop(void) {
 #endif
 		} else {
 			GFX_Events();
+            //--Check again at this point in case our own events have cancelled the emulation.
+            if (!boxer_runLoopShouldContinue()) return 1;
+            //--End of modifications
 			if (ticksRemain>0) {
 				TIMER_AddTick();
 				ticksRemain--;
@@ -244,7 +251,14 @@ void DOSBOX_SetNormalLoop() {
 void DOSBOX_RunMachine(void){
 	Bitu ret;
 	do {
+        //--Modified 2011-09-25 by Alun Bestor to bracket iterations of the run loop
+        //with our own callbacks. We pass along the contextInfo parameter so that
+        //Boxer knows which iteration of the runloop is running (in case of nested runloops).
+        void *contextInfo;
+        boxer_runLoopWillStartWithContextInfo(&contextInfo);
 		ret=(*loop)();
+        boxer_runLoopDidFinishWithContextInfo(contextInfo);
+        //--End of modifications.
 	} while (!ret);
 }
 
@@ -470,7 +484,7 @@ void DOSBOX_Init(void) {
 	
 	const char* mputypes[] = { "intelligent", "uart", "none",0};
 	// FIXME: add some way to offer the actually available choices.
-	const char *devices[] = { "default", "win32", "alsa", "oss", "coreaudio", "coremidi","none", 0};
+	const char *devices[] = { "default", "win32", "alsa", "oss", "coreaudio", "coremidi", "mt32", "none", 0};
 	Pstring = secprop->Add_string("mpu401",Property::Changeable::WhenIdle,"intelligent");
 	Pstring->Set_values(mputypes);
 	Pstring->Set_help("Type of MPU-401 to emulate.");
@@ -481,8 +495,57 @@ void DOSBOX_Init(void) {
 
 	Pstring = secprop->Add_string("midiconfig",Property::Changeable::WhenIdle,"");
 	Pstring->Set_help("Special configuration options for the device driver. This is usually the id of the device you want to use.\n"
+	                  "  or in the case of coreaudio, you can specify a soundfont here.\n"
+	                  "  When using a Roland MT-32 rev. 0 as midi output device, some games may require a delay in order to prevent 'buffer overflow' issues.\n"
+	                  "  In that case, add 'delaysysex', for example: midiconfig=2 delaysysex\n"
 	                  "  See the README/Manual for more details.");
 
+	const char *mt32ReverseStereo[] = {"off", "on",0};
+	Pstring = secprop->Add_string("mt32ReverseStereo",Property::Changeable::WhenIdle,"off");
+	Pstring->Set_values(mt32ReverseStereo);
+	Pstring->Set_help("Reverse stereo channels for MT-32 output");
+    
+	const char *mt32DACModes[] = {"0", "1", "2", "3", "auto",0};
+	Pstring = secprop->Add_string("mt32DAC",Property::Changeable::WhenIdle,"auto");
+	Pstring->Set_values(mt32DACModes);
+	Pstring->Set_help("MT-32 DAC input mode\n"
+                      "Nice = 0 - default\n"
+                      "Produces samples at double the volume, without tricks.\n"
+                      "Higher quality than the real devices\n\n"
+                      
+                      "Pure = 1\n"
+                      "Produces samples that exactly match the bits output from the emulated LA32.\n"
+                      "Nicer overdrive characteristics than the DAC hacks (it simply clips samples within range)\n"
+                      "Much less likely to overdrive than any other mode.\n"
+                      "Half the volume of any of the other modes, meaning its volume relative to the reverb\n"
+                      "output when mixed together directly will sound wrong. So, reverb level must be lowered.\n"
+                      "Perfect for developers while debugging :)\n\n"
+                      
+                      "GENERATION1 = 2\n"
+                      "Re-orders the LA32 output bits as in early generation MT-32s (according to Wikipedia).\n"
+                      "Bit order at DAC (where each number represents the original LA32 output bit number, and XX means the bit is always low):\n"
+                      "15 13 12 11 10 09 08 07 06 05 04 03 02 01 00 XX\n\n"
+                      
+                      "GENERATION2 = 3\n"
+                      "Re-orders the LA32 output bits as in later geneerations (personally confirmed on my CM-32L - KG).\n"
+                      "Bit order at DAC (where each number represents the original LA32 output bit number):\n"
+                      "15 13 12 11 10 09 08 07 06 05 04 03 02 01 00 14\n\n");
+	const char *mt32reverbModes[] = {"0", "1", "2", "3", "auto",0};
+	Pstring = secprop->Add_string("mt32reverb.mode",Property::Changeable::WhenIdle,"auto");
+	Pstring->Set_values(mt32reverbModes);
+	Pstring->Set_help("MT-32 reverb mode");
+    
+	const char *mt32reverbTimes[] = {"0", "1", "2", "3", "4", "5", "6", "7",0};
+	Pint = secprop->Add_int("mt32reverb.time",Property::Changeable::WhenIdle,5);
+	Pint->Set_values(mt32reverbTimes);
+	Pint->Set_help("MT-32 reverb time"); 
+    
+	const char *mt32reverbLevels[] = {"0", "1", "2", "3", "4", "5", "6", "7",0};
+	Pint = secprop->Add_int("mt32reverb.level",Property::Changeable::WhenIdle,3);
+	Pint->Set_values(mt32reverbLevels);
+	Pint->Set_help("MT-32 reverb level");
+    
+    
 #if C_DEBUG
 	secprop=control->AddSection_prop("debug",&DEBUG_Init);
 #endif
diff --git a/src/fpu/fpu_instructions_x86.h b/src/fpu/fpu_instructions_x86.h
index 16d96d66..53a9a3c8 100644
--- a/src/fpu/fpu_instructions_x86.h
+++ b/src/fpu/fpu_instructions_x86.h
@@ -1162,12 +1162,12 @@ static void FPU_FLD_F80(PhysPt addr) {
 
 static void FPU_FLD_I16(PhysPt addr,Bitu store_to) {
 	fpu.p_regs[8].m1 = (Bit32u)mem_readw(addr);
-	FPUD_LOAD(fild,WORD,)
+	FPUD_LOAD(fild,WORD,s)
 }
 
 static void FPU_FLD_I16_EA(PhysPt addr) {
 	fpu.p_regs[8].m1 = (Bit32u)mem_readw(addr);
-	FPUD_LOAD_EA(fild,WORD,)
+	FPUD_LOAD_EA(fild,WORD,s)
 }
 
 static void FPU_FLD_I32(PhysPt addr,Bitu store_to) {
@@ -1212,7 +1212,7 @@ static void FPU_FST_F80(PhysPt addr) {
 }
 
 static void FPU_FST_I16(PhysPt addr) {
-	FPUD_STORE(fistp,WORD,)
+	FPUD_STORE(fistp,WORD,s)
 	mem_writew(addr,(Bit16u)fpu.p_regs[8].m1);
 }
 
@@ -1222,7 +1222,7 @@ static void FPU_FST_I32(PhysPt addr) {
 }
 
 static void FPU_FST_I64(PhysPt addr) {
-	FPUD_STORE(fistp,QWORD,q)
+	FPUD_STORE(fistp,QWORD,ll)
 	mem_writed(addr,fpu.p_regs[8].m1);
 	mem_writed(addr+4,fpu.p_regs[8].m2);
 }
diff --git a/src/gui/midi.cpp b/src/gui/midi.cpp
index 61d15e55..660da03d 100644
--- a/src/gui/midi.cpp
+++ b/src/gui/midi.cpp
@@ -19,6 +19,10 @@
 #include <assert.h>
 #include <string.h>
 #include <stdlib.h>
+#include <string>
+#include <algorithm>
+
+#include "SDL.h"
 
 #include "dosbox.h"
 #include "cross.h"
@@ -27,6 +31,11 @@
 #include "mapper.h"
 #include "pic.h"
 #include "hardware.h"
+#include "timer.h"
+
+//--Added 2011-09-25 by Alun Bestor to let Boxer hook into MIDI messaging
+#include "BXCoalfaceAudio.h"
+//--End of modifications
 
 #define SYSEX_SIZE 1024
 #define RAWBUF	1024
@@ -77,26 +86,31 @@ MidiHandler Midi_none;
 
 /* Include different midi drivers, lowest ones get checked first for default */
 
-#if defined(MACOSX)
-
-#include "midi_coremidi.h"
-#include "midi_coreaudio.h"
-
-#elif defined (WIN32)
-
-#include "midi_win32.h"
-
-#else
-
-#include "midi_oss.h"
-
-#endif
+//--Disabled 2011-09-25 by Alun Bestor: all MIDI handling is now done by Boxer
 
-#if defined (HAVE_ALSA)
+//#if defined(MACOSX)
+//
+//#include "midi_coremidi.h"
+//#include "midi_coreaudio.h"
+//
+//#elif defined (WIN32)
+//
+//#include "midi_win32.h"
+//
+//#else
+//
+//#include "midi_oss.h"
+//
+//#endif
+//
+//#if defined (HAVE_ALSA)
+//
+//#include "midi_alsa.h"
+//
+//#endif
 
-#include "midi_alsa.h"
+//--End of modifications
 
-#endif
 
 static struct {
 	Bitu status;
@@ -107,26 +121,64 @@ static struct {
 	struct {
 		Bit8u buf[SYSEX_SIZE];
 		Bitu used;
+		Bitu delay;
+		Bit32u start;
 	} sysex;
 	bool available;
 	MidiHandler * handler;
 } midi;
 
 void MIDI_RawOutByte(Bit8u data) {
+	if (midi.sysex.start) {
+		Bit32u passed_ticks = GetTicks() - midi.sysex.start;
+		if (passed_ticks < midi.sysex.delay) SDL_Delay(midi.sysex.delay - passed_ticks);
+	}
+
 	/* Test for a realtime MIDI message */
 	if (data>=0xf8) {
 		midi.rt_buf[0]=data;
-		midi.handler->PlayMsg(midi.rt_buf);
+        //--Replaced 2011-09-25 by Alun Bestor to pass messages on to our own MIDI handling
+        //midi.handler->PlayMsg(midi.rt_buf);
+        boxer_sendMIDIMessage(midi.rt_buf);
+        //--End of modifications
 		return;
 	}	 
 	/* Test for a active sysex tranfer */
 	if (midi.status==0xf0) {
 		if (!(data&0x80)) { 
-			if (midi.sysex.used<(SYSEX_SIZE-1)) midi.sysex.buf[midi.sysex.used++]=data;
+			if (midi.sysex.used<(SYSEX_SIZE-1)) midi.sysex.buf[midi.sysex.used++] = data;
 			return;
 		} else {
-			midi.sysex.buf[midi.sysex.used++]=0xf7;
-			midi.handler->PlaySysex(midi.sysex.buf,midi.sysex.used);
+			midi.sysex.buf[midi.sysex.used++] = 0xf7;
+
+			if ((midi.sysex.start) && (midi.sysex.used >= 4) && (midi.sysex.used <= 9) && (midi.sysex.buf[1] == 0x41) && (midi.sysex.buf[3] == 0x16)) {
+				LOG(LOG_ALL,LOG_ERROR)("MIDI:Skipping invalid MT-32 SysEx midi message (too short to contain a checksum)");
+			} else {
+//				LOG(LOG_ALL,LOG_NORMAL)("Play sysex; address:%02X %02X %02X, length:%4d, delay:%3d", midi.sysex.buf[5], midi.sysex.buf[6], midi.sysex.buf[7], midi.sysex.used, midi.sysex.delay);
+                
+                //--Replaced 2011-09-25 by Alun Bestor to pass messages on to our own MIDI handling
+				//midi.handler->PlaySysex(midi.sysex.buf, midi.sysex.used);
+                boxer_sendMIDISysex(midi.sysex.buf, midi.sysex.used);
+                //--End of modifications
+                
+				if (midi.sysex.start) {
+					if (midi.sysex.buf[5] == 0x7F) {
+						midi.sysex.delay = 290; // All Parameters reset
+					} else if (midi.sysex.buf[5] == 0x10 && midi.sysex.buf[6] == 0x00 && midi.sysex.buf[7] == 0x04) {
+						midi.sysex.delay = 145; // Viking Child
+					} else if (midi.sysex.buf[5] == 0x10 && midi.sysex.buf[6] == 0x00 && midi.sysex.buf[7] == 0x01) {
+						midi.sysex.delay = 30; // Dark Sun 1
+					} else {
+						midi.sysex.delay = (Bitu)(((float)(midi.sysex.used) * 1.25f) * 1000.0f / 3125.0f) + 2;
+						//--Added 2011-04-20 by Alun Bestor as a quick fix for Colonel's Bequest,
+						//which is very time-sensitive and sends way too many sysex messages to fix one-by-one
+						if (midi.sysex.delay < 40) midi.sysex.delay = 40;
+						//--End of modifications
+					}
+					midi.sysex.start = GetTicks();
+				}
+			}
+
 			LOG(LOG_ALL,LOG_NORMAL)("Sysex message size %d",midi.sysex.used);
 			if (CaptureState & CAPTURE_MIDI) {
 				CAPTURE_AddMidi( true, midi.sysex.used-1, &midi.sysex.buf[1]);
@@ -148,28 +200,62 @@ void MIDI_RawOutByte(Bit8u data) {
 			if (CaptureState & CAPTURE_MIDI) {
 				CAPTURE_AddMidi(false, midi.cmd_len, midi.cmd_buf);
 			}
-			midi.handler->PlayMsg(midi.cmd_buf);
+            
+            //--Replaced 2011-09-25 by Alun Bestor to pass messages on to our own MIDI handling
+            //midi.handler->PlayMsg(midi.cmd_buf);
+            boxer_sendMIDIMessage(midi.cmd_buf);
+            //--End of modifications
+            
 			midi.cmd_pos=1;		//Use Running status
 		}
 	}
 }
 
-bool MIDI_Available(void)  {
-	return midi.available;
-}
+//--Disabled 2011-09-25 by Alun Bestor to let Boxer field such questions itself
+//bool MIDI_Available(void)  {
+//	return midi.available;
+//}
+//--End of modifications
 
 class MIDI:public Module_base{
 public:
 	MIDI(Section* configuration):Module_base(configuration){
 		Section_prop * section=static_cast<Section_prop *>(configuration);
 		const char * dev=section->Get_string("mididevice");
-		const char * conf=section->Get_string("midiconfig");
+		std::string fullconf=section->Get_string("midiconfig");
+        
+        //--Added 2011-09-25 by Alun Bestor to let Boxer pick up on the suggested MIDI device
+        boxer_suggestMIDIHandler(dev, fullconf.c_str());
+        //--End of modifications
+        
 		/* If device = "default" go for first handler that works */
 		MidiHandler * handler;
 //		MAPPER_AddHandler(MIDI_SaveRawEvent,MK_f8,MMOD1|MMOD2,"caprawmidi","Cap MIDI");
+        
+        //Disabled 2011-09-30 by Alun Bestor: Boxer now handles sysex delays itself
+        /*
+		midi.sysex.delay = 0;
+		midi.sysex.start = 0;
+        
+		if (fullconf.find("delaysysex") != std::string::npos) {
+			midi.sysex.start = GetTicks();
+			fullconf.erase(fullconf.find("delaysysex"));
+			LOG_MSG("MIDI:Using delayed SysEx processing");
+		}
+         */
+        //--End of modifications
+        
+		std::remove(fullconf.begin(), fullconf.end(), ' ');
+		const char * conf = fullconf.c_str();
 		midi.status=0x00;
 		midi.cmd_pos=0;
 		midi.cmd_len=0;
+        
+        //--Modified 2011-09-25 by Alun Bestor: DOSBox's MIDI handlers are all disabled,
+        //so skip straight to the 'none' handler.
+        goto getdefault;
+        //--End of modifications
+        
 		if (!strcasecmp(dev,"default")) goto getdefault;
 		handler=handler_list;
 		while (handler) {
diff --git a/src/gui/render.cpp b/src/gui/render.cpp
index 1ba60975..ad195756 100644
--- a/src/gui/render.cpp
+++ b/src/gui/render.cpp
@@ -103,7 +103,7 @@ static void RENDER_StartLineHandler(const void * s) {
 		Bitu *cache = (Bitu*)(render.scale.cacheRead);
 		for (Bits x=render.src.start;x>0;) {
 			if (GCC_UNLIKELY(src[0] != cache[0])) {
-				if (!GFX_StartUpdate( render.scale.outWrite, render.scale.outPitch )) {
+				if (!GFX_StartUpdate(&render.scale.outWrite, &render.scale.outPitch )) {
 					RENDER_DrawLine = RENDER_EmptyLineHandler;
 					return;
 				}
@@ -169,7 +169,8 @@ bool RENDER_StartUpdate(void) {
 	if (GCC_UNLIKELY( render.scale.clearCache) ) {
 //		LOG_MSG("Clearing cache");
 		//Will always have to update the screen with this one anyway, so let's update already
-		if (GCC_UNLIKELY(!GFX_StartUpdate( render.scale.outWrite, render.scale.outPitch )))
+		
+		if (GCC_UNLIKELY(!GFX_StartUpdate(&render.scale.outWrite, &render.scale.outPitch )))
 			return false;
 		render.fullFrame = true;
 		render.scale.clearCache = false;
@@ -177,7 +178,7 @@ bool RENDER_StartUpdate(void) {
 	} else {
 		if (render.pal.changed) {
 			/* Assume pal changes always do a full screen update anyway */
-			if (GCC_UNLIKELY(!GFX_StartUpdate( render.scale.outWrite, render.scale.outPitch )))
+			if (GCC_UNLIKELY(!GFX_StartUpdate(&render.scale.outWrite, &render.scale.outPitch )))
 				return false;
 			RENDER_DrawLine = render.scale.linePalHandler;
 			render.fullFrame = true;
@@ -257,8 +258,14 @@ static Bitu MakeAspectTable(Bitu skip,Bitu height,double scaley,Bitu miny) {
 	return linesadded;
 }
 
+//--Modified 2009-10-18 by Alun Bestor: make unstatic to permit Boxer to call this function itself
+/* static */ void RENDER_Reset( void ) {
+//--End of modifications
+
+	//--Added 2009-03-06 by Alun Bestor to allow Boxer to override DOSBox's scaler settings
+	boxer_applyRenderingStrategy();
+	//--End of modifications
 
-static void RENDER_Reset( void ) {
 	Bitu width=render.src.width;
 	Bitu height=render.src.height;
 	bool dblw=render.src.dblw;
@@ -421,6 +428,7 @@ forcenormal:
 	}
 /* Setup the scaler variables */
 	gfx_flags=GFX_SetSize(width,height,gfx_flags,gfx_scalew,gfx_scaleh,&RENDER_CallBack);
+	
 	if (gfx_flags & GFX_CAN_8)
 		render.scale.outMode = scalerMode8;
 	else if (gfx_flags & GFX_CAN_15)
diff --git a/src/hardware/adlib.cpp b/src/hardware/adlib.cpp
index 7a0a5e61..e57887f3 100644
--- a/src/hardware/adlib.cpp
+++ b/src/hardware/adlib.cpp
@@ -409,34 +409,34 @@ Bit8u Chip::Read( ) {
 
 }
 
-void Module::CacheWrite( Bit32u reg, Bit8u val ) {
+void Module::CacheWrite( Bit32u _reg, Bit8u val ) {
 	//capturing?
 	if ( capture ) {
-		capture->DoWrite( reg, val );
+		capture->DoWrite( _reg, val );
 	}
 	//Store it into the cache
-	cache[ reg ] = val;
+	cache[ _reg ] = val;
 }
 
-void Module::DualWrite( Bit8u index, Bit8u reg, Bit8u val ) {
+void Module::DualWrite( Bit8u index, Bit8u _reg, Bit8u val ) {
 	//Make sure you don't use opl3 features
 	//Don't allow write to disable opl3		
-	if ( reg == 5 ) {
+	if ( _reg == 5 ) {
 		return;
 	}
 	//Only allow 4 waveforms
-	if ( reg >= 0xE0 ) {
+	if ( _reg >= 0xE0 ) {
 		val &= 3;
 	} 
 	//Write to the timer?
-	if ( chip[index].Write( reg, val ) ) 
+	if ( chip[index].Write( _reg, val ) ) 
 		return;
 	//Enabling panning
-	if ( reg >= 0xc0 && reg <=0xc8 ) {
+	if ( _reg >= 0xc0 && _reg <=0xc8 ) {
 		val &= 0x0f;
 		val |= index ? 0xA0 : 0x50;
 	}
-	Bit32u fullReg = reg + (index ? 0x100 : 0);
+	Bit32u fullReg = _reg + (index ? 0x100 : 0);
 	handler->WriteReg( fullReg, val );
 	CacheWrite( fullReg, val );
 }
@@ -640,7 +640,7 @@ Module::Module( Section* configuration ) : Module_base(configuration) {
 	std::string oplemu( section->Get_string( "oplemu" ) );
 
 	mixerChan = mixerObject.Install(OPL_CallBack,rate,"FM");
-	mixerChan->SetScale( 2.0 );
+	mixerChan->SetScale( 2.0f );
 	if (oplemu == "fast") {
 		handler = new DBOPL::Handler();
 	} else if (oplemu == "compat") {
diff --git a/src/hardware/dbopl.cpp b/src/hardware/dbopl.cpp
index 56153353..b4acaa24 100644
--- a/src/hardware/dbopl.cpp
+++ b/src/hardware/dbopl.cpp
@@ -884,6 +884,9 @@ Channel* Channel::BlockTemplate( Chip* chip, Bit32u samples, Bit32s* output ) {
 			return (this + 2);
 		}
 		break;
+    //--Added 2011-10-16 by Alun Bestor: only here to silence LLVM 3.0 warning
+    default:
+        break;
 	}
 	//Init the operators with the the current vibrato and tremolo values
 	Op( 0 )->Prepare( chip );
@@ -949,6 +952,9 @@ Channel* Channel::BlockTemplate( Chip* chip, Bit32u samples, Bit32s* output ) {
 			output[ i * 2 + 0 ] += sample & maskLeft;
 			output[ i * 2 + 1 ] += sample & maskRight;
 			break;
+        //--Added 2011-10-16 by Alun Bestor: only here to silence LLVM 3.0 warning
+        default:
+            break;
 		}
 	}
 	switch( mode ) {
@@ -1243,7 +1249,7 @@ void Chip::Setup( Bit32u rate ) {
 		Bit8u index, shift;
 		EnvelopeSelect( i, index, shift );
 		//Original amount of samples the attack would take
-		Bit32s original = (Bit32u)( (AttackSamplesTable[ index ] << shift) / scale);
+		Bit32s orig = (Bit32u)( (AttackSamplesTable[ index ] << shift) / scale);
 		 
 		Bit32s guessAdd = (Bit32u)( scale * (EnvelopeIncreaseTable[ index ] << ( RATE_SH - shift - 3 )));
 		Bit32s bestAdd = guessAdd;
@@ -1252,7 +1258,7 @@ void Chip::Setup( Bit32u rate ) {
 			Bit32s volume = ENV_MAX;
 			Bit32s samples = 0;
 			Bit32u count = 0;
-			while ( volume > 0 && samples < original * 2 ) {
+			while ( volume > 0 && samples < orig * 2 ) {
 				count += guessAdd;
 				Bit32s change = count >> RATE_SH;
 				count &= RATE_MASK;
@@ -1262,7 +1268,7 @@ void Chip::Setup( Bit32u rate ) {
 				samples++;
 
 			}
-			Bit32s diff = original - samples;
+			Bit32s diff = orig - samples;
 			Bit32u lDiff = labs( diff );
 			//Init last on first pass
 			if ( lDiff < bestDiff ) {
@@ -1274,11 +1280,11 @@ void Chip::Setup( Bit32u rate ) {
 			//Below our target
 			if ( diff < 0 ) {
 				//Better than the last time
-				Bit32s mul = ((original - diff) << 12) / original;
+				Bit32s mul = ((orig - diff) << 12) / orig;
 				guessAdd = ((guessAdd * mul) >> 12);
 				guessAdd++;
 			} else if ( diff > 0 ) {
-				Bit32s mul = ((original - diff) << 12) / original;
+				Bit32s mul = ((orig - diff) << 12) / orig;
 				guessAdd = (guessAdd * mul) >> 12;
 				guessAdd--;
 			}
diff --git a/src/hardware/dma.cpp b/src/hardware/dma.cpp
index 542f5962..83e05780 100644
--- a/src/hardware/dma.cpp
+++ b/src/hardware/dma.cpp
@@ -32,6 +32,8 @@ DmaController *DmaControllers[2];
 #define EMM_PAGEFRAME4K	((0xE000*16)/4096)
 Bit32u ems_board_mapping[LINK_START];
 
+Bit32u dma_wrapping = 0xffff;
+
 static void UpdateEMSMapping(void) {
 	/* if EMS is not present, this will result in a 1:1 mapping */
 	Bitu i;
@@ -48,7 +50,9 @@ static void DMA_BlockRead(PhysPt spage,PhysPt offset,void * data,Bitu size,Bit8u
 	offset <<= dma16;
 	Bit32u dma_wrap = ((0xffff<<dma16)+dma16) | dma_wrapping;
 	for ( ; size ; size--, offset++) {
-		if (offset>(dma_wrapping<<dma16)) E_Exit("DMA segbound wrapping (read)");
+        if (offset>(dma_wrapping<<dma16)) {
+			LOG_MSG("DMA segbound wrapping (read): %x:%x size %x [%x] wrap %x",spage,offset,size,dma16,dma_wrapping);
+		}
 		offset &= dma_wrap;
 		Bitu page = highpart_addr_page+(offset >> 12);
 		/* care for EMS pageframe etc. */
@@ -67,7 +71,9 @@ static void DMA_BlockWrite(PhysPt spage,PhysPt offset,void * data,Bitu size,Bit8
 	offset <<= dma16;
 	Bit32u dma_wrap = ((0xffff<<dma16)+dma16) | dma_wrapping;
 	for ( ; size ; size--, offset++) {
-		if (offset>(dma_wrapping<<dma16)) E_Exit("DMA segbound wrapping (write)");
+		if (offset>(dma_wrapping<<dma16)) {
+			LOG_MSG("DMA segbound wrapping (write): %x:%x size %x [%x] wrap %x",spage,offset,size,dma16,dma_wrapping);
+		}
 		offset &= dma_wrap;
 		Bitu page = highpart_addr_page+(offset >> 12);
 		/* care for EMS pageframe etc. */
diff --git a/src/hardware/gus.cpp b/src/hardware/gus.cpp
index aa230dc8..5f7eb661 100644
--- a/src/hardware/gus.cpp
+++ b/src/hardware/gus.cpp
@@ -210,8 +210,10 @@ public:
 	}
 	void WritePanPot(Bit8u val) {
 		PanPot = val;
-		PanLeft = pantable[0x0f-(val & 0xf)];
-		PanRight = pantable[(val & 0xf)];
+		if ((val & 0xf) >= 8) PanLeft = pantable[val & 0xf];
+		else PanLeft = 0;
+		if ((val & 0xf) < 7) PanRight = pantable[0xf - (val & 0xf)];
+		else PanRight = 0;
 		UpdateVolumes();
 	}
 	Bit8u ReadPanPot(void) {
@@ -770,10 +772,29 @@ static void MakeTables(void) {
 		vol16bit[i]=(Bit16s)out;
 		out/=1.002709201;		/* 0.0235 dB Steps */
 	}
-	pantable[0]=0;
-	for (i=1;i<16;i++) {
-		pantable[i]=(Bit32u)(-128.0*(log((double)i/15.0)/log(2.0))*(double)(1 << RAMP_FRACT));
-	}
+	/* FIX: DOSBox 0.74 had code here that produced a pantable which
+	 *      had nothing to do with actual panning control variables.
+	 *      Instead it seemed to generate a 16-element map that started
+	 *      at 0, jumped sharply to unity and decayed to 0.
+	 *      The unfortunate result was that stock builds of DOSBox
+	 *      effectively locked Gravis Ultrasound capable programs
+	 *      to monural audio.
+	 *
+	 *      This fix generates the table properly so that they correspond
+	 *      to how much we attenuate the LEFT channel for any given
+	 *      4-bit value of the Panning register (you attenuate the
+	 *      RIGHT channel by looking at element 0xF - (val&0xF)).
+	 *
+	 *      Having made this fix I can finally enjoy old DOS demos
+	 *      in GUS stereo instead of having everything mushed into
+	 *      mono. */
+	for (i=0;i < 8;i++)
+		pantable[i] = 0;
+	for (i=8;i < 15;i++)
+		pantable[i]=(Bit32u)(-128.0*(log((double)(15-i)/7.0)/log(2.0))*(double)(1 << RAMP_FRACT));
+	/* if the program cranks the pan register all the way, ensure the
+	 * opposite channel is crushed to silence */
+	pantable[15] = 1UL << 30UL;
 }
 
 class GUS:public Module_base{
diff --git a/src/hardware/hardware.cpp b/src/hardware/hardware.cpp
index 42570b2b..df798ee4 100644
--- a/src/hardware/hardware.cpp
+++ b/src/hardware/hardware.cpp
@@ -32,11 +32,12 @@
 #include "cross.h"
 
 #if (C_SSHOT)
-#include <png.h>
+#import <libpng/png.h>
+
 #include "../libs/zmbv/zmbv.cpp"
 #endif
 
-static std::string capturedir;
+std::string capturedir;
 extern const char* RunningProgram;
 Bitu CaptureState;
 
@@ -81,7 +82,11 @@ static struct {
 #endif
 } capture;
 
+//Overridden 2014-11-30 by Alun Bestor to allow Boxer to decide where captured files should go and what they should be named.
+
+/*
 FILE * OpenCaptureFile(const char * type,const char * ext) {
+
 	if(capturedir.empty()) {
 		LOG_MSG("Please specify a capture directory");
 		return 0;
@@ -90,7 +95,7 @@ FILE * OpenCaptureFile(const char * type,const char * ext) {
 	Bitu last=0;
 	char file_start[16];
 	dir_information * dir;
-	/* Find a filename to open */
+	// Find a filename to open
 	dir = open_directory(capturedir.c_str());
 	if (!dir) {
 		//Try creating it first
@@ -120,7 +125,9 @@ FILE * OpenCaptureFile(const char * type,const char * ext) {
 	close_directory( dir );
 	char file_name[CROSS_LEN];
 	sprintf(file_name,"%s%c%s%03d%s",capturedir.c_str(),CROSS_FILESPLIT,file_start,last,ext);
-	/* Open the actual file */
+	
+	
+	// Open the actual file
 	FILE * handle=fopen(file_name,"wb");
 	if (handle) {
 		LOG_MSG("Capturing %s to %s",type,file_name);
@@ -129,6 +136,7 @@ FILE * OpenCaptureFile(const char * type,const char * ext) {
 	}
 	return handle;
 }
+*/
 
 #if (C_SSHOT)
 static void CAPTURE_AddAviChunk(const char * tag, Bit32u size, void * data, Bit32u flags) {
diff --git a/src/hardware/iohandler.cpp b/src/hardware/iohandler.cpp
index d53ad704..4744ec5c 100644
--- a/src/hardware/iohandler.cpp
+++ b/src/hardware/iohandler.cpp
@@ -23,7 +23,11 @@
 #include "inout.h"
 #include "setup.h"
 #include "cpu.h"
-#include "../src/cpu/lazyflags.h"
+//--Modified 2009-02-26 by Alun Bestor: Incorrect folder path that wont work in XCode project
+//#include "../src/cpu/lazyflags.h"
+#include "../cpu/lazyflags.h"
+//--End of modifications
+
 #include "callback.h"
 
 //#define ENABLE_PORTLOG
diff --git a/src/hardware/ipx.cpp b/src/hardware/ipx.cpp
index 7b45c805..c7f0e78d 100644
--- a/src/hardware/ipx.cpp
+++ b/src/hardware/ipx.cpp
@@ -434,7 +434,7 @@ static void handleIpxRequest(void) {
 		case 0x0006:	// cancel operation
 		{
 			RealPt ecbaddress = RealMake(SegValue(es),reg_si);
-			ECBClass* tmpECB= ECBList;
+			tmpECB= ECBList;
 			ECBClass* tmp2ECB;
 			while(tmpECB) {
 				tmp2ECB=tmpECB->nextECB;
diff --git a/src/hardware/joystick.cpp b/src/hardware/joystick.cpp
index 6aff4c40..9610c7dd 100644
--- a/src/hardware/joystick.cpp
+++ b/src/hardware/joystick.cpp
@@ -49,8 +49,15 @@ static bool write_active = false;
 static bool swap34 = false;
 bool button_wrapping_enabled = true;
 
-extern bool autofire; //sdl_mapper.cpp
+//--Modified 2011-05-08 by Alun Bestor to let Boxer set and retrieve the gameport timing programmatically.
+bool gameport_timed = true;
+//--End of modifications
 
+//--Removed 2011-04-26 by Alun Bestor: Boxer no longer includes sdl_mapper.cpp
+//extern bool autofire; //sdl_mapper.cpp
+bool autofire;
+//--End of modifications
+ 
 static Bitu read_p201(Bitu port,Bitu iolen) {
 	/* Reset Joystick to 0 after TIMEOUT ms */
 	if(write_active && ((PIC_Ticks - last_write) > TIMEOUT)) {
@@ -90,6 +97,7 @@ static Bitu read_p201(Bitu port,Bitu iolen) {
 static Bitu read_p201_timed(Bitu port,Bitu iolen) {
 	Bit8u ret=0xff;
 	double currentTick = PIC_FullIndex();
+	
 	if( stick[0].enabled ){
 		if( stick[0].xtick < currentTick ) ret &=~1;
 		if( stick[0].ytick < currentTick ) ret &=~2;
@@ -110,6 +118,7 @@ static Bitu read_p201_timed(Bitu port,Bitu iolen) {
 	return ret;
 }
 
+
 static void write_p201(Bitu port,Bitu val,Bitu iolen) {
 	/* Store writetime index */
 	write_active = true;
@@ -125,6 +134,7 @@ static void write_p201(Bitu port,Bitu val,Bitu iolen) {
 
 }
 static void write_p201_timed(Bitu port,Bitu val,Bitu iolen) {
+	
 	// Store writetime index
 	// Axes take time = 24.2 microseconds + ( 0.011 microsecons/ohm * resistance )
 	// to reset to 0
@@ -144,6 +154,22 @@ static void write_p201_timed(Bitu port,Bitu val,Bitu iolen) {
 	}
 }
 
+
+//--Modified 2011-05-08 by Alun Bestor to let Boxer toggle the gameport timing on the fly.
+static Bitu read_p201_switchable(Bitu port,Bitu iolen) {
+    boxer_setJoystickActive(true);
+    if (gameport_timed && !write_active) return read_p201_timed(port, iolen);
+	else return read_p201(port, iolen);
+}
+
+static void write_p201_switchable(Bitu port,Bitu val,Bitu iolen) {
+    boxer_setJoystickActive(true);
+	if (gameport_timed) write_p201_timed(port, val, iolen);
+	else write_p201(port, val, iolen);
+}
+//--End of modifications
+
+
 void JOYSTICK_Enable(Bitu which,bool enabled) {
 	if (which<2) stick[which].enabled=enabled;
 }
@@ -191,6 +217,7 @@ private:
 public:
 	JOYSTICK(Section* configuration):Module_base(configuration){
 		Section_prop * section=static_cast<Section_prop *>(configuration);
+		
 		const char * type=section->Get_string("joysticktype");
 		if (!strcasecmp(type,"none"))       joytype = JOY_NONE;
 		else if (!strcasecmp(type,"false")) joytype = JOY_NONE;
@@ -202,19 +229,31 @@ public:
 		else if (!strcasecmp(type,"ch"))    joytype = JOY_CH;
 		else joytype = JOY_AUTO;
 
-		bool timed = section->Get_bool("timed");
-		if(timed) {
-			ReadHandler.Install(0x201,read_p201_timed,IO_MB);
-			WriteHandler.Install(0x201,write_p201_timed,IO_MB);
-		} else {
-			ReadHandler.Install(0x201,read_p201,IO_MB);
-			WriteHandler.Install(0x201,write_p201,IO_MB);
-		}
+		//--Modified 2011-05-08 by Alun Bestor to let Boxer set and retrieve the gameport timing mode.
+		//bool timed = section->Get_bool("timed");
+//		if(timed) {
+//			ReadHandler.Install(0x201,read_p201_timed,IO_MB);
+//			WriteHandler.Install(0x201,write_p201_timed,IO_MB);
+//		} else {
+//			ReadHandler.Install(0x201,read_p201,IO_MB);
+//			WriteHandler.Install(0x201,write_p201,IO_MB);
+//		}
+		gameport_timed = section->Get_bool("timed");
+		ReadHandler.Install(0x201,read_p201_switchable,IO_MB);
+		WriteHandler.Install(0x201,write_p201_switchable,IO_MB);
+		//--End of modifications
+		
 		autofire = section->Get_bool("autofire");
 		swap34 = section->Get_bool("swap34");
 		button_wrapping_enabled = section->Get_bool("buttonwrap");
+		
+		//--Disabled 2011-04-25 by Alun Bestor: Boxer sets this itself earlier
+		/*
 		stick[0].enabled = false;
 		stick[1].enabled = false;
+		*/
+		//--End of modifications
+		
 		stick[0].xtick = stick[0].ytick = stick[1].xtick =
 		                 stick[1].ytick = PIC_FullIndex();
 	}
diff --git a/src/hardware/keyboard.cpp b/src/hardware/keyboard.cpp
index b38964b0..b5edf06b 100644
--- a/src/hardware/keyboard.cpp
+++ b/src/hardware/keyboard.cpp
@@ -25,6 +25,9 @@
 #include "mem.h"
 #include "mixer.h"
 #include "timer.h"
+//--Added 2012-02-24 by Alun Bestor to give Boxer more hooks into keyboard behaviour
+#import "BXCoalface.h"
+//--End of modifications
 
 #define KEYBUFSIZE 32
 #define KEYDELAY 0.300f			//Considering 20-30 khz serial clock and 11 bits/char
@@ -73,6 +76,11 @@ static void KEYBOARD_TransferBuffer(Bitu val) {
 	keyb.used--;
 }
 
+Bitu boxer_keyboardBufferRemaining()
+{
+    if (keyb.used >= KEYBUFSIZE) return 0;
+    else return KEYBUFSIZE - keyb.used;
+}
 
 void KEYBOARD_ClrBuffer(void) {
 	keyb.used=0;
diff --git a/src/hardware/mixer.cpp b/src/hardware/mixer.cpp
index 555205f2..5598acc1 100644
--- a/src/hardware/mixer.cpp
+++ b/src/hardware/mixer.cpp
@@ -49,6 +49,10 @@
 #include "hardware.h"
 #include "programs.h"
 
+//--Added 2012-02-26 by Alun Bestor to give Boxer control over the mixer.
+#import "BXCoalfaceAudio.h"
+//--End of modifications
+
 #define MIXER_SSIZE 4
 #define MIXER_SHIFT 14
 #define MIXER_REMAIN ((1<<MIXER_SHIFT)-1)
@@ -78,7 +82,7 @@ Bit8u MixTemp[MIXER_BUFSIZE];
 
 MixerChannel * MIXER_AddChannel(MIXER_Handler handler,Bitu freq,const char * name) {
 	MixerChannel * chan=new MixerChannel();
-	chan->scale = 1.0;
+	chan->scale = 1.0f;
 	chan->handler=handler;
 	chan->name=name;
 	chan->SetFreq(freq);
@@ -113,8 +117,12 @@ void MIXER_DelChannel(MixerChannel* delchan) {
 }
 
 void MixerChannel::UpdateVolume(void) {
-	volmul[0]=(Bits)((1 << MIXER_VOLSHIFT)*scale*volmain[0]*mixer.mastervol[0]);
-	volmul[1]=(Bits)((1 << MIXER_VOLSHIFT)*scale*volmain[1]*mixer.mastervol[1]);
+    //--Modified 2012-02-26 by Alun Bestor to give Boxer control over master volume
+	//volmul[0]=(Bits)((1 << MIXER_VOLSHIFT)*scale*volmain[0]*mixer.mastervol[0]);
+	//volmul[1]=(Bits)((1 << MIXER_VOLSHIFT)*scale*volmain[1]*mixer.mastervol[1]);
+	volmul[0]=(Bits)((1 << MIXER_VOLSHIFT)*scale*volmain[0]*boxer_masterVolume(BXLeftChannel));
+	volmul[1]=(Bits)((1 << MIXER_VOLSHIFT)*scale*volmain[1]*boxer_masterVolume(BXRightChannel));
+    //--End of modifications
 }
 
 void MixerChannel::SetVolume(float _left,float _right) {
@@ -565,7 +573,10 @@ public:
 		if (cmd->FindExist("/NOSHOW")) return;
 		chan=mixer.channels;
 		WriteOut("Channel  Main    Main(dB)\n");
-		ShowVolume("MASTER",mixer.mastervol[0],mixer.mastervol[1]);
+        //--Modified 2012-02-26 by Alun Bestor to show Boxer's master volume instead.
+		//ShowVolume("MASTER",mixer.mastervol[0],mixer.mastervol[1]);
+        ShowVolume("MASTER", boxer_masterVolume(BXLeftChannel), boxer_masterVolume(BXRightChannel));
+        //--End of modifications
 		for (chan=mixer.channels;chan;chan=chan->next) 
 			ShowVolume(chan->name,chan->volmain[0],chan->volmain[1]);
 	}
@@ -627,7 +638,8 @@ void MIXER_Init(Section* sec) {
 	mixer.pos=0;
 	mixer.done=0;
 	memset(mixer.work,0,sizeof(mixer.work));
-	mixer.mastervol[0]=1.0f;
+	
+    mixer.mastervol[0]=1.0f;
 	mixer.mastervol[1]=1.0f;
 
 	/* Start the Mixer using SDL Sound at 22 khz */
@@ -652,7 +664,7 @@ void MIXER_Init(Section* sec) {
 		mixer.tick_add=((mixer.freq) << MIXER_SHIFT)/1000;
 		TIMER_AddTickHandler(MIXER_Mix_NoSound);
 	} else {
-		if((mixer.freq != obtained.freq) || (mixer.blocksize != obtained.samples))
+		if((mixer.freq != (Bit32u)obtained.freq) || (mixer.blocksize != obtained.samples))
 			LOG_MSG("MIXER:Got different values from SDL: freq %d, blocksize %d",obtained.freq,obtained.samples);
 		mixer.freq=obtained.freq;
 		mixer.blocksize=obtained.samples;
@@ -667,3 +679,16 @@ void MIXER_Init(Section* sec) {
 	mixer.needed=mixer.min_needed+1;
 	PROGRAMS_MakeFile("MIXER.COM",MIXER_ProgramStart);
 }
+
+
+//--Added 2012-02-26 by Alun Bestor to give Boxer an easy way to update channel volumes.
+void boxer_updateVolumes()
+{
+    MixerChannel *source=mixer.channels;
+    while (source)
+    {
+        source->UpdateVolume();
+        source=source->next;
+    }
+}
+//--End of modifications
diff --git a/src/hardware/opl.cpp b/src/hardware/opl.cpp
index 29cd204f..74e6c577 100644
--- a/src/hardware/opl.cpp
+++ b/src/hardware/opl.cpp
@@ -25,6 +25,9 @@
  */
 
 
+//--Added 2009-10-18 by Alun Bestor to allow calls to memset() which were failing to compile otherwise
+#include <string.h>
+//--End of modifications
 #include <math.h>
 #include <stdlib.h> // rand()
 #include "dosbox.h"
diff --git a/src/hardware/pcspeaker.cpp b/src/hardware/pcspeaker.cpp
index 008523b4..1f9c1401 100644
--- a/src/hardware/pcspeaker.cpp
+++ b/src/hardware/pcspeaker.cpp
@@ -279,7 +279,7 @@ static void PCSPEAKER_CallBack(Bitu len) {
 				index+=vol_len;
 			} else {
 				/* Check how long it will take to goto new level */
-				float vol_time=fabs(vol_diff)/SPKR_SPEED;
+				float vol_time=(float)(fabs(vol_diff)/SPKR_SPEED);
 				if (vol_time<=vol_len) {
 					/* Volume reaches endpoint in this block, calc until that point */
 					value+=vol_time*spkr.volcur;
diff --git a/src/hardware/pic.cpp b/src/hardware/pic.cpp
index fde85022..7b9766c9 100644
--- a/src/hardware/pic.cpp
+++ b/src/hardware/pic.cpp
@@ -528,7 +528,7 @@ void TIMER_AddTick(void) {
 	/* Go through the list of scheduled events and lower their index with 1000 */
 	PICEntry * entry=pic_queue.next_entry;
 	while (entry) {
-		entry->index -= 1.0;
+		entry->index -= 1.0f;
 		entry=entry->next;
 	}
 	/* Call our list of ticker handlers */
diff --git a/src/hardware/serialport/directserial.cpp b/src/hardware/serialport/directserial.cpp
index 529c11b1..6867e901 100644
--- a/src/hardware/serialport/directserial.cpp
+++ b/src/hardware/serialport/directserial.cpp
@@ -303,9 +303,9 @@ void CDirectSerial::setBreak (bool value) {
 }
 
 // updateModemControlLines(mcr) sets DTR and RTS. 
-void CDirectSerial::setRTSDTR(bool rts, bool dtr) {
-	SERIAL_setRTS(comport,rts);
-	SERIAL_setDTR(comport,dtr);
+void CDirectSerial::setRTSDTR(bool _rts, bool _dtr) {
+	SERIAL_setRTS(comport,_rts);
+	SERIAL_setDTR(comport,_dtr);
 }
 
 void CDirectSerial::setRTS(bool val) {
diff --git a/src/hardware/serialport/misc_util.cpp b/src/hardware/serialport/misc_util.cpp
index 0243c35d..1331e63b 100644
--- a/src/hardware/serialport/misc_util.cpp
+++ b/src/hardware/serialport/misc_util.cpp
@@ -223,7 +223,7 @@ bool TCPClientSocket::Putchar(Bit8u data) {
 }
 
 bool TCPClientSocket::SendArray(Bit8u* data, Bitu bufsize) {
-	if(SDLNet_TCP_Send(mysock, data, bufsize)!=bufsize) {
+	if(SDLNet_TCP_Send(mysock, data, bufsize)!=(int)bufsize) {
 		isopen=false;
 		return false;
 	}
@@ -237,7 +237,7 @@ bool TCPClientSocket::SendByteBuffered(Bit8u data) {
 		sendbuffer[sendbufferindex]=data;
 		sendbufferindex=0;
 		
-		if(SDLNet_TCP_Send(mysock, sendbuffer, sendbuffersize)!=sendbuffersize) {
+		if(SDLNet_TCP_Send(mysock, sendbuffer, sendbuffersize)!=(int)sendbuffersize) {
 			isopen=false;
 			return false;
 		}
@@ -269,7 +269,7 @@ bool TCPClientSocket::SendArrayBuffered(Bit8u* data, Bitu bufsize) {
 void TCPClientSocket::FlushBuffer() {
 	if(sendbufferindex) {
 		if(SDLNet_TCP_Send(mysock, sendbuffer,
-			sendbufferindex)!=sendbufferindex) {
+			sendbufferindex)!=(int)sendbufferindex) {
 			isopen=false;
 			return;
 		}
diff --git a/src/hardware/serialport/nullmodem.cpp b/src/hardware/serialport/nullmodem.cpp
index 668ebc4c..680472b5 100644
--- a/src/hardware/serialport/nullmodem.cpp
+++ b/src/hardware/serialport/nullmodem.cpp
@@ -207,7 +207,7 @@ Bits CNullModem::readChar() {
 	if(telnet && rxchar>=0) return TelnetEmulation((Bit8u)rxchar);
 	else if(rxchar==0xff && !transparent) {// escape char
 		// get the next char
-		Bits rxchar = clientsocket->GetcharNonBlock();
+		rxchar = clientsocket->GetcharNonBlock();
 		if(rxchar==0xff) return rxchar; // 0xff 0xff -> 0xff was meant
 		rxchar&0x1? setCTS(true) : setCTS(false);
 		rxchar&0x2? setDSR(true) : setDSR(false);
@@ -570,13 +570,13 @@ void CNullModem::setBreak (bool /*value*/) {
 /*****************************************************************************/
 void CNullModem::setRTSDTR(bool xrts, bool xdtr) {
 	if(!transparent) {
-		Bit8u control[2];
-		control[0]=0xff;
-		control[1]=0x0;
-		if(xrts) control[1]|=1;
-		if(xdtr) control[1]|=2;
-		if(LCR&LCR_BREAK_MASK) control[1]|=4;
-		if(clientsocket) clientsocket->SendArray(control, 2);
+		Bit8u _control[2];
+		_control[0]=0xff;
+		_control[1]=0x0;
+		if(xrts) _control[1]|=1;
+		if(xdtr) _control[1]|=2;
+		if(LCR&LCR_BREAK_MASK) _control[1]|=4;
+		if(clientsocket) clientsocket->SendArray(_control, 2);
 	}
 }
 void CNullModem::setRTS(bool val) {
diff --git a/src/hardware/serialport/serialdummy.cpp b/src/hardware/serialport/serialdummy.cpp
index f4dd904c..3c595f1d 100644
--- a/src/hardware/serialport/serialdummy.cpp
+++ b/src/hardware/serialport/serialdummy.cpp
@@ -85,9 +85,9 @@ void CSerialDummy::setBreak(bool value) {
 /*****************************************************************************/
 /* setRTSDTR sets the modem control lines                                   **/
 /*****************************************************************************/
-void CSerialDummy::setRTSDTR(bool rts, bool dtr) {
-	setRTS(rts);
-	setDTR(dtr);
+void CSerialDummy::setRTSDTR(bool _rts, bool _dtr) {
+	setRTS(_rts);
+	setDTR(_dtr);
 }
 void CSerialDummy::setRTS(bool val) {
 #ifdef CHECKIT_TESTPLUG
diff --git a/src/hardware/serialport/softmodem.cpp b/src/hardware/serialport/softmodem.cpp
index 78029a91..7f14f9fc 100644
--- a/src/hardware/serialport/softmodem.cpp
+++ b/src/hardware/serialport/softmodem.cpp
@@ -148,13 +148,14 @@ void CSerialModem::SendRes(ResTypes response) {
 	char const * string;Bitu code;
 	switch (response)
 	{
-		case ResNONE:		return;
 		case ResOK:			string="OK"; code=0; break;
 		case ResERROR:		string="ERROR"; code=4; break;
 		case ResRING:		string="RING"; code=2; break;
 		case ResNODIALTONE: string="NO DIALTONE"; code=6; break;
 		case ResNOCARRIER:	string="NO CARRIER" ;code=3; break;
 		case ResCONNECT:	string="CONNECT 57600"; code=1; break;
+		case ResNONE:
+		default:			return;
 	}
 	
 	if(doresponse!=1) {
@@ -271,7 +272,7 @@ void CSerialModem::EnterIdleState(void){
 	}
 	// get rid of everything
 	if(serversocket) {
-		while(waitingclientsocket=serversocket->Accept())
+		while((waitingclientsocket=serversocket->Accept()))
 			delete waitingclientsocket;
 	} else if (listenport) {
 		
@@ -648,7 +649,7 @@ void CSerialModem::TelnetEmulation(Bit8u * data, Bitu size) {
 
 void CSerialModem::Timer2(void) {
 
-	unsigned long args = 1;
+	//unsigned long args = 1;
 	bool sendbyte = true;
 	Bitu usesize;
 	Bit8u txval;
@@ -783,8 +784,8 @@ void CSerialModem::setBreak(bool) {
 	// TODO: handle this
 }
 
-void CSerialModem::setRTSDTR(bool rts, bool dtr) {
-	setDTR(dtr);
+void CSerialModem::setRTSDTR(bool _rts, bool _dtr) {
+	setDTR(_dtr);
 }
 void CSerialModem::setRTS(bool val) {
 	
diff --git a/src/hardware/tandy_sound.cpp b/src/hardware/tandy_sound.cpp
index 7ee942f9..0be15473 100644
--- a/src/hardware/tandy_sound.cpp
+++ b/src/hardware/tandy_sound.cpp
@@ -144,7 +144,7 @@ static void SN76496Write(Bitu /*port*/,Bitu data,Bitu /*iolen*/) {
 					R->NoiseFB = (n & 4) ? FB_WNOISE : FB_PNOISE;
 					n &= 3;
 					/* N/512,N/1024,N/2048,Tone #3 output */
-					R->Period[3] = (n == 3) ? 2 * R->Period[2] : (R->UpdateStep << (5+n));
+					R->Period[3] = (n == 3) ? 2 * R->Period[2] : (int)(R->UpdateStep << (5+n));
 
 					/* reset noise shifter */
 //					R->RNG = NG_PRESET;
@@ -405,7 +405,7 @@ static void TandyDACWrite(Bitu port,Bitu data,Bitu /*iolen*/) {
 		}
 		break;
 	case 0xc6:
-		tandy.dac.frequency = tandy.dac.frequency & 0xf00 | (Bit8u)(data&0xff);
+		tandy.dac.frequency = (tandy.dac.frequency & 0xf00) | (Bit8u)(data&0xff);
 		switch (tandy.dac.mode&3) {
 		case 0:
 			// joystick mode
@@ -418,7 +418,7 @@ static void TandyDACWrite(Bitu port,Bitu data,Bitu /*iolen*/) {
 		}
 		break;
 	case 0xc7:
-		tandy.dac.frequency = tandy.dac.frequency & 0x00ff | (((Bit8u)(data&0xf))<<8);
+		tandy.dac.frequency = (tandy.dac.frequency & 0x00ff) | (((Bit8u)(data&0xf))<<8);
 		tandy.dac.amplitude = (Bit8u)(data>>5);
 		switch (tandy.dac.mode&3) {
 		case 0:
diff --git a/src/hardware/vga_draw.cpp b/src/hardware/vga_draw.cpp
index 33ee8cdb..c8e3ef2e 100644
--- a/src/hardware/vga_draw.cpp
+++ b/src/hardware/vga_draw.cpp
@@ -18,6 +18,7 @@
 
 /* $Id: vga_draw.cpp,v 1.112 2009-11-03 21:06:59 h-a-l-9000 Exp $ */
 
+#include <stdio.h>
 #include <string.h>
 #include <math.h>
 #include "dosbox.h"
@@ -27,6 +28,10 @@
 #include "vga.h"
 #include "pic.h"
 
+//--Added 2011-04-18 by Alun Bestor to fix endianness issues in Tandy/CGA line-printing
+#import <CoreFoundation/CFByteOrder.h>
+//--endif
+
 //#undef C_DEBUG
 //#define C_DEBUG 1
 //#define LOG(X,Y) LOG_MSG
@@ -100,18 +105,20 @@ static Bit8u * VGA_Draw_CGA16_Line(Bitu vidstart, Bitu line) {
 		temp3 = temp[i] + temp[i+1] + temp[i+2] + temp[i+3]; i++;
 		temp4 = temp[i] + temp[i+1] + temp[i+2] + temp[i+3]; i++;
 
-		*draw++ = 0x80808080|(temp1|val1) |
+		//--Modified 2011-04-19 by Alun Bestor to fix swapped pixel columns on PowerPC Macs
+		*draw++ = CFSwapInt32HostToLittle(0x80808080|(temp1|val1) |
 		          ((temp2|val1) << 8) |
 		          ((temp3|val1) <<16) |
-		          ((temp4|val1) <<24);
+		          ((temp4|val1) <<24));
 		temp1 = temp[i] + temp[i+1] + temp[i+2] + temp[i+3]; i++;
 		temp2 = temp[i] + temp[i+1] + temp[i+2] + temp[i+3]; i++;
 		temp3 = temp[i] + temp[i+1] + temp[i+2] + temp[i+3]; i++;
 		temp4 = temp[i] + temp[i+1] + temp[i+2] + temp[i+3]; i++;
-		*draw++ = 0x80808080|(temp1|val2) |
+		*draw++ = CFSwapInt32HostToLittle(0x80808080|(temp1|val2) |
 		          ((temp2|val2) << 8) |
 		          ((temp3|val2) <<16) |
-		          ((temp4|val2) <<24);
+		          ((temp4|val2) <<24));
+		//--End of modifications
 	}
 	return TempLine;
 }
@@ -124,10 +131,13 @@ static Bit8u * VGA_Draw_4BPP_Line(Bitu vidstart, Bitu line) {
 		++vidstart;
 		Bitu val2 = base[vidstart & vga.tandy.addr_mask];
 		++vidstart;
-		*draw++=(val1 & 0x0f) << 8  |
+		
+		//--Modified 2011-04-19 by Alun Bestor to fix swapped pixel columns on PowerPC Macs
+		*draw++=CFSwapInt32HostToLittle((val1 & 0x0f) << 8  |
 				(val1 & 0xf0) >> 4  |
 				(val2 & 0x0f) << 24 |
-				(val2 & 0xf0) << 12;
+				(val2 & 0xf0) << 12);
+		//--End of modifications
 	}
 	return TempLine;
 }
@@ -138,10 +148,13 @@ static Bit8u * VGA_Draw_4BPP_Line_Double(Bitu vidstart, Bitu line) {
 	for (Bitu x=0;x<vga.draw.blocks;x++) {
 		Bitu val = base[vidstart & vga.tandy.addr_mask];
 		++vidstart;
-		*draw++=(val & 0xf0) >> 4  |
+		
+		//--Modified 2011-04-19 by Alun Bestor to fix swapped pixel columns on PowerPC Macs
+		*draw++=CFSwapInt32HostToLittle((val & 0xf0) >> 4  |
 				(val & 0xf0) << 4  |
 				(val & 0x0f) << 16 |
-				(val & 0x0f) << 24;
+				(val & 0x0f) << 24);
+		//--End of modifications
 	}
 	return TempLine;
 }
@@ -598,7 +611,7 @@ static Bit8u * VGA_TEXT_Xlat16_Draw_Line_9(Bitu vidstart, Bitu line) {
 		if (line<vga.draw.cursor.sline) goto skip_cursor;
 		if (line>vga.draw.cursor.eline) goto skip_cursor;
 		draw=(Bit16u*)&TempLine[font_addr*18];
-		Bit8u fg=vga.tandy.draw_base[vga.draw.cursor.address+1]&0xf;
+		fg=vga.tandy.draw_base[vga.draw.cursor.address+1]&0xf;
 		for(int i = 0; i < 8; i++) {
 			*draw++ = vga.dac.xlat16[fg];
 		}
@@ -870,7 +883,7 @@ static void VGA_VerticalTimer(Bitu /*val*/) {
 #endif
 
 	// check if some lines at the top off the screen are blanked
-	float draw_skip = 0.0;
+	float draw_skip = 0.0f;
 	if (GCC_UNLIKELY(vga.draw.vblank_skip)) {
 		draw_skip = (float)(vga.draw.delay.htotal * vga.draw.vblank_skip);
 		vga.draw.address += vga.draw.address_add * (vga.draw.vblank_skip/(vga.draw.address_line_total));
diff --git a/src/hardware/vga_other.cpp b/src/hardware/vga_other.cpp
index 710b6c07..49a3158e 100644
--- a/src/hardware/vga_other.cpp
+++ b/src/hardware/vga_other.cpp
@@ -603,7 +603,7 @@ void VGA_SetupOther(void) {
 	}
 	if (machine==MCH_HERC) {
 		Bitu base=0x3b0;
-		for (Bitu i = 0; i < 4; i++) {
+		for (i = 0; i < 4; i++) {
 			// The registers are repeated as the address is not decoded properly;
 			// The official ports are 3b4, 3b5
 			IO_RegisterWriteHandler(base+i*2,write_crtc_index_other,IO_MB);
@@ -636,3 +636,42 @@ void VGA_SetupOther(void) {
 	}
 
 }
+
+
+//--Added 2013-02-10 by Alun Bestor to give Boxer control over Hercules graphics options
+Bit8u boxer_herculesTintMode()
+{
+    return herc_pal;
+}
+
+void boxer_setHerculesTintMode(Bit8u mode)
+{
+    if (herc_pal != mode)
+    {
+        herc_pal = mode % 3;
+        if (machine == MCH_HERC)
+        {
+            Herc_Palette();
+            VGA_DAC_CombineColor(1,7);
+        }
+    }
+}
+
+double boxer_CGACompositeHueOffset()
+{
+    return hue_offset;
+}
+
+void boxer_setCGACompositeHueOffset(double offset)
+{
+    if (offset != hue_offset)
+    {
+        hue_offset = offset;
+        if (machine == MCH_CGA)
+        {
+            update_cga16_color();
+        }
+    }
+}
+//--End of modifications
+
diff --git a/src/hardware/vga_xga.cpp b/src/hardware/vga_xga.cpp
index b7f927c8..32dab428 100644
--- a/src/hardware/vga_xga.cpp
+++ b/src/hardware/vga_xga.cpp
@@ -672,7 +672,6 @@ void XGA_DrawWait(Bitu val, Bitu len) {
 					for(Bitu k = 0; k < chunks; k++) { // chunks counter
 						xga.waitcmd.newline = false;
 						for(Bitu n = 0; n < chunksize; n++) { // pixels
-							Bitu mixmode;
 							
 							// This formula can rule the world ;)
 							Bitu mask = 1 << ((((n&0xF8)+(8-(n&0x7)))-1)+chunksize*k);
diff --git a/src/ints/bios.cpp b/src/ints/bios.cpp
index 6bbaad19..9ce119e6 100644
--- a/src/ints/bios.cpp
+++ b/src/ints/bios.cpp
@@ -427,36 +427,30 @@ static Bitu INT17_Handler(void) {
 	}
     
 	switch(reg_ah) {
-	case 0x00:		/* PRINTER: Write Character */
-		if(parallelPortObjects[reg_dx]!=0) {
-			if(parallelPortObjects[reg_dx]->Putchar(reg_al)) {
-				reg_ah=parallelPortObjects[reg_dx]->getPrinterStatus();
-			} else {
-				reg_ah=1;	/* Report a timeout */
-			}
-		}
-		break;
-	case 0x01:		/* PRINTER: Initialize port */
-		if(parallelPortObjects[reg_dx]!= 0) {
-			parallelPortObjects[reg_dx]->initialize();
-			reg_ah=parallelPortObjects[reg_dx]->getPrinterStatus();
-		}
-		break;
-	case 0x02:		/* PRINTER: Get Status */
-		if(parallelPortObjects[reg_dx] != 0) {
-			reg_ah=parallelPortObjects[reg_dx]->getPrinterStatus();
-			//LOG_MSG("printer status: %x",reg_ah);
-		}
-		break;
-	case 0x20:		/* Some sort of printerdriver install check*/
-		break;
-	default:
-		E_Exit("Unhandled INT 17 call %2X",reg_ah);
+        case 0x00:		// PRINTER: Write Character
+            if(parallelPortObjects[reg_dx]!=0) {
+                if(parallelPortObjects[reg_dx]->Putchar(reg_al))
+                    reg_ah=parallelPortObjects[reg_dx]->getPrinterStatus();
+                else reg_ah=1;
+            }
+            break;
+        case 0x01:		// PRINTER: Initialize port
+            if(parallelPortObjects[reg_dx]!= 0) {
+                parallelPortObjects[reg_dx]->initialize();
+                reg_ah=parallelPortObjects[reg_dx]->getPrinterStatus();
+            }
+            break;
+        case 0x02:		// PRINTER: Get Status
+            if(parallelPortObjects[reg_dx] != 0)
+                reg_ah=parallelPortObjects[reg_dx]->getPrinterStatus();
+            //LOG_MSG("printer status: %x",reg_ah);
+            break;
 	};
 	return CBRET_NONE;
 }
 //--End of modifications
 
+
 static Bit8u INT14_Wait(Bit16u port, Bit8u mask, Bit8u timeout) {
 	double starttime = PIC_FullIndex();
 	double timeout_f = timeout * 1000.0;
@@ -1157,7 +1151,8 @@ void BIOS_SetComPorts(Bit16u baseaddr[]) {
 	equipmentword = mem_readw(BIOS_CONFIGURATION);
 	equipmentword &= (~0x0E00);
 	equipmentword |= (portcount << 9);
-	BIOS_SetEquipment(equipmentword);
+	mem_writew(BIOS_CONFIGURATION,equipmentword);
+	CMOS_SetRegister(0x14,(Bit8u)(equipmentword&0xff)); //Should be updated on changes
 }
 
 //--Added 2012-10-19 by Alun Bestor as part of parallel port emulation
@@ -1186,7 +1181,7 @@ void BIOS_SetLPTPort(Bitu port, Bit16u baseaddr) {
 	Bit16u equipmentword = mem_readw(BIOS_CONFIGURATION);
 	equipmentword &= (~0xC000);
 	equipmentword |= (portcount << 14);
-	BIOS_SetEquipment(equipmentword);
+	mem_writew(BIOS_CONFIGURATION,equipmentword);
 }
 //--End of modifications
 
diff --git a/src/ints/bios_disk.cpp b/src/ints/bios_disk.cpp
index baa8dcf2..2803aa8f 100644
--- a/src/ints/bios_disk.cpp
+++ b/src/ints/bios_disk.cpp
@@ -239,11 +239,11 @@ void imageDisk::Set_Geometry(Bit32u setHeads, Bit32u setCyl, Bit32u setSect, Bit
 	active = true;
 }
 
-void imageDisk::Get_Geometry(Bit32u * getHeads, Bit32u *getCyl, Bit32u *getSect, Bit32u *getSectSize) {
+void imageDisk::Get_Geometry(Bit32u * getHeads, Bit32u *getCyl, Bit32u *getSectors, Bit32u *getSectorSize) {
 	*getHeads = heads;
 	*getCyl = cylinders;
-	*getSect = sectors;
-	*getSectSize = sector_size;
+	*getSectors = sectors;
+	*getSectorSize = sector_size;
 }
 
 Bit8u imageDisk::GetBiosType(void) {
diff --git a/src/ints/bios_keyboard.cpp b/src/ints/bios_keyboard.cpp
index 61cc2c70..76749ce9 100644
--- a/src/ints/bios_keyboard.cpp
+++ b/src/ints/bios_keyboard.cpp
@@ -31,9 +31,11 @@
 /* SDL by default treats numlock and scrolllock different from all other keys.
  * In recent versions this can disabled by a environment variable which we set in sdlmain.cpp
  * Define the following if this is the case */
-#if SDL_VERSION_ATLEAST(1, 2, 14)
+//--Modified 2011-03-30 by Alun Bestor to reflect that this is now fixed within Boxer
+//#if SDL_VERSION_ATLEAST(1, 2, 14)
 #define CAN_USE_LOCK 1
-#endif
+//#endif
+//--End of modifications
 
 static Bitu call_int16,call_irq1,irq1_ret_ctrlbreak_callback,call_irq6;
 
@@ -166,6 +168,11 @@ static void add_key(Bit16u code) {
 }
 
 static bool get_key(Bit16u &code) {
+    //--Added 2012-04-15 to let Boxer insert its own keys
+    if (boxer_getNextKeyCodeInPasteBuffer(&code, true))
+        return true;
+    //--End of modifications
+    
 	Bit16u start,end,head,tail,thead;
 	if (machine==MCH_PCJR) {
 		/* should be done for cga and others as well, to be tested */
@@ -183,10 +190,16 @@ static bool get_key(Bit16u &code) {
 	if (thead>=end) thead=start;
 	mem_writew(BIOS_KEYBOARD_BUFFER_HEAD,thead);
 	code = real_readw(0x40,head);
+    
 	return true;
 }
 
 static bool check_key(Bit16u &code) {
+    //--Added 2012-04-15 to let Boxer insert its own keys
+    if (boxer_getNextKeyCodeInPasteBuffer(&code, false))
+        return true;
+    //--End of modifications
+    
 	Bit16u head,tail;
 	head =mem_readw(BIOS_KEYBOARD_BUFFER_HEAD);
 	tail =mem_readw(BIOS_KEYBOARD_BUFFER_TAIL);
@@ -306,8 +319,10 @@ static Bitu IRQ1_Handler(void) {
 		break;
 
 #ifdef CAN_USE_LOCK
-	case 0x3a:flags2 |=0x40;break;//CAPSLOCK
-	case 0xba:flags1 ^=0x40;flags2 &=~0x40;leds ^=0x04;break;
+    case 0x3a:flags2 |=0x40;break;//CAPSLOCK
+//--Modified 2011-03-13 by Alun Bestor to let Boxer sniff the state of lock keys.
+    case 0xba:flags1 ^=0x40;flags2 &=~0x40;leds ^=0x04;boxer_setCapsLockActive(flags1 & 0x40);break;
+//--End of modifications
 #else
 	case 0x3a:flags2 |=0x40;flags1 |=0x40;leds |=0x04;break; //SDL gives only the state instead of the toggle					/* Caps Lock */
 	case 0xba:flags1 &=~0x40;leds &=~0x04;break;
@@ -351,30 +366,34 @@ static Bitu IRQ1_Handler(void) {
 			flags1 &=~0x20;
 			leds &=~0x02;
 #endif
+            //--Added 2011-03-13 by Alun Bestor to let Boxer sniff the state of lock keys.
+            boxer_setNumLockActive(flags1 & 0x20);
+            //--End of modifications
 		}
-		break;
-	case 0x46:						/* Scroll Lock or Ctrl-Break */
-		/* if it has E0 prefix, or is Ctrl-NumLock on non-enhanced keyboard => Break */
-		if((flags3&0x02) || (!(flags3&0x10) && (flags1&0x04))) {	/* Ctrl-Break? */
-			/* remove 0xe0-prefix */
-			flags3 &=~0x02;
-			printf("Triggering honest-to-god Ctrl+Break.\n");
-			mem_writeb(BIOS_KEYBOARD_FLAGS3,flags3);
-			mem_writeb(BIOS_CTRL_BREAK_FLAG,0x80);
-			empty_keyboard_buffer();
-			SegSet16(cs, RealSeg(CALLBACK_RealPointer(irq1_ret_ctrlbreak_callback)));
-			reg_ip = RealOff(CALLBACK_RealPointer(irq1_ret_ctrlbreak_callback));
-			return CBRET_NONE;
-		} else {													/* Scroll Lock. */
-			flags2 |=0x10;
-		}
-		break;
-	case 0xc6:
-		if((flags3&0x02) || (!(flags3&0x10) && (flags1&0x04))) {	/* Ctrl-Break released? */
-			/* nothing to do */
-		} else {
-			flags1 ^=0x10;flags2 &=~0x10;leds ^=0x01;break;			/* Scroll Lock released */
-		}
+        break;
+        case 0x46:						/* Scroll Lock or Ctrl-Break */
+            /* if it has E0 prefix, or is Ctrl-NumLock on non-enhanced keyboard => Break */
+            if((flags3&0x02) || (!(flags3&0x10) && (flags1&0x04))) {				/* Ctrl-Break? */
+                /* remove 0xe0-prefix */
+                flags3 &=~0x02;
+                mem_writeb(BIOS_KEYBOARD_FLAGS3,flags3);
+                mem_writeb(BIOS_CTRL_BREAK_FLAG,0x80);
+                empty_keyboard_buffer();
+                SegSet16(cs, RealSeg(CALLBACK_RealPointer(irq1_ret_ctrlbreak_callback)));
+                reg_ip = RealOff(CALLBACK_RealPointer(irq1_ret_ctrlbreak_callback));
+                return CBRET_NONE;
+            } else {                                        /* Scroll Lock. */
+                flags2 |=0x10;				/* Scroll Lock SDL Seems to do this one fine (so break and make codes) */
+            }
+            break;
+        case 0xc6:
+            if((flags3&0x02) || (!(flags3&0x10) && (flags1&0x04))) {				/* Ctrl-Break released? */
+                /* nothing to do */
+            } else {
+                //--Modified 2011-03-13 by Alun Bestor to let Boxer sniff the state of lock keys.
+                flags1 ^=0x10;flags2 &=~0x10;leds ^=0x01;boxer_setScrollLockActive(flags1 & 0x10);break;		/* Scroll Lock released */
+                //--End of modifications
+            }
 //	case 0x52:flags2|=128;break;//See numpad					/* Insert */
 	case 0xd2:	
 		if(flags3&0x02) { /* Maybe honour the insert on keypad as well */
@@ -480,11 +499,13 @@ irq1_end:
 	return CBRET_NONE;
 }
 
+
 static Bitu IRQ1_CtrlBreakAfterInt1B(void) {
 	BIOS_AddKeyToBuffer(0x0000);
 	return CBRET_NONE;
 }
 
+
 /* check whether key combination is enhanced or not,
    translate key if necessary */
 static bool IsEnhancedKey(Bit16u &key) {
@@ -513,6 +534,14 @@ static bool IsEnhancedKey(Bit16u &key) {
 
 static Bitu INT16_Handler(void) {
 	Bit16u temp=0;
+    
+    //--Added 2012-08-19 by Alun Bestor to let Boxer interrupt keyboard listening loops
+    if (!boxer_continueListeningForKeyEvents())
+    {
+        return CBRET_STOP;
+    }
+    //--End of modifications
+    
 	switch (reg_ah) {
 	case 0x00: /* GET KEYSTROKE */
 		if ((get_key(temp)) && (!IsEnhancedKey(temp))) {
diff --git a/src/ints/ems.cpp b/src/ints/ems.cpp
index a24a4a41..5ecbeb6b 100644
--- a/src/ints/ems.cpp
+++ b/src/ints/ems.cpp
@@ -750,7 +750,7 @@ static Bitu INT67_Handler(void) {
 		switch (reg_al) {
 			case 0x00: // use physical page numbers
 				{	PhysPt data = SegPhys(ds)+reg_si;
-					for (int i=0; i<reg_cx; i++) {
+					for (i=0; i<reg_cx; i++) {
 						Bit16u logPage	= mem_readw(data); data+=2;
 						Bit16u physPage = mem_readw(data); data+=2;
 						reg_ah = EMM_MapPage(physPage,reg_dx,logPage);
@@ -759,7 +759,7 @@ static Bitu INT67_Handler(void) {
 				} break;
 			case 0x01: // use segment address 
 				{	PhysPt data = SegPhys(ds)+reg_si;
-					for (int i=0; i<reg_cx; i++) {
+					for (i=0; i<reg_cx; i++) {
 						Bit16u logPage	= mem_readw(data); data+=2;
 						reg_ah = EMM_MapSegment(mem_readw(data),reg_dx,logPage); data+=2;
 						if (reg_ah!=EMM_NO_ERROR) break;
@@ -789,7 +789,7 @@ static Bitu INT67_Handler(void) {
 		if (reg_al==0x00) {
 			PhysPt data = SegPhys(es)+reg_di;
 			Bit16u step = 0x1000 / EMM_MAX_PHYS;
-			for (Bit16u i=0; i<EMM_MAX_PHYS; i++) {
+			for (i=0; i<EMM_MAX_PHYS; i++) {
 				mem_writew(data,EMM_PAGEFRAME+step*i);	data+=2;
 				mem_writew(data,i);						data+=2;
 			};
diff --git a/src/ints/int10_char.cpp b/src/ints/int10_char.cpp
index 672c0bf9..5e415276 100644
--- a/src/ints/int10_char.cpp
+++ b/src/ints/int10_char.cpp
@@ -513,7 +513,7 @@ void WriteChar(Bit16u col,Bit16u row,Bit8u page,Bit8u chr,Bit8u attr,bool useatt
 	}
 
 	//Some weird behavior of mode 6 (and 11) 
-	if ((CurMode->mode == 0x6)/* || (CurMode->mode==0x11)*/) attr = (attr&0x80)|1;
+	if (CurMode->mode == 0x6/* || CurMode->mode==0x11*/) attr = (attr&0x80)|1;
 	//(same fix for 11 fixes vgatest2, but it's not entirely correct according to wd)
 
 	x=8*col;
diff --git a/src/ints/mouse.cpp b/src/ints/mouse.cpp
index e0aa8b66..eaf4d568 100644
--- a/src/ints/mouse.cpp
+++ b/src/ints/mouse.cpp
@@ -34,6 +34,8 @@
 #include "bios.h"
 #include "dos_inc.h"
 
+
+
 static Bitu call_int33,call_int74,int74_ret_callback,call_mouse_bd;
 static Bit16u ps2cbseg,ps2cbofs;
 static bool useps2callback,ps2callbackinit;
@@ -199,7 +201,7 @@ Bitu PS2_Handler(void) {
 #define MOUSE_RIGHT_RELEASED 16
 #define MOUSE_MIDDLE_PRESSED 32
 #define MOUSE_MIDDLE_RELEASED 64
-#define MOUSE_DELAY 5.0
+#define MOUSE_DELAY 5.0f
 
 void MOUSE_Limit_Events(Bitu /*val*/) {
 	mouse.timer_in_progress = false;
@@ -487,12 +489,22 @@ void Mouse_CursorMoved(float xrel,float yrel,float x,float y,bool emulate) {
 	}
 	Mouse_AddEvent(MOUSE_HAS_MOVED);
 	DrawCursor();
+	
+	//--Added 2010-05-29: let Boxer know that the program moved the mouse cursor,
+	//and feed it the new relative mouse coordinates
+	boxer_mouseMovedToPoint(mouse.x / mouse.max_x, mouse.y / mouse.max_y);
+	//--End of modifications
 }
 
 void Mouse_CursorSet(float x,float y) {
 	mouse.x=x;
 	mouse.y=y;
 	DrawCursor();
+	
+	//--Added 2010-05-29: let Boxer know that the program moved the mouse cursor,
+	//and feed it the new relative mouse coordinates
+	boxer_mouseMovedToPoint(mouse.x / mouse.max_x, mouse.y / mouse.max_y);
+	//--End of modifications
 }
 
 void Mouse_ButtonPressed(Bit8u button) {
@@ -716,7 +728,14 @@ static Bitu INT33_Handler(void) {
 		if ((Bit16s)reg_dx >= mouse.max_y) mouse.y = static_cast<float>(mouse.max_y);
 		else if (mouse.min_y >= (Bit16s)reg_dx) mouse.y = static_cast<float>(mouse.min_y); 
 		else if ((Bit16s)reg_dx != POS_Y) mouse.y = static_cast<float>(reg_dx);
+		
 		DrawCursor();
+		
+		//--Added 2010-05-29: let Boxer know that the program moved the mouse cursor,
+		//and feed it the new relative mouse coordinates
+		boxer_mouseMovedToPoint(mouse.x / mouse.max_x, mouse.y / mouse.max_y);
+		//--End of modifications
+			
 		break;
 	case 0x05:	/* Return Button Press Data */
 		{
diff --git a/src/misc/cross.cpp b/src/misc/cross.cpp
index bc4557e4..7570b0d9 100644
--- a/src/misc/cross.cpp
+++ b/src/misc/cross.cpp
@@ -192,7 +192,7 @@ bool read_directory_first(dir_information* dirp, char* entry_name, bool& is_dire
 
 //	safe_strncpy(entry_name,dentry->d_name,(FILENAME_MAX<MAX_PATH)?FILENAME_MAX:MAX_PATH);	// [include stdio.h], maybe pathconf()
 	safe_strncpy(entry_name,dentry->d_name,CROSS_LEN);
-
+    
 #ifdef DIRENT_HAS_D_TYPE
 	if(dentry->d_type == DT_DIR) {
 		is_directory = true;
@@ -223,7 +223,7 @@ bool read_directory_next(dir_information* dirp, char* entry_name, bool& is_direc
 
 //	safe_strncpy(entry_name,dentry->d_name,(FILENAME_MAX<MAX_PATH)?FILENAME_MAX:MAX_PATH);	// [include stdio.h], maybe pathconf()
 	safe_strncpy(entry_name,dentry->d_name,CROSS_LEN);
-
+    
 #ifdef DIRENT_HAS_D_TYPE
 	if(dentry->d_type == DT_DIR) {
 		is_directory = true;
diff --git a/src/misc/messages.cpp b/src/misc/messages.cpp
index b253d792..c229cd27 100644
--- a/src/misc/messages.cpp
+++ b/src/misc/messages.cpp
@@ -90,7 +90,7 @@ static void LoadMessageFile(const char * fname) {
 			if (*parser!=10 && *parser!=13) {
 				*writer++=*parser;
 			}
-			*parser++;
+			*parser += 1;
 		}
 		*writer=0;
 		/* New string name */
@@ -113,6 +113,13 @@ static void LoadMessageFile(const char * fname) {
 	fclose(mfile);
 }
 
+//--Modified 2009-02-23 by Alun Bestor: replaced this function to route all localizations off to our own translation files
+const char * MSG_Get(char const * msg)
+{
+	return boxer_localizedStringForKey(msg);
+}
+/*
+
 const char * MSG_Get(char const * msg) {
 	for(itmb tel=Lang.begin();tel!=Lang.end();tel++){	
 		if((*tel).name==msg)
@@ -122,6 +129,8 @@ const char * MSG_Get(char const * msg) {
 	}
 	return "Message not Found!\n";
 }
+*/
+//--End of modifications
 
 
 void MSG_Write(const char * location) {
diff --git a/src/misc/setup.cpp b/src/misc/setup.cpp
index 6c383366..d2fa9cca 100644
--- a/src/misc/setup.cpp
+++ b/src/misc/setup.cpp
@@ -271,8 +271,8 @@ bool Prop_string::CheckValue(Value const& in, bool warn){
 			return true;
 		}
 		if((*it).ToString() == "%u") {
-			Bitu value;
-			if(sscanf(in.ToString().c_str(),"%u",&value) == 1) {
+			Bitu val;
+			if(sscanf(in.ToString().c_str(),"%u",&val) == 1) {
 				return true;
 			}
 		}
@@ -633,7 +633,7 @@ bool Config::PrintConfig(char const * const configfilename) const {
 			}
 			i=0;
 			char prefix[80];
-			snprintf(prefix,80, "\n# %*s  ", maxwidth, "");
+			snprintf(prefix,80, "\n# %*s  ", (int)maxwidth, "");
 			while ((p = sec->Get_prop(i++))) {		
 				std::string help = p->Get_help();
 				std::string::size_type pos = std::string::npos;
@@ -641,18 +641,18 @@ bool Config::PrintConfig(char const * const configfilename) const {
 					help.replace(pos, 1, prefix);
 				}
 		     
-				fprintf(outfile, "# %*s: %s", maxwidth, p->propname.c_str(), help.c_str());
+				fprintf(outfile, "# %*s: %s", (int)maxwidth, p->propname.c_str(), help.c_str());
 
 				std::vector<Value> values = p->GetValues();
 				if (!values.empty()) {
 					fprintf(outfile, "%s%s:", prefix, MSG_Get("CONFIG_SUGGESTED_VALUES"));
-					std::vector<Value>::iterator it = values.begin();
-					while (it != values.end()) {
-						if((*it).ToString() != "%u") { //Hack hack hack. else we need to modify GetValues, but that one is const...
-							if (it != values.begin()) fputs(",", outfile);
-							fprintf(outfile, " %s", (*it).ToString().c_str());
+					std::vector<Value>::iterator value_iter = values.begin();
+					while (value_iter != values.end()) {
+						if((*value_iter).ToString() != "%u") { //Hack hack hack. else we need to modify GetValues, but that one is const...
+							if (value_iter != values.begin()) fputs(",", outfile);
+							fprintf(outfile, " %s", (*value_iter).ToString().c_str());
 						}
-						++it;
+						++value_iter;
 					}
 					fprintf(outfile,".");
 				}
diff --git a/src/misc/support.cpp b/src/misc/support.cpp
index 19d037cb..34ba78e0 100644
--- a/src/misc/support.cpp
+++ b/src/misc/support.cpp
@@ -169,7 +169,7 @@ double ConvDblWord(char * word) {
 	return 0.0f;
 }
 
-
+/*
 static char buf[1024];           //greater scope as else it doesn't always gets thrown right (linux/gcc2.95)
 void E_Exit(const char * format,...) {
 #if C_DEBUG && C_HEAVY_DEBUG
@@ -183,3 +183,4 @@ void E_Exit(const char * format,...) {
 
 	throw(buf);
 }
+ */
diff --git a/src/shell/shell.cpp b/src/shell/shell.cpp
index d9949cfe..47277175 100644
--- a/src/shell/shell.cpp
+++ b/src/shell/shell.cpp
@@ -29,10 +29,15 @@
 #include "support.h"
 
 
+
 Bitu call_shellstop;
 /* Larger scope so shell_del autoexec can use it to
  * remove things from the environment */
-Program * first_shell = 0; 
+Program * first_shell = 0;
+
+//--Added 2013-09-22 by Alun Bestor to track the currently active shell
+DOS_Shell *currentShell = NULL;
+//--End of modifications
 
 static Bitu shellstop_handler(void) {
 	return CBRET_STOP;
@@ -284,9 +289,17 @@ void DOS_Shell::RunInternal(void)
 }
 
 void DOS_Shell::Run(void) {
+    //--Added 2013-09-22 by Alun Bestor to keep a record of the currently-processing shell
+    boxer_shellWillStart(this);
+    DOS_Shell *previousShell = currentShell;
+    currentShell = this;
+    //--End of modifications
+    
 	char input_line[CMD_MAXLINE] = {0};
 	std::string line;
 	if (cmd->FindStringRemain("/C",line)) {
+        
+        
 		strcpy(input_line,line.c_str());
 		char* sep = strpbrk(input_line,"\r\n"); //GTA installer
 		if (sep) *sep = 0;
@@ -294,25 +307,47 @@ void DOS_Shell::Run(void) {
 		temp.echo = echo;
 		temp.ParseLine(input_line);		//for *.exe *.com  |*.bat creates the bf needed by runinternal;
 		temp.RunInternal();				// exits when no bf is found.
+        
+        //--Added 2013-09-22 by Alun Bestor to keep a record of the currently-processing shell
+        currentShell = previousShell;
+        boxer_shellDidFinish(this);
+        //--End of modifications
+        
 		return;
 	}
+    
 	/* Start a normal shell and check for a first command init */
-	WriteOut(MSG_Get("SHELL_STARTUP_BEGIN"),VERSION);
-#if C_DEBUG
-	WriteOut(MSG_Get("SHELL_STARTUP_DEBUG"));
-#endif
-	if (machine == MCH_CGA) WriteOut(MSG_Get("SHELL_STARTUP_CGA"));
-	if (machine == MCH_HERC) WriteOut(MSG_Get("SHELL_STARTUP_HERC"));
-	WriteOut(MSG_Get("SHELL_STARTUP_END"));
-
+    //--Modified 2012-08-19 by Alun Bestor to allow selective overriding of the startup messages.
+    if (boxer_shellShouldDisplayStartupMessages(this))
+    {
+        WriteOut(MSG_Get("SHELL_STARTUP_BEGIN"),VERSION);
+    #if C_DEBUG
+        WriteOut(MSG_Get("SHELL_STARTUP_DEBUG"));
+    #endif
+        if (machine == MCH_CGA) WriteOut(MSG_Get("SHELL_STARTUP_CGA"));
+        if (machine == MCH_HERC) WriteOut(MSG_Get("SHELL_STARTUP_HERC"));
+        WriteOut(MSG_Get("SHELL_STARTUP_END"));
+    }
+    //--End of modifications
+    
 	if (cmd->FindString("/INIT",line,true)) {
+		//--Added 2009-12-13 by Alun Bestor to let Boxer monitor the autoexec process
+		boxer_shellWillStartAutoexec(this);
+		//--End of modifications
+		
 		strcpy(input_line,line.c_str());
 		line.erase();
 		ParseLine(input_line);
 	}
 	do {
-		if (bf){
-			if(bf->ReadLine(input_line)) {
+        //--Added 2012-08-19 by Alun Bestor to let Boxer insert its own commands into batch processing.
+        if (boxer_hasPendingCommandsForShell(this))
+        {
+            boxer_executeNextPendingCommandForShell(this);
+        }
+		else if (bf){
+        //--End of modifications
+            if(bf->ReadLine(input_line)) {
 				if (echo) {
 					if (input_line[0]!='@') {
 						ShowPrompt();
@@ -324,12 +359,27 @@ void DOS_Shell::Run(void) {
 				if (echo) WriteOut("\n");
 			}
 		} else {
+            //--Added 2009-11-29 by Alun Bestor as a hook for detecting when control has returned to the DOS prompt. 
+            boxer_didReturnToShell(this);
+            //--End of modifications
+            
 			if (echo) ShowPrompt();
 			InputCommand(input_line);
-			ParseLine(input_line);
-			if (echo && !bf) WriteOut_NoParsing("\n");
+            
+            //--Added 2012-08-19 by Alun Bestor to let Boxer interrupt the command input with its own commands.
+            if (boxer_shellShouldContinue(this) && !boxer_hasPendingCommandsForShell(this))
+            {
+            //--End of modifications
+                ParseLine(input_line);
+                if (echo && !bf) WriteOut_NoParsing("\n");
+            }
 		}
-	} while (!exit);
+	} while (boxer_shellShouldContinue(this) && !exit);
+    
+    //--Added 2013-09-22 by Alun Bestor to keep a record of the currently-processing shell
+    currentShell = previousShell;
+    boxer_shellDidFinish(this);
+    //--End of modifications
 }
 
 void DOS_Shell::SyntaxError(void) {
@@ -381,16 +431,16 @@ public:
 		char buffer[CROSS_LEN];
 		char orig[CROSS_LEN];
 		char cross_filesplit[2] = {CROSS_FILESPLIT , 0};
-
-		Bitu dummy = 1;
-		bool command_found = false;
-		while (control->cmdline->FindCommand(dummy++,line) && !command_found) {
+		/* Combining -securemode and no parameter leaves you with a lovely Z:\. */ 
+		if ( !control->cmdline->FindCommand(1,line) ) { 
+			if ( secure ) autoexec[12].Install("z:\\config.com -securemode");
+		} else {
 			if (line.find(':',((line[0]|0x20) >= 'a' && (line[0]|0x20) <= 'z')?2:0) != std::string::npos) {
 				/* a physfs source */
 				autoexec[12].Install(std::string("MOUNT C \"") + line + std::string("\""));
 				autoexec[13].Install("C:");
 				if(secure) autoexec[14].Install("z:\\config.com -securemode");
-				break;
+				goto nomount;
 			}
 
 			struct stat test;
@@ -418,17 +468,17 @@ public:
 				}
 				*name++ = 0;
 				if (access(buffer,F_OK)) goto nomount;
-				/* Save the non-modified filename (so physfs, boot and imgmount can use it (long filenames, case sensivitive)) */
+				/* Save the non modified filename (so boot and imgmount can use it (long filenames, case sensivitive)*/
 				strcpy(orig,name);
 				upcase(name);
 				if((strstr(name,".ZIP") != 0) || (strstr(name,".7Z") != 0)) {
 					//TODO:Add more extensions?
-					LOG_MSG("Mounting %s as PHYSFS write directory", buffer);
-					autoexec[12].Install(std::string("MOUNT C \"") + buffer + std::string(":") + orig
+					LOG_MSG("Mouting %s as PHYSFS write directory", buffer);
+					autoexec[12].Install(std::string("MOUNT C \"") + buffer + std::string(":") + name
 						+ std::string(":\""));
 					autoexec[13].Install("C:");
 					if(secure) autoexec[14].Install("z:\\config.com -securemode");
-					break;
+					goto nomount;
 				}
 				autoexec[12].Install(std::string("MOUNT C \"") + buffer + "\"");
 				autoexec[13].Install("C:");
@@ -650,7 +700,7 @@ void SHELL_Init() {
 	DOS_ForceDuplicateEntry(1,0);				/* "new" STDIN */
 	DOS_ForceDuplicateEntry(1,2);				/* STDERR */
 	DOS_OpenFile("CON",OPEN_READWRITE,&dummy);	/* STDAUX */
-	DOS_OpenFile("CON",OPEN_READWRITE,&dummy);	/* STDPRN */
+	DOS_OpenFile("PRN",OPEN_READWRITE,&dummy);	/* STDPRN */
 
 	psp.SetParent(psp_seg);
 	/* Set the environment */
diff --git a/src/shell/shell_batch.cpp b/src/shell/shell_batch.cpp
index b259651e..dde890e3 100644
--- a/src/shell/shell_batch.cpp
+++ b/src/shell/shell_batch.cpp
@@ -24,6 +24,10 @@
 #include "shell.h"
 #include "support.h"
 
+//--Added 2013-09-22 by Alun Bestor to let Boxer track batch files
+#include "BXCoalface.h"
+//--End of modifications
+
 BatchFile::BatchFile(DOS_Shell * host,char const * const resolved_name,char const * const entered_name, char const * const cmd_line) {
 	location = 0;
 	prev=host->bf;
@@ -46,6 +50,10 @@ BatchFile::~BatchFile() {
 	delete cmd;
 	shell->bf=prev;
 	shell->echo=echo;
+    
+    //--Added 2013-09-22 by Alun Bestor to let Boxer track the lifecycle of the batch file
+    boxer_shellDidEndBatchFile(shell, filename.c_str());
+    //--End of modifications
 }
 
 bool BatchFile::ReadLine(char * line) {
diff --git a/src/shell/shell_cmds.cpp b/src/shell/shell_cmds.cpp
index 49ff8277..d9a5182a 100644
--- a/src/shell/shell_cmds.cpp
+++ b/src/shell/shell_cmds.cpp
@@ -31,6 +31,7 @@
 #include <vector>
 #include <string>
 
+
 static SHELL_Cmd cmd_list[]={
 {	"DIR",		0,			&DOS_Shell::CMD_DIR,		"SHELL_CMD_DIR_HELP"},
 {	"CHDIR",	1,			&DOS_Shell::CMD_CHDIR,		"SHELL_CMD_CHDIR_HELP"},
@@ -140,6 +141,13 @@ void DOS_Shell::DoCommand(char * line) {
 	}
 	*cmd_write=0;
 	if (strlen(cmd_buffer)==0) return;
+	
+	//--Added 2009-02-20 by Alun Bestor to hook into DOS shell for our own nefarious purposes
+	//We do this here to preempt whatever DOSBox would like to do
+	if (!boxer_shellShouldRunCommand(this, cmd_buffer, line))
+        return;
+	//--End of modifications
+	
 /* Check the internal list */
 	Bit32u cmd_index=0;
 	while (cmd_list[cmd_index].name) {
@@ -155,6 +163,18 @@ void DOS_Shell::DoCommand(char * line) {
 	WriteOut(MSG_Get("SHELL_EXECUTE_ILLEGAL_COMMAND"),cmd_buffer);
 }
 
+//--Added 2009-02-23 by Alun Bestor to allow commands that expect arguments to display their help text when no arguments were provided
+#define HELP_IF_NO_ARGS(command) \
+	if (ScanCMDBool(args,"?") || !strlen(args)) { \
+		WriteOut(MSG_Get("SHELL_CMD_" command "_HELP")); \
+		const char* long_m = MSG_Get("SHELL_CMD_" command "_HELP_LONG"); \
+		WriteOut("\n"); \
+		if(strcmp("Message not Found!\n",long_m)) WriteOut(long_m); \
+		else WriteOut(command "\n"); \
+		return; \
+	}
+//--End of modifications
+
 #define HELP(command) \
 	if (ScanCMDBool(args,"?")) { \
 		WriteOut(MSG_Get("SHELL_CMD_" command "_HELP")); \
@@ -172,16 +192,25 @@ void DOS_Shell::CMD_CLS(char * args) {
 }
 
 void DOS_Shell::CMD_DELETE(char * args) {
-	HELP("DELETE");
+	//--Modified 2009-02-24 by Alun Bestor to show help text when no arguments were given
+	//HELP("DELETE");
+	HELP_IF_NO_ARGS("DELETE");
+	//--End of modifications
+	
 	/* Command uses dta so set it to our internal dta */
 	RealPt save_dta=dos.dta();
 	dos.dta(dos.tables.tempdta);
 
+	//--Disabled 2009-02-24 by Alun Bestor: bailing out upon encountering unrecognised switches was preventing the use of unix/style/paths
+	/*
 	char * rem=ScanCMDRemain(args);
 	if (rem) {
 		WriteOut(MSG_Get("SHELL_ILLEGAL_SWITCH"),rem);
 		return;
 	}
+	*/
+	//--End of modification
+
 	/* If delete accept switches mind the space infront of them. See the dir /p code */ 
 
 	char full[DOS_PATHLENGTH];
@@ -227,7 +256,11 @@ void DOS_Shell::CMD_HELP(char * args){
 }
 
 void DOS_Shell::CMD_RENAME(char * args){
-	HELP("RENAME");
+	//--Modified 2010-12-29 by Alun Bestor to show help text when no arguments were given
+	//HELP("RENAME");
+	HELP_IF_NO_ARGS("RENAME");
+	//--End of modifications
+	
 	StripSpaces(args);
 	if(!*args) {SyntaxError();return;}
 	if((strchr(args,'*')!=NULL) || (strchr(args,'?')!=NULL) ) { WriteOut(MSG_Get("SHELL_CMD_NO_WILD"));return;}
@@ -297,15 +330,38 @@ void DOS_Shell::CMD_EXIT(char * args) {
 }
 
 void DOS_Shell::CMD_CHDIR(char * args) {
+	//--Note 2009-02-24 by Alun Bestor: I would like to add implicit help for CD, but there's the possibility that batchfiles would
+	//send the output of CD to a file or env variable...
 	HELP("CHDIR");
+	
 	StripSpaces(args);
 	if (!*args) {
 		Bit8u drive=DOS_GetDefaultDrive()+'A';
 		char dir[DOS_PATHLENGTH];
 		DOS_GetCurrentDir(0,dir);
 		WriteOut("%c:\\%s\n",drive,dir);
-	} else if(strlen(args) == 2 && args[1]==':') {
-		WriteOut(MSG_Get("SHELL_CMD_CHDIR_HINT"),toupper(*reinterpret_cast<unsigned char*>(&args[0])));
+	}
+	
+	//--Modified 2009-02-24 by Alun Bestor: instead of telling the user they can just type C: why don't you do what they wanted to do in the first place
+	//Also tweaked it so that if the path is prefixed with a drive letter, we switch to that drive first
+	else if(strlen(args) >= 2 && args[1]==':') {
+	//else if(strlen(args) == 2 && args[1]==':') {
+		//WriteOut(MSG_Get("SHELL_CMD_CHDIR_HINT"),toupper(*reinterpret_cast<unsigned char*>(&args[0])));
+		
+		//Extract the drive letter and change to it
+		std::string driveLetter(args, 2);
+		DoCommand(const_cast<char*>(driveLetter.c_str()));
+
+		//If there's more path on the end, run CD again with that as the arguments
+		if (strlen(args) > 2)
+		{
+			std::string path(args);
+			path = path.substr(2);
+			CMD_CHDIR(const_cast<char*>(path.c_str()));
+		}
+		else return;
+	//--End of modifications
+		
 	} else 	if (!DOS_ChangeDir(args)) {
 		/* Changedir failed. Check if the filename is longer then 8 and/or contains spaces */
 	   
@@ -341,26 +397,46 @@ void DOS_Shell::CMD_CHDIR(char * args) {
 }
 
 void DOS_Shell::CMD_MKDIR(char * args) {
-	HELP("MKDIR");
+	//--Modified 2009-02-24 by Alun Bestor to show help text when no arguments were given
+	//HELP("MKDIR");
+	HELP_IF_NO_ARGS("MKDIR");
+	//--End of modifications
+	
 	StripSpaces(args);
+	
+	//--Disabled 2009-02-24 by Alun Bestor: bailing out upon encountering unrecognised switches was preventing the use of unix/style/paths
+	/*
 	char * rem=ScanCMDRemain(args);
 	if (rem) {
 		WriteOut(MSG_Get("SHELL_ILLEGAL_SWITCH"),rem);
 		return;
 	}
+	*/
+	//--End of modifications
+	
 	if (!DOS_MakeDir(args)) {
 		WriteOut(MSG_Get("SHELL_CMD_MKDIR_ERROR"),args);
 	}
 }
 
 void DOS_Shell::CMD_RMDIR(char * args) {
-	HELP("RMDIR");
+	//--Modified 2009-02-24 by Alun Bestor to show help text when no arguments were given
+	//HELP("RMDIR");
+	HELP_IF_NO_ARGS("RMDIR");
+	//--End of modifications
+	
 	StripSpaces(args);
+	
+	//--Disabled 2009-02-24 by Alun Bestor: bailing out upon encountering unrecognised switches was preventing the use of unix/style/paths
+	/*
 	char * rem=ScanCMDRemain(args);
 	if (rem) {
 		WriteOut(MSG_Get("SHELL_ILLEGAL_SWITCH"),rem);
 		return;
 	}
+	*/
+	//--End of modifications
+	
 	if (!DOS_RemoveDir(args)) {
 		WriteOut(MSG_Get("SHELL_CMD_RMDIR_ERROR"),args);
 	}
@@ -411,11 +487,17 @@ void DOS_Shell::CMD_DIR(char * args) {
 	}
 	bool optB=ScanCMDBool(args,"B");
 	bool optAD=ScanCMDBool(args,"AD");
+
+	//--Disabled 2009-02-24 by Alun Bestor: bailing out upon encountering unrecognised switches was preventing the use of unix/style/paths
+	/*	
 	char * rem=ScanCMDRemain(args);
 	if (rem) {
 		WriteOut(MSG_Get("SHELL_ILLEGAL_SWITCH"),rem);
 		return;
 	}
+	*/
+	//--End of modifications
+	
 	Bit32u byte_count,file_count,dir_count;
 	Bitu w_count=0;
 	Bitu p_count=0;
@@ -430,6 +512,10 @@ void DOS_Shell::CMD_DIR(char * args) {
 	} else {
 		switch (args[argLen-1])
 		{
+		//--Added 2009-02-24 by Alun Bestor to support /Unix/delimited/paths
+		case '/':
+		//--End of modifications
+		
 		case '\\':	// handle \, C:\, etc.
 		case ':' :	// handle C:, etc.
 			strcat(args,"*.*");
@@ -555,7 +641,11 @@ struct copysource {
 
 
 void DOS_Shell::CMD_COPY(char * args) {
-	HELP("COPY");
+	//--Modified 2009-02-24 by Alun Bestor to show help text when no arguments were given
+	//HELP("COPY");
+	HELP_IF_NO_ARGS("COPY");
+	//--End of modifications
+	
 	static char defaulttarget[] = ".";
 	StripSpaces(args);
 	/* Command uses dta so set it to our internal dta */
@@ -572,12 +662,17 @@ void DOS_Shell::CMD_COPY(char * args) {
 	ScanCMDBool(args,"Y");
 	ScanCMDBool(args,"-Y");
 
+	//--Disabled 2009-02-24 by Alun Bestor: bailing out upon encountering unrecognised switches was preventing the use of unix/style/paths
+	/*
 	char * rem=ScanCMDRemain(args);
 	if (rem) {
 		WriteOut(MSG_Get("SHELL_ILLEGAL_SWITCH"),rem);
 		dos.dta(save_dta);
 		return;
 	}
+	*/
+	//--End of modifications
+	
 	// Gather all sources (extension to copy more then 1 file specified at commandline)
 	// Concatating files go as follows: All parts except for the last bear the concat flag.
 	// This construction allows them to be counted (only the non concat set)
@@ -774,7 +869,11 @@ void DOS_Shell::CMD_SET(char * args) {
 }
 
 void DOS_Shell::CMD_IF(char * args) {
-	HELP("IF");
+	//--Modified 2009-02-24 by Alun Bestor to show help text when no arguments were given
+	//HELP("IF");
+	HELP_IF_NO_ARGS("IF");
+	//--End of modifications
+	
 	StripSpaces(args,'=');
 	bool has_not=false;
 
@@ -861,7 +960,11 @@ void DOS_Shell::CMD_IF(char * args) {
 }
 
 void DOS_Shell::CMD_GOTO(char * args) {
-	HELP("GOTO");
+	//--Modified 2009-02-24 by Alun Bestor to show help text when no arguments were given
+	//HELP("GOTO");
+	HELP_IF_NO_ARGS("GOTO");
+	//--End of modifications
+	
 	StripSpaces(args);
 	if (!bf) return;
 	if (*args &&(*args==':')) args++;
@@ -888,8 +991,13 @@ void DOS_Shell::CMD_SHIFT(char * args ) {
 }
 
 void DOS_Shell::CMD_TYPE(char * args) {
-	HELP("TYPE");
+	//--Modified 2009-02-24 by Alun Bestor to show help text when no arguments were given
+	//HELP("TYPE");
+	HELP_IF_NO_ARGS("TYPE");
+	//--End of modifications
+	
 	StripSpaces(args);
+	
 	if (!*args) {
 		WriteOut(MSG_Get("SHELL_SYNTAXERROR"));
 		return;
@@ -924,7 +1032,11 @@ void DOS_Shell::CMD_PAUSE(char * args){
 }
 
 void DOS_Shell::CMD_CALL(char * args){
-	HELP("CALL");
+	//--Modified 2009-02-24 by Alun Bestor to show help text when no arguments were given
+	//HELP("CALL");
+	HELP_IF_NO_ARGS("CALL");
+	//--End of modifications
+	
 	this->call=true; /* else the old batchfile will be closed first */
 	this->ParseLine(args);
 	this->call=false;
@@ -934,7 +1046,11 @@ void DOS_Shell::CMD_SUBST (char * args) {
 /* If more that one type can be substed think of something else 
  * E.g. make basedir member dos_drive instead of localdrive
  */
-	HELP("SUBST");
+	//--Modified 2009-02-24 by Alun Bestor to show help text when no arguments were given
+	//HELP("SUBST");
+	HELP_IF_NO_ARGS("SUBST");
+	//--End of modifications
+	
 	localDrive* ldp=0;
 	char mountstring[DOS_PATHLENGTH+CROSS_LEN+20];
 	char temp_str[2] = { 0,0 };
@@ -987,7 +1103,11 @@ void DOS_Shell::CMD_SUBST (char * args) {
 }
 
 void DOS_Shell::CMD_LOADHIGH(char *args){
-	HELP("LOADHIGH");
+	//--Modified 2009-02-24 by Alun Bestor to show help text when no arguments were given
+	//HELP("LOADHIGH");
+	HELP_IF_NO_ARGS("LOADHIGH");
+	//--End of modifications
+	
 	Bit16u umb_start=dos_infoblock.GetStartOfUMBChain();
 	Bit8u umb_flag=dos_infoblock.GetUMBChainState();
 	Bit8u old_memstrat=(Bit8u)(DOS_GetMemAllocStrategy()&0xff);
@@ -1012,10 +1132,16 @@ void DOS_Shell::CMD_CHOICE(char * args){
 		char *last = strchr(args,0);
 		StripSpaces(args);
 		rem = ScanCMDRemain(args);
+		
+		//--Disabled 2009-02-24 by Alun Bestor: bailing out upon encountering unrecognised switches was preventing the use of unix/style/paths
+		/*
 		if (rem && *rem && (tolower(rem[1]) != 'c')) {
 			WriteOut(MSG_Get("SHELL_ILLEGAL_SWITCH"),rem);
 			return;
 		}
+		*/
+		//--End of modifications
+		
 		if (args == rem) args = strchr(rem,0)+1;
 		if (rem) rem += 2;
 		if(rem && rem[0]==':') rem++; /* optional : after /c */
diff --git a/src/shell/shell_misc.cpp b/src/shell/shell_misc.cpp
index 221ddc4c..8fc5efe5 100644
--- a/src/shell/shell_misc.cpp
+++ b/src/shell/shell_misc.cpp
@@ -27,6 +27,10 @@
 #include "callback.h"
 #include "support.h"
 
+//--Added 2010-01-21 by Alun Bestor to let Boxer hook into DOSBox internals
+#include "BXCoalface.h"
+//--End of modifications
+
 void DOS_Shell::ShowPrompt(void) {
 	Bit8u drive=DOS_GetDefaultDrive()+'A';
 	char dir[DOS_PATHLENGTH];
@@ -50,19 +54,54 @@ void DOS_Shell::InputCommand(char * line) {
 	line[0] = '\0';
 
 	std::list<std::string>::iterator it_history = l_history.begin(), it_completion = l_completion.begin();
-
+	
+	
 	while (size) {
-		dos.echo=false;
-		while(!DOS_ReadFile(input_handle,&c,&n)) {
+		dos.echo=false;		
+		
+		//--Modified 2012-08-19 by Alun Bestor to let Boxer inject its own input
+        //and cancel keyboard input listening.
+        boxer_shellWillReadCommandInputFromHandle(this, input_handle);
+		while(boxer_continueListeningForKeyEvents() && !DOS_ReadFile(input_handle,&c,&n)) {
 			Bit16u dummy;
 			DOS_CloseFile(input_handle);
 			DOS_OpenFile("con",2,&dummy);
 			LOG(LOG_MISC,LOG_ERROR)("Reopening the input handle.This is a bug!");
 		}
+        boxer_shellDidReadCommandInputFromHandle(this, input_handle);
+		
+        if (!boxer_shellShouldContinue(this))
+        {
+            return;
+        }
+        
+		bool executeImmediately = false;
+		if (boxer_handleShellCommandInput(this, line, &str_index, &executeImmediately))
+		{
+			if (executeImmediately)
+			{
+				size = 0;
+				break;
+			}
+			else
+			{
+				//Correct the visible cursor position and the cached lengths
+				str_len = strlen(line);
+				size = CMD_MAXLINE - str_len - 2;
+				int cursorOffset = str_len - str_index;
+				while (cursorOffset > 0) {
+					outc(8); cursorOffset--;
+				}
+				continue;
+			}
+		}
+		//--End of modifications
+		
 		if (!n) {
 			size=0;			//Kill the while loop
 			continue;
 		}
+		
 		switch (c) {
 		case 0x00:				/* Extended Keys */
 			{
@@ -312,6 +351,7 @@ void DOS_Shell::InputCommand(char * line) {
 			size = 0;       // stop the next loop
 			str_len = 0;    // prevent multiple adds of the same line
 			break;
+		
 		default:
 			if (l_completion.size()) l_completion.clear();
 			if(str_index < str_len && true) { //mem_readb(BIOS_KEYBOARD_FLAGS1)&0x80) dev_con.h ?
@@ -335,7 +375,9 @@ void DOS_Shell::InputCommand(char * line) {
 				str_len++;
 				size--;
 			}
+				
 			DOS_WriteFile(STDOUT,&c,&n);
+			
 			break;
 		}
 	}
@@ -426,13 +468,25 @@ bool DOS_Shell::Execute(char * name,char * args) {
 		}
 	}
 	
+	//--Added 2010-01-21 by Alun Bestor to let Boxer track the executed program
+	char canonicalPath[DOS_PATHLENGTH+4];
+	DOS_Canonicalize(fullname, canonicalPath);
+	//--End of modifications
+	
 	if (strcasecmp(extension, ".bat") == 0) 
 	{	/* Run the .bat file */
 		/* delete old batch file if call is not active*/
 		bool temp_echo=echo; /*keep the current echostate (as delete bf might change it )*/
 		if(bf && !call) delete bf;
+		
+		//--Added 2010-01-21 by Alun Bestor to let Boxer track the launched batch file
+		boxer_shellWillBeginBatchFile(this, canonicalPath, args);
+		
 		bf=new BatchFile(this,fullname,name,line);
 		echo=temp_echo; //restore it.
+        
+        //--Note: boxer_didEndBatchFile will be called once the batch file completes much later, in the batch file's own destructor.
+		//--End of modifications
 	} 
 	else 
 	{	/* only .bat .exe .com extensions maybe be executed by the shell */
@@ -440,6 +494,11 @@ bool DOS_Shell::Execute(char * name,char * args) {
 		{
 			if(strcasecmp(extension, ".exe") !=0) return false;
 		}
+		
+		//--Added 2010-01-21 by Alun Bestor to let Boxer track the executed program
+		boxer_shellWillExecuteFileAtDOSPath(this, canonicalPath, args);
+		//--End of modifications
+		
 		/* Run the .exe or .com file from the shell */
 		/* Allocate some stack space for tables in physical memory */
 		reg_sp-=0x200;
@@ -496,7 +555,12 @@ bool DOS_Shell::Execute(char * name,char * args) {
 		reg_eip=oldeip;
 		SegSet16(cs,oldcs);
 #endif
+        
+        //--Added 2010-01-21 by Alun Bestor to let Boxer track the executed program
+        boxer_shellDidExecuteFileAtDOSPath(this, canonicalPath);
+        //--End of modifications
 	}
+	
 	return true; //Executable started
 }
 
-- 
2.34.1

