From 0d8fa19223ee7f069f4f0cba22c0e65eff7a7331 Mon Sep 17 00:00:00 2001
From: Ismail Khatib <ikhatib@gmail.com>
Date: Thu, 21 Mar 2024 04:20:58 +0100
Subject: [PATCH] Add GBoxer-WIN32 patches

---
 config_gboxer_win64.h                     |  390 +++
 src/dos/cdrom.h                           |    2 +-
 src/dos/cdrom_aspi_win32.cpp              |   13 +-
 src/dos/cdrom_ioctl_win32.cpp             |    6 +-
 src/dos/dos_keyboard_layout.cpp           |   38 +-
 src/dos/drive_local.cpp                   |  402 +--
 src/dos/drive_local_gboxer.cpp            |  177 ++
 src/dos/drive_local_gboxer.h              |   51 +
 src/fpu/fpu_instructions_x86.h            | 2848 ++++++++++-----------
 src/hardware/mixer.cpp                    |   20 +-
 src/hardware/parport/printer_charmaps.cpp |   14 +
 src/hardware/vga_draw.cpp                 |   79 +-
 src/hardware/vga_other.cpp                |   67 +-
 13 files changed, 2248 insertions(+), 1859 deletions(-)
 create mode 100755 config_gboxer_win64.h
 create mode 100644 src/dos/drive_local_gboxer.cpp
 create mode 100644 src/dos/drive_local_gboxer.h

diff --git a/config_gboxer_win64.h b/config_gboxer_win64.h
new file mode 100755
index 00000000..6c14d624
--- /dev/null
+++ b/config_gboxer_win64.h
@@ -0,0 +1,390 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.in by autoheader.  */
+
+/*
+Note 2009-02-26 by Alun Bestor:
+This file is normally generated by configure to specify different compile-time settings based on the current build platform and any selected compile-time options.
+	
+However, over here in XCode-land we want things to be much more clear-cut: so our compile-time options (like sound libraries) have been hardcoded, host architecture checks have been replaced with PPC/Intel switches in place, and type size checks with mappings to standard system types.
+	
+This means that this file has had too many modifications to be safely replaceable with a copy of this file from a makefile-built DOSBox. It will need manual maintenance when the next version of DOSBox is released.
+*/
+
+
+/*
+ *  Copyright (C) 2002-2007  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+/* Determines if the compilers supports always_inline attribute. */
+#define C_ATTRIBUTE_ALWAYS_INLINE 1
+
+/* Determines if the compilers supports fastcall attribute. */
+#define C_ATTRIBUTE_FASTCALL 1
+
+/* Define to 1 to use inlined memory functions in cpu core */
+/* #undef C_CORE_INLINE */
+#define C_CORE_INLINE 1
+
+/* Define to 1 to enable internal debugger, requires libcurses */
+/* #undef C_DEBUG */
+
+/* Define to 1 if you want serial passthrough support (Win32, Posix and OS/2). */
+#define C_DIRECTSERIAL 1
+
+
+/* Define to 1 to use x86 dynamic cpu core */
+//--Modified 2009-02-26 by Alun Bestor to enable automatically for x86
+#if defined(__i386__)
+	#define C_DYNAMIC_X86 1
+#endif
+/* #undef C_DYNAMIC_X86 */
+//--End of modifications
+
+
+/* Define to 1 to use recompiling cpu core. Can not be used together with the
+   dynamic-x86 core */
+
+/* #undef C_DYNREC */
+//--Modified 2009-02-26 by Alun Bestor to enable automatically for X64
+#if defined(__x86_64__) && !defined(C_DYNAMIC_X86)
+	#define  C_DYNREC 1
+#endif
+#define C_DYNREC 1
+//--End of modifications
+
+/* Define to 1 to enable floating point emulation */
+#define C_FPU 1
+
+/* Define to 1 to use a x86 assembly fpu core */
+/* #undef C_FPU_X86 */
+//--Modified 2009-02-26 by Alun Bestor to force this on for Intel
+
+#if defined(__i386__) || defined(__x86_64__)
+	#define C_FPU_X86 1
+#endif
+
+//--End of modifications
+
+
+/* Determines if the compilers supports attributes for structures. */
+#define C_HAS_ATTRIBUTE 1
+
+/* Determines if the compilers supports __builtin_expect for branch
+   prediction. */
+#define C_HAS_BUILTIN_EXPECT 1
+
+/* Define to 1 if you have the mprotect function */
+/* #undef C_HAVE_MPROTECT */
+
+/* Define to 1 to enable heavy debugging, also have to enable C_DEBUG */
+/* #undef C_HEAVY_DEBUG */
+
+
+/* Define to 1 to enable IPX over Internet networking, requires SDL_net */
+#define C_IPX 1
+
+/* Define to 1 to enable internal modem support, requires SDL_net */
+#define C_MODEM 1
+
+/* Define to 1 to use opengl display output support */
+#define C_OPENGL 1
+
+
+/* Define to 1 to enable SDL_sound support */
+/* #undef C_SDL_SOUND */
+
+/* Define to 1 if you have setpriority support */
+/* #undef C_SET_PRIORITY */
+
+/* Define to 1 to enable screenshots, requires libpng */
+/* #undef C_SSHOT */
+#define C_SSHOT 1
+
+
+/* The type of cpu this target has */
+//--Modified 2009-02-26 by Alun Bestor to define these manually
+#if defined(__x86_64__)
+	#define C_TARGETCPU X86_64
+#elif defined(__i386__)
+	#define C_TARGETCPU X86
+#elif defined(__ppc__) || defined(__ppc64__)
+	#define C_TARGETCPU POWERPC
+#endif
+#define C_TARGETCPU X86_64
+//--End of modifications
+
+
+/* Define to 1 if your processor stores words with the most significant byte
+   first (like Motorola and SPARC, unlike Intel and VAX). */
+
+//--Modified 2009-02-26 by Alun Bestor to define this manually
+/* #undef WORDS_BIGENDIAN */
+#if defined(__BIG_ENDIAN__)
+	#define WORDS_BIGENDIAN 1
+#endif
+//--End of modifications
+
+
+/* Define to 1 to use a unaligned memory access */
+#define C_UNALIGNED_MEMORY 1
+
+/* libm doesn't include powf */
+/* #undef DB_HAVE_NO_POWF */
+
+/* environ can be included */
+#define ENVIRON_INCLUDED 1
+
+/* environ can be linked */
+/* #define ENVIRON_LINKED 1 */
+#define ENVIRON_LINKED 1
+
+/* Define to 1 to use ALSA for MIDI */
+/* #undef HAVE_ALSA */
+
+/* Define to 1 if you have the <ddraw.h> header file. */
+#define HAVE_DDRAW_H 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `asound' library (-lasound). */
+/* #undef HAVE_LIBASOUND */
+
+/* Define to 1 if you have the `m' library (-lm). */
+#define HAVE_LIBM 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+/* #undef HAVE_NETINET_IN_H */
+
+/* Define to 1 if you have the <pwd.h> header file. */
+/* #undef HAVE_PWD_H */
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+/* #undef HAVE_SYS_SOCKET_H */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Compiling on GNU/Linux */
+/* #undef LINUX */
+
+/* Compiling on Mac OS X */
+/* #undef MACOSX */
+
+// Defined if compiling for Windows (any option)
+//#ifdef _WIN32
+#ifndef WIN32
+#define WIN32 1
+#endif
+
+/* Compiling on OS/2 EMX */
+/* #undef OS2 */
+
+/* Compile with PhysicalFS support */
+#define C_HAVE_PHYSFS 0
+
+#define C_PRINTER 1
+
+//--Note 2009-02-26 by Alun Bestor: I'm assuming (hoping) these lines are unused by everything except make install
+
+/* Name of package */
+#define PACKAGE "dosbox"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "dosbox"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "dosbox 0.74"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "dosbox"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "0.74"
+
+/* Version number of package */
+#define VERSION "0.74"
+
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if your <sys/time.h> declares `struct tm'. */
+/* #undef TM_IN_SYS_TIME */
+   
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* Define to `int` if you don't have socklen_t */
+/* #undef socklen_t */
+
+
+#if C_ATTRIBUTE_ALWAYS_INLINE
+#define INLINE inline __attribute__((always_inline))
+#else
+#define INLINE inline
+#endif
+
+#if C_ATTRIBUTE_FASTCALL
+#define DB_FASTCALL __attribute__((fastcall))
+#else
+#define DB_FASTCALL
+#endif
+
+#if C_HAS_ATTRIBUTE
+#define GCC_ATTRIBUTE(x) __attribute__ ((x))
+#else
+#define GCC_ATTRIBUTE(x) /* attribute not supported */
+#endif
+
+#if C_HAS_BUILTIN_EXPECT
+#define GCC_UNLIKELY(x) __builtin_expect((x),0)
+#define GCC_LIKELY(x) __builtin_expect((x),1)
+#else
+#define GCC_UNLIKELY(x) (x)
+#define GCC_LIKELY(x) (x)
+#endif
+
+
+//--Modified 2009-02-09 by Alun Bestor: instead of going through this rigmarole, we simply map DOSBox's types to the predefined system types.
+
+#if 0
+typedef		double		Real64;
+
+#import <stdint.h>
+
+typedef		uint8_t		Bit8u;
+typedef		int8_t		Bit8s;
+
+typedef		uint16_t	Bit16u;
+typedef		int16_t		Bit16s;
+
+typedef		uint32_t	Bit32u;
+typedef		int32_t		Bit32s;
+
+typedef		uint64_t	Bit64u;
+typedef		int64_t		Bit64s;
+
+//I'd rather map these to NSUinteger and NSInteger respectively, which would give the exact same result, but that would mean importing Obj-C headers into a C++ context and the compiler would shit itself
+#if defined(__LP64__)
+	typedef Bit64u Bitu;
+	typedef Bit64s Bits;
+#else
+	typedef Bit32u Bitu;
+	typedef Bit32s Bits;
+#endif
+#endif
+
+/* The size of `int *', as computed by sizeof. */
+#define SIZEOF_INT_P 8
+
+/* The size of `unsigned char', as computed by sizeof. */
+#define SIZEOF_UNSIGNED_CHAR 1
+
+/* The size of `unsigned int', as computed by sizeof. */
+#define SIZEOF_UNSIGNED_INT 4
+
+/* The size of `unsigned long', as computed by sizeof. */
+#define SIZEOF_UNSIGNED_LONG 4
+
+/* The size of `unsigned long long', as computed by sizeof. */
+#define SIZEOF_UNSIGNED_LONG_LONG 8
+
+/* The size of `unsigned short', as computed by sizeof. */
+#define SIZEOF_UNSIGNED_SHORT 2
+
+
+typedef         double     Real64;
+
+#if SIZEOF_UNSIGNED_CHAR != 1
+#  error "sizeof (unsigned char) != 1"
+#else
+  typedef unsigned char Bit8u;
+  typedef   signed char Bit8s;
+#endif
+
+#if SIZEOF_UNSIGNED_SHORT != 2
+#  error "sizeof (unsigned short) != 2"
+#else
+  typedef unsigned short Bit16u;
+  typedef   signed short Bit16s;
+#endif
+
+#if SIZEOF_UNSIGNED_INT == 4
+  typedef unsigned int Bit32u;
+  typedef   signed int Bit32s;
+#elif SIZEOF_UNSIGNED_LONG == 4
+  typedef unsigned long Bit32u;
+  typedef   signed long Bit32s;
+#else
+#  error "can't find sizeof(type) of 4 bytes!"
+#endif
+
+#if SIZEOF_UNSIGNED_LONG == 8
+  typedef unsigned long Bit64u;
+  typedef   signed long Bit64s;
+#elif SIZEOF_UNSIGNED_LONG_LONG == 8
+  typedef unsigned long long Bit64u;
+  typedef   signed long long Bit64s;
+#else
+#  error "can't find data type of 8 bytes"
+#endif
+
+#if SIZEOF_INT_P == 4
+  typedef Bit32u Bitu;
+  typedef Bit32s Bits;
+ #else
+  typedef Bit64u Bitu;
+  typedef Bit64s Bits;
+ #endif
+
+//--End of modifications
diff --git a/src/dos/cdrom.h b/src/dos/cdrom.h
index cecbddce..0e060376 100644
--- a/src/dos/cdrom.h
+++ b/src/dos/cdrom.h
@@ -314,7 +314,7 @@ public:
 	bool	PlayAudioSector		(unsigned long start,unsigned long len);
 	bool	PauseAudio			(bool resume);
 	bool	StopAudio			(void);
-	void	ChannelControl		(TCtrl ctrl);
+	void	ChannelControl		(TCtrl ctrl) { return; };
 	
 	bool	ReadSector			(Bit8u *buffer, bool raw, unsigned long sector);
 	bool	ReadSectors			(PhysPt buffer, bool raw, unsigned long sector, unsigned long num);
diff --git a/src/dos/cdrom_aspi_win32.cpp b/src/dos/cdrom_aspi_win32.cpp
index 4c604544..824375b5 100644
--- a/src/dos/cdrom_aspi_win32.cpp
+++ b/src/dos/cdrom_aspi_win32.cpp
@@ -18,21 +18,22 @@
 
 /* $Id: cdrom_aspi_win32.cpp,v 1.21 2009-05-27 09:15:41 qbix79 Exp $ */
 
-#if defined (WIN32)
-
-#include <ctype.h>
-
-#include "dosbox.h"
 #include "cdrom.h"
 #include "support.h"
 
+#if defined (WIN32)
+
 //Are actually system includes but leave for now
-#include "wnaspi32.h"
+//#include "wnaspi32.h"
 
 #if defined (_MSC_VER)
 #include <ntddcdrm.h>			// Ioctl stuff
 #include <ntddscsi.h>
 #include <winioctl.h>			// Ioctl stuff
+#elif (defined __MINGW64_VERSION_MAJOR)
+#include <winioctl.h>			// Ioctl stuff
+#include <ntddcdrm.h>			// Ioctl stuff
+#include <ntddscsi.h>
 #else 
 #include "ddk/ntddcdrm.h"		// Ioctl stuff
 #include "ddk/ntddscsi.h"
diff --git a/src/dos/cdrom_ioctl_win32.cpp b/src/dos/cdrom_ioctl_win32.cpp
index 2008f86d..d225f90d 100644
--- a/src/dos/cdrom_ioctl_win32.cpp
+++ b/src/dos/cdrom_ioctl_win32.cpp
@@ -18,6 +18,8 @@
 
 /* $Id: cdrom_ioctl_win32.cpp,v 1.16 2009-01-07 22:39:18 c2woody Exp $ */
 
+#include "cdrom.h"
+
 #if defined (WIN32)
 
 // *****************************************************************
@@ -27,7 +29,7 @@
 #include <windows.h>
 #include <io.h>
 
-#if defined (_MSC_VER)
+#if (defined (_MSC_VER)) || (defined __MINGW64_VERSION_MAJOR)
 #include <ntddcdrm.h>			// Ioctl stuff
 #include <winioctl.h>			// Ioctl stuff
 #else 
@@ -36,8 +38,6 @@
 
 #include <mmsystem.h>
 
-#include "cdrom.h"
-
 // for a more sophisticated implementation of the mci cdda functionality
 // see the SDL sources, which the mci_ functions are based on
 
diff --git a/src/dos/dos_keyboard_layout.cpp b/src/dos/dos_keyboard_layout.cpp
index 7bfbe827..b080e28f 100644
--- a/src/dos/dos_keyboard_layout.cpp
+++ b/src/dos/dos_keyboard_layout.cpp
@@ -84,7 +84,7 @@ public:
 	void switch_foreign_layout();
 	const char* get_layout_name();
 	const char* main_language_code();
-    
+
     //--Added 2012-02-25 by Alun Bestor to support limited on-the-fly layout switching
     bool foreign_layout_active();
     bool is_US_layout();
@@ -327,7 +327,7 @@ Bitu keyboard_layout::read_keyboard_file(const char* keyboard_file_name, Bit32s
 			LOG(LOG_BIOS,LOG_ERROR)("Invalid keyboard layout file %s",keyboard_file_name);
 			return KEYB_INVALIDFILE;
 		}
-		
+
 		fseek(tempfile, 0, SEEK_SET);
 		read_buf_size=(Bit32u)fread(read_buf, sizeof(Bit8u), 65535, tempfile);
 		fclose(tempfile);
@@ -387,7 +387,7 @@ Bitu keyboard_layout::read_keyboard_file(const char* keyboard_file_name, Bit32s
 	}
 
 	bool found_matching_layout=false;
-	
+
 	// check all submappings and use them if general submapping or same codepage submapping
 	for (Bit16u sub_map=0; (sub_map<submappings) && (!found_matching_layout); sub_map++) {
 		Bit16u submap_cp, table_offset;
@@ -708,7 +708,7 @@ Bitu keyboard_layout::read_codepage_file(const char* codepage_file_name, Bit32s
 	if (!strcmp(cp_filename,"auto")) {
 		// select matching .cpi-file for specified codepage
 		switch (codepage_id) {
-			case 437:	case 850:	case 852:	case 853:	case 857:	case 858:	
+			case 437:	case 850:	case 852:	case 853:	case 857:	case 858:
 						sprintf(cp_filename, "EGA.CPI"); break;
 			case 775:	case 859:	case 1116:	case 1117:
 						sprintf(cp_filename, "EGA2.CPI"); break;
@@ -765,7 +765,7 @@ Bitu keyboard_layout::read_codepage_file(const char* codepage_file_name, Bit32s
 	if (tempfile==NULL) {
 		// check if build-in codepage is available
 		switch (codepage_id) {
-			case 437:	case 850:	case 852:	case 853:	case 857:	case 858:	
+			case 437:	case 850:	case 852:	case 853:	case 857:	case 858:
 						for (Bitu bct=0; bct<6322; bct++) cpi_buf[bct]=font_ega_cpx[bct];
 						cpi_buf_size=6322;
 						break;
@@ -777,7 +777,7 @@ Bitu keyboard_layout::read_codepage_file(const char* codepage_file_name, Bit32s
 						for (Bitu bct=0; bct<5720; bct++) cpi_buf[bct]=font_ega5_cpx[bct];
 						cpi_buf_size=5720;
 						break;
-			default: 
+			default:
 				return KEYB_INVALIDCPFILE;
 				break;
 		}
@@ -792,10 +792,10 @@ Bitu keyboard_layout::read_codepage_file(const char* codepage_file_name, Bit32s
 			return KEYB_INVALIDCPFILE;
 		}
 		// check if non-compressed cpi file
-		if ((cpi_buf[0]!=0xff) || (cpi_buf[1]!=0x46) || (cpi_buf[2]!=0x4f) || 
+		if ((cpi_buf[0]!=0xff) || (cpi_buf[1]!=0x46) || (cpi_buf[2]!=0x4f) ||
 			(cpi_buf[3]!=0x4e) || (cpi_buf[4]!=0x54)) {
 			// check if dr-dos custom cpi file
-			if ((cpi_buf[0]==0x7f) && (cpi_buf[1]!=0x44) && (cpi_buf[2]!=0x52) && 
+			if ((cpi_buf[0]==0x7f) && (cpi_buf[1]!=0x44) && (cpi_buf[2]!=0x52) &&
 				(cpi_buf[3]!=0x46) && (cpi_buf[4]!=0x5f)) {
 				LOG(LOG_BIOS,LOG_ERROR)("Codepage file %s has unsupported DR-DOS format",cp_filename);
 				return KEYB_INVALIDCPFILE;
@@ -878,11 +878,11 @@ Bitu keyboard_layout::read_codepage_file(const char* codepage_file_name, Bit32s
 
 
 	start_pos=host_readd(&cpi_buf[0x13]);
-	
+
 	//--Added 2011-06-20 by Alun Bestor as a sanity check, preventing crashes in the event that a codepage file cannot be parsed
 	if (start_pos > cpi_buf_size) return KEYB_INVALIDCPFILE;
 	//--End of modifications
-	
+
 	number_of_codepages=host_readw(&cpi_buf[start_pos]);
 	start_pos+=4;
 
@@ -1136,7 +1136,7 @@ bool boxer_keyboardLayoutSupported(const char *code)
     {
         //If the current layout supports the specified language code without switching anything, yippee
         if (loaded_layout->supports_language_code(code)) return true;
-    
+
         //If we can safely swap layouts without changing codepages, yippee too
         Bitu detectedCodepage = loaded_layout->extract_codepage(code);
         if (detectedCodepage == dos.loaded_codepage) return true;
@@ -1158,7 +1158,7 @@ void boxer_setKeyboardLayoutActive(bool active)
         //Force-disable US layouts,
         //to match how switch_keyboard_layout() behaves.
         if (loaded_layout->is_US_layout()) active = false;
-        
+
         if (boxer_keyboardLayoutActive() != active)
             loaded_layout->switch_foreign_layout();
     }
@@ -1174,7 +1174,7 @@ public:
 		loaded_layout=new keyboard_layout();
 
 		const char * layoutname=section->Get_string("keyboardlayout");
-        
+
 		Bits wants_dos_codepage = -1;
 		if (!strncmp(layoutname,"auto",4)) {
 #if defined (WIN32)
@@ -1320,15 +1320,15 @@ public:
 				default:
 					break;
 			}
-#endif
-            
+#else
             //--Added 2009-02-23 by Alun Bestor: if auto layout was specified, ask Boxer to provide a layout
             const char *preferredLayout = boxer_preferredKeyboardLayout();
             if (preferredLayout)
                 layoutname = preferredLayout;
             //--End of modifications
+#endif
 		}
-		
+
 		bool extract_codepage = true;
 		if (wants_dos_codepage>0) {
 			if ((loaded_layout->read_codepage_file("auto", (Bitu)wants_dos_codepage)) == KEYB_NOERROR) {
@@ -1341,7 +1341,7 @@ public:
 			Bitu req_codepage = loaded_layout->extract_codepage(layoutname);
 			loaded_layout->read_codepage_file("auto", req_codepage);
 		}
-        
+
 /*		if (strncmp(layoutname,"auto",4) && strncmp(layoutname,"none",4)) {
 			LOG_MSG("Loading DOS keyboard layout %s ...",layoutname);
 		} */
@@ -1355,7 +1355,7 @@ public:
 				LOG_MSG("DOS keyboard layout loaded with main language code %s for layout %s",lcode,layoutname);
 			}
 		}
-        
+
         //--Added 2012-05-21 by Alun Bestor to fix US-858 layout loading up with keyboard remapping enabled.
         if (loaded_layout->is_US_layout() && loaded_layout->foreign_layout_active())
         {
@@ -1379,7 +1379,7 @@ public:
 static DOS_KeyboardLayout* test;
 
 void DOS_KeyboardLayout_ShutDown(Section* /*sec*/) {
-	delete test;	
+	delete test;
 }
 
 void DOS_KeyboardLayout_Init(Section* sec) {
diff --git a/src/dos/drive_local.cpp b/src/dos/drive_local.cpp
index 9c14636f..bfe40876 100644
--- a/src/dos/drive_local.cpp
+++ b/src/dos/drive_local.cpp
@@ -31,25 +31,8 @@
 #include "cross.h"
 #include "inout.h"
 
-class localFile : public DOS_File {
-public:
-	localFile(const char* name, FILE * handle);
-	bool Read(Bit8u * data,Bit16u * size);
-	bool Write(Bit8u * data,Bit16u * size);
-	bool Seek(Bit32u * pos,Bit32u type);
-	bool Close();
-	Bit16u GetInformation(void);
-	bool UpdateDateTimeFromHost(void);   
-	void FlagReadOnlyMedium(void);
-    //--Added 2011-11-03 by Alun Bestor to let Boxer inform open file handles
-    //that their physical backing media will be removed.
-    void willBecomeUnavailable(void);
-    //--End of modifications
-private:
-	FILE * fhandle;
-	bool read_only_medium;
-	enum { NONE,READ,WRITE } last_action;
-};
+#include "drive_local_gboxer.h"
+#include "Coalface.h"
 
 
 bool localDrive::FileCreate(DOS_File * * file,const char * name,Bit16u /*attributes*/) {
@@ -61,7 +44,7 @@ bool localDrive::FileCreate(DOS_File * * file,const char * name,Bit16u /*attribu
 	char* temp_name = dirCache.GetExpandName(newname); //Can only be used in till a new drive_cache action is preformed */
 	/* Test if file exists (so we need to truncate it). don't add to dirCache then */
 	bool existing_file=false;
-	
+
 	//--Added 2010-01-18 by Alun Bestor to allow Boxer to selectively deny write access to files
 	if (!boxer_shouldAllowWriteAccessToPath((const char *)newname, this))
 	{
@@ -69,26 +52,26 @@ bool localDrive::FileCreate(DOS_File * * file,const char * name,Bit16u /*attribu
 		return false;
 	}
 	//--End of modifications
-	
-    //-- Modified 2012-07-24 by Alun Bestor to allow Boxer to shadow local file access
+
+  //-- Modified 2012-07-24 by Alun Bestor to allow Boxer to shadow local file access
 	//FILE * test=fopen(temp_name,"rb+");
-    FILE * test=boxer_openLocalFile(temp_name, this, "rb+");
-    //--End of modifications
+	ADB::VFILE *test = GBoxer::Coalface::open_local_file(temp_name, this, "rb+");
+  //--End of modifications
 	if(test) {
-		fclose(test);
+		// fclose(test);
+		GBoxer::Coalface::close_local_file(test);
 		existing_file=true;
-
 	}
-	
-    //-- Modified 2012-07-24 by Alun Bestor to allow Boxer to shadow local file access
+
+  //-- Modified 2012-07-24 by Alun Bestor to allow Boxer to shadow local file access
 	//FILE * hand=fopen(temp_name,"wb+");
-    FILE * hand=boxer_openLocalFile(temp_name, this, "wb+");
-    //--End of modifications
+	ADB::VFILE *hand = GBoxer::Coalface::open_local_file(temp_name, this, "wb+");
+  //--End of modifications
 	if (!hand){
 		LOG_MSG("Warning: file creation failed: %s",newname);
 		return false;
 	}
-   
+
 	if(!existing_file) {
 		strcpy(newname,basedir);
 		strcat(newname,name);
@@ -96,11 +79,19 @@ bool localDrive::FileCreate(DOS_File * * file,const char * name,Bit16u /*attribu
 		dirCache.AddEntry(newname, true);
 	}
 
+	/*
+	FileStat_Block statBlock;
+	bool gotStat = FileStat(name, &statBlock);
+	if (!gotStat) {
+		LOG_MSG("Warning: FileStat FAILED!!!");
+	}
+	*/
+
 	/* Make the 16 bit device information */
-	*file=new localFile(name,hand);
-	(*file)->flags=OPEN_READWRITE;
-	
-	
+	*file = new GBoxer::LocalFile(name, hand);
+	(*file)->flags = OPEN_READWRITE;
+
+
 	//--Added 2010-08-21 by Alun Bestor to let Boxer monitor DOSBox's file operations
 	boxer_didCreateLocalFile(temp_name, this);
 	//--End of modifications
@@ -135,51 +126,59 @@ bool localDrive::FileOpen(DOS_File * * file,const char * name,Bit32u flags) {
 			} else {
 				DOS_SetError(DOSERR_ACCESS_DENIED);
 				return false;
-			}			
+			}
 		}
 	}
 	//--End of modifications
-    
-    //-- Modified 2012-07-24 by Alun Bestor to allow Boxer to shadow local file access
+
+  //-- Modified 2012-07-24 by Alun Bestor to allow Boxer to shadow local file access
 	//FILE * hand=fopen(newname,type);
-    FILE * hand=boxer_openLocalFile(newname, this, type);
-    //--End of modifications
-    
-//	Bit32u err=errno;
-	if (!hand) { 
+	ADB::VFILE *hand = GBoxer::Coalface::open_local_file(newname, this, type);
+  //--End of modifications
+
+	// Bit32u err=errno;
+	if (!hand) {
 		if((flags&0xf) != OPEN_READ) {
-            
-            //-- Modified 2012-07-24 by Alun Bestor to allow Boxer to shadow local file access
-            //FILE * hmm=fopen(newname,"rb");
-            FILE * hmm=boxer_openLocalFile(newname, this, "rb");
-            //--End of modifications
-            
+
+			//-- Modified 2012-07-24 by Alun Bestor to allow Boxer to shadow local file access
+			//FILE * hmm=fopen(newname,"rb");
+			ADB::VFILE *hmm = GBoxer::Coalface::open_local_file(newname, this, "rb");
+			//--End of modifications
+
 			if (hmm) {
-				fclose(hmm);
+				// fclose(hmm);
+				GBoxer::Coalface::close_local_file(hmm);
 				LOG_MSG("Warning: file %s exists and failed to open in write mode.\nPlease Remove write-protection",newname);
 			}
 		}
 		return false;
 	}
 
-	*file=new localFile(name,hand);
-	(*file)->flags=flags;  //for the inheritance flag and maybe check for others.
+	/*
+	FileStat_Block statBlock;
+	bool gotStat = FileStat(name, &statBlock);
+	if (!gotStat) {
+		LOG_MSG("Warning: FileStat FAILED!!!");
+	}
+	*/
+
+	*file = new GBoxer::LocalFile(name, hand);
+	(*file)->flags = flags;  //for the inheritance flag and maybe check for others.
 //	(*file)->SetFileName(newname);
 	return true;
 }
 
 FILE * localDrive::GetSystemFilePtr(char const * const name, char const * const type) {
-
 	char newname[CROSS_LEN];
 	strcpy(newname,basedir);
 	strcat(newname,name);
 	CROSS_FILENAME(newname);
 	dirCache.ExpandName(newname);
-    
-    //-- Modified 2012-07-24 by Alun Bestor to allow Boxer to shadow local file access
-	//return fopen(newname,type);
-    return boxer_openLocalFile(newname, this, type);
-    //--End of modifications
+
+  //-- Modified 2012-07-24 by Alun Bestor to allow Boxer to shadow local file access
+	return fopen(newname, type);
+	// return GBoxer::Coalface::open_local_file(newname, this, type);
+  //--End of modifications
 }
 
 bool localDrive::GetSystemFilename(char *sysName, char const * const dosName) {
@@ -197,7 +196,7 @@ bool localDrive::FileUnlink(const char * name) {
 	strcat(newname,name);
 	CROSS_FILENAME(newname);
 	char *fullname = dirCache.GetExpandName(newname);
-	
+
 	//--Added 2010-12-29 by Alun Bestor to let Boxer selectively prevent file operations
 	if (!boxer_shouldAllowWriteAccessToPath((const char *)fullname, this))
 	{
@@ -205,20 +204,21 @@ bool localDrive::FileUnlink(const char * name) {
 		return false;
 	}
 	//--End of modifications
-	
-    //-- Modified 2012-07-24 by Alun Bestor to allow Boxer to shadow local file access
+
+  //-- Modified 2012-07-24 by Alun Bestor to allow Boxer to shadow local file access
 	//if (unlink(fullname)) {
-    if (!boxer_removeLocalFile(fullname, this)) {
+	if (!boxer_removeLocalFile(fullname, this)) {
 		//Unlink failed for some reason try finding it.
 		struct stat buffer;
-        //if(stat(fullname,&buffer)) return false; // File not found.
-        if (!boxer_getLocalPathStats(fullname, this, &buffer)) return false;
-		
+		//if(stat(fullname,&buffer)) return false; // File not found.
+		if (!boxer_getLocalPathStats(fullname, this, &buffer)) return false;
+
 		//FILE* file_writable = fopen(fullname,"rb+");
-        FILE* file_writable = boxer_openLocalFile(fullname, this, "rb+");
-        
+		ADB::VFILE *file_writable = GBoxer::Coalface::open_local_file(fullname, this, "rb+");
+
 		if(!file_writable) return false; //No acces ? ERROR MESSAGE NOT SET. FIXME ?
-		fclose(file_writable);
+		// fclose(file_writable);
+		GBoxer::Coalface::close_local_file(file_writable);
 
 		//File exists and can technically be deleted, nevertheless it failed.
 		//This means that the file is probably open by some process.
@@ -236,19 +236,19 @@ bool localDrive::FileUnlink(const char * name) {
 		}
 		if(!found_file) return false;
 		//if (!unlink(fullname)) {
-        if (boxer_removeLocalFile(fullname, this)) {
+		if (boxer_removeLocalFile(fullname, this)) {
 			dirCache.DeleteEntry(newname);
-			
+
 			//--Added 2010-08-21 by Alun Bestor to let Boxer monitor DOSBox's file operations
 			boxer_didRemoveLocalFile(fullname, this);
 			//--End of modifications
 			return true;
 		}
-		return false;        
-//--End of modifications
+		return false;
+	//--End of modifications
 	} else {
 		dirCache.DeleteEntry(newname);
-		
+
 		//--Added 2010-08-21 by Alun Bestor to let Boxer monitor DOSBox's file operations
 		boxer_didRemoveLocalFile(fullname, this);
 		//--End of modifications
@@ -265,10 +265,10 @@ bool localDrive::FindFirst(const char * _dir,DOS_DTA & dta,bool fcb_findfirst) {
 	if (allocation.mediaid==0xF0 ) {
 		EmptyCache(); //rescan floppie-content on each findfirst
 	}
-    
+
 	char end[2]={CROSS_FILESPLIT,0};
 	if (tempDir[strlen(tempDir)-1]!=CROSS_FILESPLIT) strcat(tempDir,end);
-	
+
 	Bit16u id;
 	if (!dirCache.FindFirst(tempDir,id)) {
 		DOS_SetError(DOSERR_PATH_NOT_FOUND);
@@ -276,7 +276,7 @@ bool localDrive::FindFirst(const char * _dir,DOS_DTA & dta,bool fcb_findfirst) {
 	}
 	strcpy(srchInfo[id].srch_dir,tempDir);
 	dta.SetDirID(id);
-	
+
 	Bit8u sAttr;
 	dta.GetSearchParams(sAttr,tempDir);
 
@@ -297,7 +297,7 @@ bool localDrive::FindFirst(const char * _dir,DOS_DTA & dta,bool fcb_findfirst) {
 			}
 			dta.SetResult(dirCache.GetLabel(),0,0,0,DOS_ATTR_VOLUME);
 			return true;
-		} else if ((sAttr & DOS_ATTR_VOLUME)  && (*_dir == 0) && !fcb_findfirst) { 
+		} else if ((sAttr & DOS_ATTR_VOLUME)  && (*_dir == 0) && !fcb_findfirst) {
 		//should check for a valid leading directory instead of 0
 		//exists==true if the volume label matches the searchmask and the path is valid
 			if (WildFileCmp(dirCache.GetLabel(),tempDir)) {
@@ -331,29 +331,29 @@ again:
 
 	strcpy(full_name,srchInfo[id].srch_dir);
 	strcat(full_name,dir_ent);
-	
-	//GetExpandName might indirectly destroy dir_ent (by caching in a new directory 
+
+	//GetExpandName might indirectly destroy dir_ent (by caching in a new directory
 	//and due to its design dir_ent might be lost.)
 	//Copying dir_ent first
 	strcpy(dir_entcopy,dir_ent);
     //Modified 2012-07-24 by Alun Bestor to wrap local file operations
-	//if (stat(dirCache.GetExpandName(full_name),&stat_block)!=0) { 
+	//if (stat(dirCache.GetExpandName(full_name),&stat_block)!=0) {
     if (!boxer_getLocalPathStats(dirCache.GetExpandName(full_name), this, &stat_block)) {
     //--End of modifications
 		goto again;//No symlinks and such
-	}	
+	}
 
 	if(stat_block.st_mode & S_IFDIR) find_attr=DOS_ATTR_DIRECTORY;
 	else find_attr=DOS_ATTR_ARCHIVE;
  	if (~srch_attr & find_attr & (DOS_ATTR_DIRECTORY | DOS_ATTR_HIDDEN | DOS_ATTR_SYSTEM)) goto again;
-	
+
 	/*file is okay, setup everything to be copied in DTA Block */
 	char find_name[DOS_NAMELENGTH_ASCII];Bit16u find_date,find_time;Bit32u find_size;
 
 	if(strlen(dir_entcopy)<DOS_NAMELENGTH_ASCII){
 		strcpy(find_name,dir_entcopy);
 		upcase(find_name);
-	} 
+	}
 
 	find_size=(Bit32u) stat_block.st_size;
 	struct tm *time;
@@ -361,7 +361,7 @@ again:
 		find_date=DOS_PackDate((Bit16u)(time->tm_year+1900),(Bit16u)(time->tm_mon+1),(Bit16u)time->tm_mday);
 		find_time=DOS_PackTime((Bit16u)time->tm_hour,(Bit16u)time->tm_min,(Bit16u)time->tm_sec);
 	} else {
-		find_time=6; 
+		find_time=6;
 		find_date=4;
 	}
 	dta.SetResult(find_name,find_size,find_date,find_time,find_attr);
@@ -376,9 +376,9 @@ bool localDrive::GetFileAttr(const char * name,Bit16u * attr) {
 	dirCache.ExpandName(newname);
 
 	struct stat status;
-    
+
     //Modified 2012-07-24 by Alun Bestor to wrap local file operations
-	//if (stat(newname,&status)==0) { 
+	//if (stat(newname,&status)==0) {
     if (boxer_getLocalPathStats(newname, this, &status)) {
     //--End of modifications
 		*attr=DOS_ATTR_ARCHIVE;
@@ -386,7 +386,7 @@ bool localDrive::GetFileAttr(const char * name,Bit16u * attr) {
 		return true;
 	}
 	*attr=0;
-	return false; 
+	return false;
 }
 
 bool localDrive::MakeDir(const char * dir) {
@@ -395,7 +395,7 @@ bool localDrive::MakeDir(const char * dir) {
 	strcat(newdir,dir);
 	CROSS_FILENAME(newdir);
 	char * fullname=dirCache.GetExpandName(newdir);
-	
+
 	//--Modified 2010-12-29 by Alun Bestor to allow Boxer to selectively prevent file operations,
 	//and to prevent DOSBox from creating folders with the wrong file permissions.
 	/*
@@ -405,7 +405,7 @@ bool localDrive::MakeDir(const char * dir) {
 	 int temp=mkdir(fullname,0700);
 	 #endif
 	 */
-	
+
 	if (!boxer_shouldAllowWriteAccessToPath((const char *)fullname, this))
 	{
 		DOS_SetError(DOSERR_ACCESS_DENIED);
@@ -415,12 +415,12 @@ bool localDrive::MakeDir(const char * dir) {
 	//int temp=mkdir(fullname, 0777);
 	//if (temp==0) dirCache.CacheOut(newdir,true);
 	//return (temp==0);// || ((temp!=0) && (errno==EEXIST));
-    
+
     bool created = boxer_createLocalDir(fullname, this);
     if (created) dirCache.CacheOut(newdir,true);
     return created;
 	//--End of modifications
-	
+
 }
 
 bool localDrive::RemoveDir(const char * dir) {
@@ -428,20 +428,20 @@ bool localDrive::RemoveDir(const char * dir) {
 	strcpy(newdir,basedir);
 	strcat(newdir,dir);
 	CROSS_FILENAME(newdir);
-	
+
 	//--Modified 2010-12-29 by Alun Bestor to allow Boxer to selectively prevent file operations
 	char *fullname = dirCache.GetExpandName(newdir);
-	
+
 	if (!boxer_shouldAllowWriteAccessToPath((const char *)fullname, this))
 	{
 		DOS_SetError(DOSERR_ACCESS_DENIED);
 		return false;
 	}
-	
+
 	//int temp=rmdir(fullname);
 	//if (temp==0) dirCache.DeleteEntry(newdir,true);
     //return (temp==0);
-    
+
     bool removed = boxer_removeLocalDir(fullname, this);
 	if (removed) dirCache.DeleteEntry(newdir,true);
     return removed;
@@ -454,7 +454,7 @@ bool localDrive::TestDir(const char * dir) {
 	strcat(newdir,dir);
 	CROSS_FILENAME(newdir);
 	dirCache.ExpandName(newdir);
-    
+
 	//--Modified 2012-04-27 by Alun Bestor to wrap local file operations
     /*
 	// Skip directory test, if "\"
@@ -478,13 +478,13 @@ bool localDrive::Rename(const char * oldname,const char * newname) {
 	strcat(newold,oldname);
 	CROSS_FILENAME(newold);
 	dirCache.ExpandName(newold);
-	
+
 	char newnew[CROSS_LEN];
 	strcpy(newnew,basedir);
 	strcat(newnew,newname);
 	CROSS_FILENAME(newnew);
 	char *fullname = dirCache.GetExpandName(newnew);
-	
+
 	//--Modified 2012-04-27 by Alun Bestor to wrap local file operations
 	if (!boxer_shouldAllowWriteAccessToPath((const char *)newold, this) ||
 		!boxer_shouldAllowWriteAccessToPath((const char *)fullname, this))
@@ -492,7 +492,7 @@ bool localDrive::Rename(const char * oldname,const char * newname) {
 		DOS_SetError(DOSERR_ACCESS_DENIED);
 		return false;
 	}
-	
+
 	//int temp=rename(newold,fullname);
     //if (temp==0) dirCache.CacheOut(newnew);
 	//return (temp==0);
@@ -519,14 +519,14 @@ bool localDrive::FileExists(const char* name) {
 	strcat(newname,name);
 	CROSS_FILENAME(newname);
 	dirCache.ExpandName(newname);
-    
+
 	//--Modified 2012-04-27 by Alun Bestor to wrap local file operations
 	//FILE* Temp=fopen(newname,"rb");
 	//if(Temp==NULL) return false;
 	//fclose(Temp);
 	//return true;
-    return boxer_localFileExists(newname, this);
-    //--End of modifications
+  return boxer_localFileExists(newname, this);
+  //--End of modifications
 }
 
 bool localDrive::FileStat(const char* name, FileStat_Block * const stat_block) {
@@ -536,12 +536,12 @@ bool localDrive::FileStat(const char* name, FileStat_Block * const stat_block) {
 	CROSS_FILENAME(newname);
 	dirCache.ExpandName(newname);
 	struct stat temp_stat;
-    
+
 	//--Modified 2012-04-27 by Alun Bestor to wrap local file operations
 	//if(stat(newname,&temp_stat)!=0) return false;
     if (!boxer_getLocalPathStats(newname, this, &temp_stat)) return false;
     //--End of modifications
-    
+
 	/* Convert the stat to a FileStat */
 	struct tm *time;
 	if((time=localtime(&temp_stat.st_mtime))!=0) {
@@ -567,31 +567,31 @@ bool localDrive::isRemovable(void) {
 	return false;
 }
 
-Bits localDrive::UnMount(void) { 
+Bits localDrive::UnMount(void) {
 	delete this;
-	return 0; 
+	return 0;
 }
 
 /* helper functions for drive cache */
 //--Modified 2012-07-25 by Alun Bestor to wrap local filesystem access
 void *localDrive::opendir(const char *name) {
-	//return open_directory(name);
-    return boxer_openLocalDirectory(name, this);
+	// return open_directory(name);
+	return boxer_openLocalDirectory(name, this);
 }
 
 void localDrive::closedir(void *handle) {
-	//close_directory((dir_information*)handle);
-    boxer_closeLocalDirectory(handle);
+	// close_directory((dir_information*)handle);
+	boxer_closeLocalDirectory(handle);
 }
 
 bool localDrive::read_directory_first(void *handle, char* entry_name, bool& is_directory) {
-	//return ::read_directory_first((dir_information*)handle, entry_name, is_directory);
-    return boxer_getNextDirectoryEntry(handle, entry_name, is_directory);
+	// return ::read_directory_first((dir_information*)handle, entry_name, is_directory);
+	return boxer_getNextDirectoryEntry(handle, entry_name, is_directory);
 }
 
 bool localDrive::read_directory_next(void *handle, char* entry_name, bool& is_directory) {
-	//return ::read_directory_next((dir_information*)handle, entry_name, is_directory);
-    return boxer_getNextDirectoryEntry(handle, entry_name, is_directory);
+	// return ::read_directory_next((dir_information*)handle, entry_name, is_directory);
+	return boxer_getNextDirectoryEntry(handle, entry_name, is_directory);
 }
 //--End of modifications
 
@@ -603,181 +603,13 @@ localDrive::localDrive(const char * startdir,Bit16u _bytes_sector,Bit8u _sectors
 	allocation.total_clusters=_total_clusters;
 	allocation.free_clusters=_free_clusters;
 	allocation.mediaid=_mediaid;
-	
+
 	//--Added 2009-10-25 by Alun Bestor to allow Boxer to track the system path for DOSBox drives
 	strcpy(systempath, startdir);
 	//--End of modifications
-	
-	dirCache.SetBaseDir(basedir,this);
-}
-
 
-//TODO Maybe use fflush, but that seemed to fuck up in visual c
-bool localFile::Read(Bit8u * data,Bit16u * size) {
-	if ((this->flags & 0xf) == OPEN_WRITE) {	// check if file opened in write-only mode
-		DOS_SetError(DOSERR_ACCESS_DENIED);
-		return false;
-	}
-    
-    //--Added 2011-11-03 by Alun Bestor to avoid errors on files
-    //whose backing media has disappeared
-    if (!fhandle)
-    {
-        *size = 0;
-        //IMPLEMENTATION NOTE: you might think we ought to return false here,
-        //but no! We return true to be consistent with DOSBox's behaviour,
-        //which appears to be the behaviour expected by DOS.
-        return true;
-    }
-    //--End of modifications
-    
-	if (last_action==WRITE) fseek(fhandle,ftell(fhandle),SEEK_SET);
-	last_action=READ;
-	*size=(Bit16u)fread(data,1,*size,fhandle);
-	/* Fake harddrive motion. Inspector Gadget with soundblaster compatible */
-	/* Same for Igor */
-	/* hardrive motion => unmask irq 2. Only do it when it's masked as unmasking is realitively heavy to emulate */
-	Bit8u mask = IO_Read(0x21);
-	if(mask & 0x4 ) IO_Write(0x21,mask&0xfb);
-	return true;
-}
-
-bool localFile::Write(Bit8u * data,Bit16u * size) {
-	if ((this->flags & 0xf) == OPEN_READ) {	// check if file opened in read-only mode
-		DOS_SetError(DOSERR_ACCESS_DENIED);
-		return false;
-	}
-    
-    //--Added 2011-11-03 by Alun Bestor to avoid errors on files
-    //whose backing media has disappeared
-    if (!fhandle)
-    {
-        *size = 0;
-        //IMPLEMENTATION NOTE: you might think we ought to return false here,
-        //but no! We return true to be consistent with DOSBox's behaviour,
-        //which appears to be the behaviour expected by DOS.
-        return true;
-    }
-    //--End of modifications
-    
-	if (last_action==READ) fseek(fhandle,ftell(fhandle),SEEK_SET);
-	last_action=WRITE;
-	if(*size==0){  
-        return (!ftruncate(fileno(fhandle),ftell(fhandle)));
-    }
-    else 
-    {
-		*size=(Bit16u)fwrite(data,1,*size,fhandle);
-		return true;
-    }
-}
-
-bool localFile::Seek(Bit32u * pos,Bit32u type) {
-	int seektype;
-    
-	switch (type) {
-	case DOS_SEEK_SET:seektype=SEEK_SET;break;
-	case DOS_SEEK_CUR:seektype=SEEK_CUR;break;
-	case DOS_SEEK_END:seektype=SEEK_END;break;
-	default:
-	//TODO Give some doserrorcode;
-		return false;//ERROR
-	}
-    
-    //--Added 2011-11-03 by Alun Bestor to avoid errors on files
-    //whose backing media has disappeared
-    if (!fhandle)
-    {
-        *pos = 0;
-        //IMPLEMENTATION NOTE: you might think we ought to return false here,
-        //but no! We return true to be consistent with DOSBox's behaviour,
-        //which appears to be the behaviour expected by DOS.
-        return true;
-    }
-    //--End of modifications
-    
-	int ret=fseek(fhandle,*reinterpret_cast<Bit32s*>(pos),seektype);
-	if (ret!=0) {
-		// Out of file range, pretend everythings ok 
-		// and move file pointer top end of file... ?! (Black Thorne)
-		fseek(fhandle,0,SEEK_END);
-	};
-#if 0
-	fpos_t temppos;
-	fgetpos(fhandle,&temppos);
-	Bit32u * fake_pos=(Bit32u*)&temppos;
-	*pos=*fake_pos;
-#endif
-	*pos=(Bit32u)ftell(fhandle);
-	last_action=NONE;
-	return true;
-}
-
-bool localFile::Close() {
-	// only close if one reference left
-	if (refCtr==1) {
-		if(fhandle) fclose(fhandle);
-		fhandle = 0;
-		open = false;
-	};
-	return true;
-}
-
-Bit16u localFile::GetInformation(void) {
-	return read_only_medium?0x40:0;
-}
-	
-
-localFile::localFile(const char* _name, FILE * handle) {
-	fhandle=handle;
-	open=true;
-	UpdateDateTimeFromHost();
-
-	attr=DOS_ATTR_ARCHIVE;
-	last_action=NONE;
-	read_only_medium=false;
-
-	name=0;
-	SetName(_name);
-}
-
-void localFile::FlagReadOnlyMedium(void) {
-	read_only_medium = true;
-}
-
-bool localFile::UpdateDateTimeFromHost(void) {
-	if(!open) return false;
-    
-    //--Added 2011-11-03 by Alun Bestor to avoid errors on closed files
-    if (!fhandle) return false;
-    //--End of modifications
-    
-	struct stat temp_stat;
-	fstat(fileno(fhandle),&temp_stat);
-	struct tm * ltime;
-	if((ltime=localtime(&temp_stat.st_mtime))!=0) {
-		time=DOS_PackTime((Bit16u)ltime->tm_hour,(Bit16u)ltime->tm_min,(Bit16u)ltime->tm_sec);
-		date=DOS_PackDate((Bit16u)(ltime->tm_year+1900),(Bit16u)(ltime->tm_mon+1),(Bit16u)ltime->tm_mday);
-	} else {
-		time=1;date=1;
-	}
-	return true;
-}
-
-//--Added 2011-11-03 by Alun Bestor to let Boxer inform open file handles
-//that their physical backing media will be removed.
-void localFile::willBecomeUnavailable()
-{
-    //If the real file is about to become unavailable, then close
-    //our file handle but leave the DOS file flagged as 'open'.
-    if (fhandle)
-    {
-		fclose(fhandle);
-		fhandle = 0;
-    }
+	dirCache.SetBaseDir(basedir,this);
 }
-//--End of modification
-
 
 
 // ********************************************
@@ -810,7 +642,7 @@ bool cdromDrive::FileOpen(DOS_File * * file,const char * name,Bit32u flags) {
 		return false;
 	}
 	bool retcode = localDrive::FileOpen(file,name,flags);
-	if(retcode) (dynamic_cast<localFile*>(*file))->FlagReadOnlyMedium();
+	if(retcode) (dynamic_cast<GBoxer::LocalFile*>(*file))->FlagReadOnlyMedium();
 	return retcode;
 }
 
diff --git a/src/dos/drive_local_gboxer.cpp b/src/dos/drive_local_gboxer.cpp
new file mode 100644
index 00000000..4c221b65
--- /dev/null
+++ b/src/dos/drive_local_gboxer.cpp
@@ -0,0 +1,177 @@
+#include "drive_local_gboxer.h"
+
+#include "dos_inc.h"
+#include "inout.h"
+
+#include "Coalface.h"
+#include <glib.h>
+
+
+using GBoxer::LocalFile;
+
+LocalFile::LocalFile(const char *filename, ADB::VFILE *handle)
+    : m_fhandle           {handle},
+      m_read_only_medium  {false}
+{
+	attr = DOS_ATTR_ARCHIVE;
+	open = true;
+	name = 0;
+
+	// UpdateDateTimeFromHost();
+	SetName(filename);
+}
+
+LocalFile::~LocalFile()
+{
+  // g_message("//////////////////////// LocalFile::~LocalFile()");
+}
+
+// TODO Maybe use fflush, but that seemed to fuck up in visual c
+bool LocalFile::Read(Bit8u *data, Bit16u *size)
+{
+  // Check if file opened in write-only mode
+	if ((this->flags & 0xf) == OPEN_WRITE) {
+		DOS_SetError(DOSERR_ACCESS_DENIED);
+		return false;
+	}
+
+  // --Added 2011-11-03 by Alun Bestor to avoid errors on files
+  // whose backing media has disappeared
+  if (!m_fhandle) {
+    *size = 0;
+    // IMPLEMENTATION NOTE: you might think we ought to return false here,
+    // but no! We return true to be consistent with DOSBox's behaviour,
+    // which appears to be the behaviour expected by DOS.
+    return true;
+  }
+  // --End of modifications
+
+  *size = (Bit16u)Coalface::read_local_file(data, *size, m_fhandle);
+
+	/* Fake harddrive motion. Inspector Gadget with soundblaster compatible */
+	/* Same for Igor */
+	/* hardrive motion => unmask irq 2. Only do it when it's masked as unmasking is realitively heavy to emulate */
+	Bit8u mask = IO_Read(0x21);
+	if (mask & 0x4 ) IO_Write(0x21, mask & 0xfb);
+	return true;
+}
+
+bool LocalFile::Write(Bit8u *data, Bit16u *size)
+{
+  // Check if file opened in read-only mode
+	if ((this->flags & 0xf) == OPEN_READ) {
+		DOS_SetError(DOSERR_ACCESS_DENIED);
+		return false;
+	}
+
+  // --Added 2011-11-03 by Alun Bestor to avoid errors on files
+  // whose backing media has disappeared
+  if (!m_fhandle) {
+    *size = 0;
+    // IMPLEMENTATION NOTE: you might think we ought to return false here,
+    // but no! We return true to be consistent with DOSBox's behaviour,
+    // which appears to be the behaviour expected by DOS.
+    return true;
+  }
+  // --End of modifications
+
+  *size = (Bit16u)Coalface::write_local_file(data, *size, m_fhandle);
+
+  return true;
+}
+
+bool LocalFile::Seek(Bit32u *pos, Bit32u type)
+{
+	int seektype;
+	switch (type) {
+    case DOS_SEEK_SET: seektype = SEEK_SET; break;
+    case DOS_SEEK_CUR: seektype = SEEK_CUR; break;
+    case DOS_SEEK_END: seektype = SEEK_END; break;
+    default:
+      // TODO Give some doserrorcode;
+		  return false; // ERROR
+	}
+
+  // --Added 2011-11-03 by Alun Bestor to avoid errors on files
+  // whose backing media has disappeared
+  if (!m_fhandle) {
+    *pos = 0;
+    // IMPLEMENTATION NOTE: you might think we ought to return false here,
+    // but no! We return true to be consistent with DOSBox's behaviour,
+    // which appears to be the behaviour expected by DOS.
+    return true;
+  }
+  // --End of modifications
+
+  bool success = Coalface::seek_local_file(m_fhandle, *reinterpret_cast<Bit32s*>(pos), seektype);
+  if (!success) {
+		// Out of file range, pretend everythings ok
+		// and move file pointer top end of file... ?! (Black Thorne)
+		Coalface::seek_local_file(m_fhandle, 0, SEEK_END);
+  }
+
+	*pos = (Bit32u)Coalface::tell_local_file(m_fhandle);
+
+	return true;
+}
+
+bool LocalFile::Close()
+{
+	// Only close if one reference left
+	if (refCtr == 1) {
+    if (m_fhandle) {
+      Coalface::close_local_file(m_fhandle);
+      m_fhandle = nullptr;
+    }
+		open = false;
+	}
+	return true;
+}
+
+Bit16u LocalFile::GetInformation(void)
+{
+	return m_read_only_medium ? 0x40 : 0;
+}
+
+bool LocalFile::UpdateDateTimeFromHost(void)
+{
+	if (!open) return false;
+
+  // --Added 2011-11-03 by Alun Bestor to avoid errors on closed files
+  if (!m_fhandle) return false;
+  // --End of modifications
+
+	struct stat temp_stat;
+
+  // TODO: Better use 'boxer_getLocalPathStats' maybe?
+  if (!Coalface::stat_local_file(m_fhandle, &temp_stat)) {
+    // Just return true if our backend doesn't support fstat
+    return true;
+  }
+
+	struct tm * ltime;
+	if ((ltime = localtime(&temp_stat.st_mtime)) != 0) {
+		time = DOS_PackTime((Bit16u)ltime->tm_hour, (Bit16u)ltime->tm_min, (Bit16u)ltime->tm_sec);
+		date = DOS_PackDate((Bit16u)(ltime->tm_year + 1900), (Bit16u)(ltime->tm_mon + 1), (Bit16u)ltime->tm_mday);
+	} else {
+		time = 1;
+    date = 1;
+	}
+
+	return true;
+}
+
+void LocalFile::FlagReadOnlyMedium(void)
+{
+	m_read_only_medium = true;
+}
+
+void LocalFile::willBecomeUnavailable()
+{
+  // If the real file is about to become unavailable, then close
+  // our file handle but leave the DOS file flagged as 'open'.
+  if (m_fhandle) {
+    Coalface::close_local_file(m_fhandle);
+    m_fhandle = nullptr;
+  }
+}
diff --git a/src/dos/drive_local_gboxer.h b/src/dos/drive_local_gboxer.h
new file mode 100644
index 00000000..fd6be722
--- /dev/null
+++ b/src/dos/drive_local_gboxer.h
@@ -0,0 +1,51 @@
+#pragma once
+
+/*
+#include <stdio.h>
+// #include <cstdio>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <errno.h>
+
+#include "dosbox.h"
+#include "dos_inc.h"
+#include "drives.h"
+#include "support.h"
+#include "cross.h"
+#include "inout.h"
+*/
+#include "dos_system.h"
+
+
+namespace ADB {
+struct VFILE;
+}
+
+namespace GBoxer
+{
+
+class LocalFile : public DOS_File {
+public:
+	LocalFile(const char *filename, ADB::VFILE *handle);
+	~LocalFile();
+
+	bool Read(Bit8u *data, Bit16u *size) override;
+	bool Write(Bit8u *data, Bit16u *size) override;
+	bool Seek(Bit32u *pos, Bit32u type) override;
+	bool Close() override;
+	Bit16u GetInformation(void) override;
+	bool UpdateDateTimeFromHost(void) override;
+	void FlagReadOnlyMedium(void);
+
+	// --Added 2011-11-03 by Alun Bestor to let Boxer inform open file handles
+	// that their physical backing media will be removed.
+	void willBecomeUnavailable(void) override;
+	// --End of modifications
+
+private:
+	ADB::VFILE*		m_fhandle;
+	bool        	m_read_only_medium;
+};
+
+} // namespace GBoxer
diff --git a/src/fpu/fpu_instructions_x86.h b/src/fpu/fpu_instructions_x86.h
index 53a9a3c8..29d383a9 100644
--- a/src/fpu/fpu_instructions_x86.h
+++ b/src/fpu/fpu_instructions_x86.h
@@ -1,1489 +1,1359 @@
-/*
- *  Copyright (C) 2002-2010  The DOSBox Team
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-/* $Id: fpu_instructions_x86.h,v 1.7 2009-05-27 09:15:41 qbix79 Exp $ */
-
-
-// #define WEAK_EXCEPTIONS
-
-
-#if defined (_MSC_VER)
-
-#ifdef WEAK_EXCEPTIONS
-#define clx
-#else
-#define clx fclex
-#endif
-
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_LOAD(op,szI,szA)			\
-		__asm {							\
-		__asm	mov		ebx, store_to	\
-		__asm	shl		ebx, 4			\
-		__asm	op		szI PTR fpu.p_regs[128].m1		\
-		__asm	fstp	TBYTE PTR fpu.p_regs[ebx].m1	\
-		}
-#else
-#define FPUD_LOAD(op,szI,szA)			\
-		Bit16u new_sw;					\
-		__asm {							\
-		__asm	mov		eax, 8			\
-		__asm	shl		eax, 4			\
-		__asm	mov		ebx, store_to	\
-		__asm	shl		ebx, 4			\
-		__asm	fclex					\
-		__asm	op		szI PTR fpu.p_regs[eax].m1		\
-		__asm	fnstsw	new_sw			\
-		__asm	fstp	TBYTE PTR fpu.p_regs[ebx].m1	\
-		}								\
-		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);
-#endif
-
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_LOAD_EA(op,szI,szA)		\
-		__asm {							\
-		__asm	op		szI PTR fpu.p_regs[128].m1		\
-		}
-#else
-#define FPUD_LOAD_EA(op,szI,szA)		\
-		Bit16u new_sw;					\
-		__asm {							\
-		__asm	mov		eax, 8			\
-		__asm	shl		eax, 4			\
-		__asm	fclex					\
-		__asm	op		szI PTR fpu.p_regs[eax].m1		\
-		__asm	fnstsw	new_sw			\
-		}								\
-		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);
-#endif
-
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_STORE(op,szI,szA)				\
-		Bit16u save_cw;						\
-		__asm {								\
-		__asm	fnstcw	save_cw				\
-		__asm	mov		eax, TOP			\
-		__asm	fldcw	fpu.cw_mask_all		\
-		__asm	shl		eax, 4				\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	op		szI PTR fpu.p_regs[128].m1		\
-		__asm	fldcw	save_cw				\
-		}
-#else
-#define FPUD_STORE(op,szI,szA)				\
-		Bit16u new_sw,save_cw;				\
-		__asm {								\
-		__asm	fnstcw	save_cw				\
-		__asm	fldcw	fpu.cw_mask_all		\
-		__asm	mov		eax, TOP			\
-		__asm	shl		eax, 4				\
-		__asm	mov		ebx, 8				\
-		__asm	shl		ebx, 4				\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	clx							\
-		__asm	op		szI PTR fpu.p_regs[ebx].m1		\
-		__asm	fnstsw	new_sw				\
-		__asm	fldcw	save_cw				\
-		}									\
-		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
-#endif
-
-// handles fsin,fcos,f2xm1,fchs,fabs
-#define FPUD_TRIG(op)				\
-		Bit16u new_sw;				\
-		__asm {						\
-		__asm	mov		eax, TOP	\
-		__asm	shl		eax, 4		\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	clx					\
-		__asm	op					\
-		__asm	fnstsw	new_sw		\
-		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	\
-		}							\
-		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
-
-// handles fsincos
-#define FPUD_SINCOS()				\
-		Bit16u new_sw;					\
-		__asm {							\
-		__asm	mov		eax, TOP		\
-		__asm	mov		ebx, eax		\
-		__asm	dec     ebx				\
-		__asm	and     ebx, 7			\
-		__asm	shl		eax, 4			\
-		__asm	shl		ebx, 4			\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	clx						\
-		__asm	fsincos					\
-		__asm	fnstsw	new_sw			\
-		__asm	mov		cx, new_sw		\
-		__asm	and		ch, 0x04 		\
-		__asm	jnz		argument_too_large1				\
-		__asm	fstp	TBYTE PTR fpu.p_regs[ebx].m1	\
-		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	jmp		end_sincos		\
-		__asm	argument_too_large1:	\
-		__asm	fstp	st(0)			\
-		__asm	end_sincos:				\
-		}												\
-		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);		\
-		if ((new_sw&0x0400)==0) FPU_PREP_PUSH();
-
-// handles fptan
-#define FPUD_PTAN()					\
-		Bit16u new_sw;					\
-		__asm {							\
-		__asm	mov		eax, TOP		\
-		__asm	mov		ebx, eax		\
-		__asm	dec     ebx				\
-		__asm	and     ebx, 7			\
-		__asm	shl		eax, 4			\
-		__asm	shl		ebx, 4			\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	clx					\
-		__asm	fptan					\
-		__asm	fnstsw	new_sw			\
-		__asm	mov		cx, new_sw		\
-		__asm	and		ch, 0x04 		\
-		__asm	jnz		argument_too_large2				\
-		__asm	fstp	TBYTE PTR fpu.p_regs[ebx].m1	\
-		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	jmp		end_ptan		\
-		__asm	argument_too_large2:	\
-		__asm	fstp	st(0)			\
-		__asm	end_ptan:				\
-		}												\
-		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);		\
-		if ((new_sw&0x0400)==0) FPU_PREP_PUSH();
-
-// handles fxtract
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_XTRACT						\
-		__asm {							\
-		__asm	mov		eax, TOP		\
-		__asm	mov		ebx, eax		\
-		__asm	dec     ebx				\
-		__asm	and     ebx, 7			\
-		__asm	shl		eax, 4			\
-		__asm	shl		ebx, 4			\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	fxtract					\
-		__asm	fstp	TBYTE PTR fpu.p_regs[ebx].m1	\
-		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	\
-		}												\
-		FPU_PREP_PUSH();
-#else
-#define FPUD_XTRACT						\
-		Bit16u new_sw;					\
-		__asm {							\
-		__asm	mov		eax, TOP		\
-		__asm	mov		ebx, eax		\
-		__asm	dec     ebx				\
-		__asm	and     ebx, 7			\
-		__asm	shl		eax, 4			\
-		__asm	shl		ebx, 4			\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	fclex					\
-		__asm	fxtract					\
-		__asm	fnstsw	new_sw			\
-		__asm	fstp	TBYTE PTR fpu.p_regs[ebx].m1	\
-		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	\
-		}												\
-		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);			\
-		FPU_PREP_PUSH();
-#endif
-
-// handles fadd,fmul,fsub,fsubr
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_ARITH1(op)						\
-		Bit16u save_cw;						\
-		__asm {								\
-		__asm	fnstcw	save_cw				\
-		__asm	mov		eax, op1			\
-		__asm	shl		eax, 4				\
-		__asm	fldcw	fpu.cw_mask_all		\
-		__asm	mov		ebx, op2			\
-		__asm	shl		ebx, 4				\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	fld		TBYTE PTR fpu.p_regs[ebx].m1	\
-		__asm	op		st(1), st(0)		\
-		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	 \
-		__asm	fldcw	save_cw				\
-		}
-#else
-#define FPUD_ARITH1(op)						\
-		Bit16u new_sw,save_cw;				\
-		__asm {								\
-		__asm	fnstcw	save_cw				\
-		__asm	fldcw	fpu.cw_mask_all		\
-		__asm	mov		eax, op1			\
-		__asm	shl		eax, 4				\
-		__asm	mov		ebx, op2			\
-		__asm	shl		ebx, 4				\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	fld		TBYTE PTR fpu.p_regs[ebx].m1	\
-		__asm	clx							\
-		__asm	op		st(1), st(0)		\
-		__asm	fnstsw	new_sw				\
-		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	 \
-		__asm	fldcw	save_cw				\
-		}									\
-		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
-#endif
-
-// handles fadd,fmul,fsub,fsubr
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_ARITH1_EA(op)					\
-		Bit16u save_cw;						\
-		__asm {								\
-		__asm	fnstcw	save_cw				\
-		__asm	mov		eax, op1			\
-		__asm	fldcw	fpu.cw_mask_all		\
-		__asm	shl		eax, 4				\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	fxch	\
-		__asm	op		st(1), st(0)		\
-		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	 \
-		__asm	fldcw	save_cw				\
-		}
-#else
-#define FPUD_ARITH1_EA(op)					\
-		Bit16u new_sw,save_cw;				\
-		__asm {								\
-		__asm	fnstcw	save_cw				\
-		__asm	fldcw	fpu.cw_mask_all		\
-		__asm	mov		eax, op1			\
-		__asm	shl		eax, 4				\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	fxch	\
-		__asm	clx							\
-		__asm	op		st(1), st(0)		\
-		__asm	fnstsw	new_sw				\
-		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	 \
-		__asm	fldcw	save_cw				\
-		}									\
-		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
-#endif
-
-// handles fsqrt,frndint
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_ARITH2(op)						\
-		Bit16u save_cw;						\
-		__asm {								\
-		__asm	fnstcw	save_cw				\
-		__asm	mov		eax, TOP			\
-		__asm	fldcw	fpu.cw_mask_all		\
-		__asm	shl		eax, 4				\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	op							\
-		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	 \
-		__asm	fldcw	save_cw				\
-		}
-#else
-#define FPUD_ARITH2(op)						\
-		Bit16u new_sw,save_cw;				\
-		__asm {								\
-		__asm	fnstcw	save_cw				\
-		__asm	fldcw	fpu.cw_mask_all		\
-		__asm	mov		eax, TOP			\
-		__asm	shl		eax, 4				\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	clx							\
-		__asm	op							\
-		__asm	fnstsw	new_sw				\
-		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	 \
-		__asm	fldcw	save_cw				\
-		}									\
-		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
-#endif
-
-// handles fdiv,fdivr
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_ARITH3(op)						\
-		Bit16u save_cw;						\
-		__asm {								\
-		__asm	fnstcw	save_cw				\
-		__asm	mov		eax, op1			\
-		__asm	shl		eax, 4				\
-		__asm	fldcw	fpu.cw_mask_all		\
-		__asm	mov		ebx, op2			\
-		__asm	shl		ebx, 4				\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	fld		TBYTE PTR fpu.p_regs[ebx].m1	\
-		__asm	op		st(1), st(0)		\
-		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	 \
-		__asm	fldcw	save_cw				\
-		}
-#else
-#define FPUD_ARITH3(op)						\
-		Bit16u new_sw,save_cw;				\
-		__asm {								\
-		__asm	fnstcw	save_cw				\
-		__asm	fldcw	fpu.cw_mask_all		\
-		__asm	mov		eax, op1			\
-		__asm	shl		eax, 4				\
-		__asm	mov		ebx, op2			\
-		__asm	shl		ebx, 4				\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	fld		TBYTE PTR fpu.p_regs[ebx].m1	\
-		__asm	fclex						\
-		__asm	op		st(1), st(0)		\
-		__asm	fnstsw	new_sw				\
-		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	 \
-		__asm	fldcw	save_cw				\
-		}									\
-		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);
-#endif
-
-// handles fdiv,fdivr
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_ARITH3_EA(op)					\
-		Bit16u save_cw;						\
-		__asm {								\
-		__asm	fnstcw	save_cw				\
-		__asm	mov		eax, op1			\
-		__asm	fldcw	fpu.cw_mask_all		\
-		__asm	shl		eax, 4				\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	fxch	\
-		__asm	op		st(1), st(0)		\
-		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	 \
-		__asm	fldcw	save_cw				\
-		}
-#else
-#define FPUD_ARITH3_EA(op)					\
-		Bit16u new_sw,save_cw;				\
-		__asm {								\
-		__asm	fnstcw	save_cw				\
-		__asm	mov		eax, op1			\
-		__asm	fldcw	fpu.cw_mask_all		\
-		__asm	shl		eax, 4				\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	fxch	\
-		__asm	fclex						\
-		__asm	op		st(1), st(0)		\
-		__asm	fnstsw	new_sw				\
-		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	 \
-		__asm	fldcw	save_cw				\
-		}									\
-		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);
-#endif
-
-// handles fprem,fprem1,fscale
-#define FPUD_REMINDER(op)			\
-		Bit16u new_sw;				\
-		__asm {						\
-		__asm	mov		eax, TOP	\
-		__asm	mov		ebx, eax	\
-		__asm	inc     ebx			\
-		__asm	and     ebx, 7		\
-		__asm	shl		ebx, 4		\
-		__asm	shl		eax, 4		\
-		__asm	fld		TBYTE PTR fpu.p_regs[ebx].m1	\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	fclex				\
-		__asm	op					\
-		__asm	fnstsw	new_sw		\
-		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	fstp	st(0)		\
-		}							\
-		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);
-
-// handles fcom,fucom
-#define FPUD_COMPARE(op)			\
-		Bit16u new_sw;				\
-		__asm {						\
-		__asm	mov		ebx, op2	\
-		__asm	mov		eax, op1	\
-		__asm	shl		ebx, 4		\
-		__asm	shl		eax, 4		\
-		__asm	fld		TBYTE PTR fpu.p_regs[ebx].m1	\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	clx					\
-		__asm	op					\
-		__asm	fnstsw	new_sw		\
-		}							\
-		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
-
-#define FPUD_COMPARE_EA(op)			\
-		Bit16u new_sw;				\
-		__asm {						\
-		__asm	mov		eax, op1	\
-		__asm	shl		eax, 4		\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	clx					\
-		__asm	op					\
-		__asm	fnstsw	new_sw		\
-		}							\
-		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
-
-// handles fxam,ftst
-#define FPUD_EXAMINE(op)			\
-		Bit16u new_sw;				\
-		__asm {						\
-		__asm	mov		eax, TOP	\
-		__asm	shl		eax, 4		\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	clx					\
-		__asm	op					\
-		__asm	fnstsw	new_sw		\
-		__asm	fstp	st(0)		\
-		}							\
-		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
-
-// handles fpatan,fyl2xp1
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_WITH_POP(op)			\
-		__asm {						\
-		__asm	mov		eax, TOP	\
-		__asm	mov		ebx, eax	\
-		__asm	inc     ebx			\
-		__asm	and     ebx, 7		\
-		__asm	shl		ebx, 4		\
-		__asm	shl		eax, 4		\
-		__asm	fld		TBYTE PTR fpu.p_regs[ebx].m1	\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	op					\
-		__asm	fstp	TBYTE PTR fpu.p_regs[ebx].m1	\
-		}							\
-		FPU_FPOP();
-#else
-#define FPUD_WITH_POP(op)			\
-		Bit16u new_sw;				\
-		__asm {						\
-		__asm	mov		eax, TOP	\
-		__asm	mov		ebx, eax	\
-		__asm	inc     ebx			\
-		__asm	and     ebx, 7		\
-		__asm	shl		ebx, 4		\
-		__asm	shl		eax, 4		\
-		__asm	fld		TBYTE PTR fpu.p_regs[ebx].m1	\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	fclex				\
-		__asm	op					\
-		__asm	fnstsw	new_sw		\
-		__asm	fstp	TBYTE PTR fpu.p_regs[ebx].m1	\
-		}								\
-		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);	\
-		FPU_FPOP();
-#endif
-
-// handles fyl2x
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_FYL2X(op)				\
-		__asm {						\
-		__asm	mov		eax, TOP	\
-		__asm	mov		ebx, eax	\
-		__asm	inc     ebx			\
-		__asm	and     ebx, 7		\
-		__asm	shl		ebx, 4		\
-		__asm	shl		eax, 4		\
-		__asm	fld		TBYTE PTR fpu.p_regs[ebx].m1	\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	op					\
-		__asm	fstp	TBYTE PTR fpu.p_regs[ebx].m1	\
-		}								\
-		FPU_FPOP();
-#else
-#define FPUD_FYL2X(op)				\
-		Bit16u new_sw;				\
-		__asm {						\
-		__asm	mov		eax, TOP	\
-		__asm	mov		ebx, eax	\
-		__asm	inc     ebx			\
-		__asm	and     ebx, 7		\
-		__asm	shl		ebx, 4		\
-		__asm	shl		eax, 4		\
-		__asm	fld		TBYTE PTR fpu.p_regs[ebx].m1	\
-		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
-		__asm	fclex				\
-		__asm	op					\
-		__asm	fnstsw	new_sw		\
-		__asm	fstp	TBYTE PTR fpu.p_regs[ebx].m1	\
-		}								\
-		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);	\
-		FPU_FPOP();
-#endif
-
-// load math constants
-#define FPUD_LOAD_CONST(op)		\
-		FPU_PREP_PUSH();			\
-		__asm {						\
-		__asm	mov		eax, TOP	\
-		__asm	shl		eax, 4		\
-		__asm	clx					\
-		__asm	op					\
-		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	\
-		}							\
-
-#else
-
-#ifdef WEAK_EXCEPTIONS
-#define clx
-#else
-#define clx "fclex"
-#endif
-
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_LOAD(op,szI,szA)				\
-		__asm__ volatile (					\
-			"movl		$128, %%eax		\n"	\
-			"shl		$4, %0			\n"	\
-			#op #szA "	(%1, %%eax)		\n"	\
-			"fstpt		(%1, %0)		"	\
-			:								\
-			:	"r" (store_to), "r" (fpu.p_regs)	\
-			:	"eax", "memory"						\
-		);
-#else
-#define FPUD_LOAD(op,szI,szA)				\
-		Bit16u new_sw;						\
-		__asm__ volatile (					\
-			"movl		$8, %%eax		\n"	\
-			"shl		$4, %%eax		\n"	\
-			"shl		$4, %1			\n"	\
-			"fclex						\n"	\
-			#op #szA "	(%2, %%eax)		\n"	\
-			"fnstsw		%0				\n"	\
-			"fstpt		(%2, %1)		"	\
-			:	"=m" (new_sw)				\
-			:	"r" (store_to), "r" (fpu.p_regs)	\
-			:	"eax", "memory"						\
-		);									\
-		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);
-#endif
-
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_LOAD_EA(op,szI,szA)			\
-		__asm__ volatile (					\
-			"movl		$128, %%eax		\n"	\
-			#op #szA "	(%0, %%eax)		\n"	\
-			:								\
-			:	"r" (fpu.p_regs)			\
-			:	"eax", "memory"				\
-		);
-#else
-#define FPUD_LOAD_EA(op,szI,szA)			\
-		Bit16u new_sw;						\
-		__asm__ volatile (					\
-			"movl		$8, %%eax		\n"	\
-			"shl		$4, %%eax		\n"	\
-			"fclex						\n"	\
-			#op #szA "	(%1, %%eax)		\n"	\
-			"fnstsw		%0				\n"	\
-			:	"=m" (new_sw)				\
-			:	"r" (fpu.p_regs)			\
-			:	"eax", "memory"				\
-		);									\
-		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);
-#endif
-
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_STORE(op,szI,szA)				\
-		Bit16u save_cw;						\
-		__asm__ volatile (					\
-			"fnstcw		%0				\n"	\
-			"shll		$4, %1			\n"	\
-			"fldcw		%3				\n"	\
-			"movl		$128, %%eax		\n"	\
-			"fldt		(%2, %1)		\n"	\
-			#op #szA "	(%2, %%eax)		\n"	\
-			"fldcw		%0				"	\
-			:	"=m" (save_cw)				\
-			:	"r" (TOP), "r" (fpu.p_regs), "m" (fpu.cw_mask_all)		\
-			:	"eax", "memory"						\
-		);
-#else
-#define FPUD_STORE(op,szI,szA)				\
-		Bit16u new_sw,save_cw;				\
-		__asm__ volatile (					\
-			"fnstcw		%1				\n"	\
-			"fldcw		%4				\n"	\
-			"shll		$4, %2			\n"	\
-			"movl		$8, %%eax		\n"	\
-			"shl		$4, %%eax		\n"	\
-			"fldt		(%3, %2)		\n"	\
-			clx" 						\n"	\
-			#op #szA "	(%3, %%eax)		\n"	\
-			"fnstsw		%0				\n"	\
-			"fldcw		%1				"	\
-			:	"=m" (new_sw), "=m" (save_cw)	\
-			:	"r" (TOP), "r" (fpu.p_regs), "m" (fpu.cw_mask_all)		\
-			:	"eax", "memory"						\
-		);										\
-		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
-#endif
-
-// handles fsin,fcos,f2xm1,fchs,fabs
-#define FPUD_TRIG(op)						\
-		Bit16u new_sw;						\
-		__asm__ volatile (					\
-			"shll		$4, %1			\n"	\
-			"fldt		(%2, %1)		\n"	\
-			clx" 						\n"	\
-			#op" 						\n"	\
-			"fnstsw		%0				\n"	\
-			"fstpt		(%2, %1)		"	\
-			:	"=m" (new_sw)				\
-			:	"r" (TOP), "r" (fpu.p_regs)	\
-			:	"memory"					\
-		);									\
-		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
-
-// handles fsincos
-#define FPUD_SINCOS()					\
-		Bit16u new_sw;						\
-		__asm__ volatile (					\
-			"movl		%1, %%eax		\n"	\
-			"shll		$4, %1			\n"	\
-			"decl		%%eax			\n"	\
-			"andl		$7, %%eax		\n"	\
-			"shll		$4, %%eax		\n"	\
-			"fldt		(%2, %1)		\n"	\
-			clx" 						\n"	\
-			"fsincos					\n"	\
-			"fnstsw		%0				\n"	\
-			"fstpt		(%2, %%eax)		\n"	\
-			"movw		%0, %%ax		\n"	\
-			"sahf						\n"	\
-			"jp			argument_too_large1		\n"	\
-			"fstpt		(%2, %1)		\n"	\
-			"argument_too_large1:		"	\
-			:	"=m" (new_sw)				\
-			:	"r" (TOP), "r" (fpu.p_regs)	\
-			:	"eax", "cc", "memory"		\
-		);									\
-		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);		\
-		if ((new_sw&0x0400)==0) FPU_PREP_PUSH();
-
-// handles fptan
-#define FPUD_PTAN()						\
-		Bit16u new_sw;						\
-		__asm__ volatile (					\
-			"movl		%1, %%eax		\n"	\
-			"shll		$4, %1			\n"	\
-			"decl		%%eax			\n"	\
-			"andl		$7, %%eax		\n"	\
-			"shll		$4, %%eax		\n"	\
-			"fldt		(%2, %1)		\n"	\
-			clx" 						\n"	\
-			"fptan 						\n"	\
-			"fnstsw		%0				\n"	\
-			"fstpt		(%2, %%eax)		\n"	\
-			"movw		%0, %%ax		\n"	\
-			"sahf						\n"	\
-			"jp			argument_too_large2		\n"	\
-			"fstpt		(%2, %1)		\n"	\
-			"argument_too_large2:		"	\
-			:	"=m" (new_sw)				\
-			:	"r" (TOP), "r" (fpu.p_regs)	\
-			:	"eax", "cc", "memory"		\
-		);									\
-		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);		\
-		if ((new_sw&0x0400)==0) FPU_PREP_PUSH();
-
-// handles fxtract
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_XTRACT						\
-		__asm__ volatile (					\
-			"movl		%0, %%eax		\n"	\
-			"shll		$4, %0			\n"	\
-			"decl		%%eax			\n"	\
-			"andl		$7, %%eax		\n"	\
-			"shll		$4, %%eax		\n"	\
-			"fldt		(%1, %0)		\n"	\
-			"fxtract					\n"	\
-			"fstpt		(%1, %%eax)		\n"	\
-			"fstpt		(%1, %0)		"	\
-			:								\
-			:	"r" (TOP), "r" (fpu.p_regs)	\
-			:	"eax", "memory"				\
-		);									\
-		FPU_PREP_PUSH();
-#else
-#define FPUD_XTRACT						\
-		Bit16u new_sw;						\
-		__asm__ volatile (					\
-			"movl		%1, %%eax		\n"	\
-			"shll		$4, %1			\n"	\
-			"decl		%%eax			\n"	\
-			"andl		$7, %%eax		\n"	\
-			"shll		$4, %%eax		\n"	\
-			"fldt		(%2, %1)		\n"	\
-			"fclex						\n"	\
-			"fxtract					\n"	\
-			"fnstsw		%0				\n"	\
-			"fstpt		(%2, %%eax)		\n"	\
-			"fstpt		(%2, %1)		"	\
-			:	"=m" (new_sw)				\
-			:	"r" (TOP), "r" (fpu.p_regs)	\
-			:	"eax", "memory"						\
-		);									\
-		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);		\
-		FPU_PREP_PUSH();
-#endif
-
-// handles fadd,fmul,fsub,fsubr
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_ARITH1(op)						\
-		Bit16u save_cw;						\
-		__asm__ volatile (					\
-			"fnstcw		%0				\n"	\
-			"fldcw		%4				\n"	\
-			"shll		$4, %2			\n"	\
-			"shll		$4, %1			\n"	\
-			"fldt		(%3, %2)		\n"	\
-			"fldt		(%3, %1)		\n"	\
-			#op"						\n"	\
-			"fstpt		(%3, %1)		\n"	\
-			"fldcw		%0				"	\
-			:	"=m" (save_cw)		\
-			:	"r" (op1), "r" (op2), "r" (fpu.p_regs), "m" (fpu.cw_mask_all)		\
-			:	"memory"				\
-		);
-#else
-#define FPUD_ARITH1(op)						\
-		Bit16u new_sw,save_cw;				\
-		__asm__ volatile (					\
-			"fnstcw		%1				\n"	\
-			"fldcw		%5				\n"	\
-			"shll		$4, %3			\n"	\
-			"shll		$4, %2			\n"	\
-			"fldt		(%4, %3)		\n"	\
-			"fldt		(%4, %2)		\n"	\
-			clx" 						\n"	\
-			#op"						\n"	\
-			"fnstsw		%0				\n"	\
-			"fstpt		(%4, %2)		\n"	\
-			"fldcw		%1				"	\
-			:	"=m" (new_sw), "=m" (save_cw)		\
-			:	"r" (op1), "r" (op2), "r" (fpu.p_regs), "m" (fpu.cw_mask_all)		\
-			:	"memory"				\
-		);									\
-		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
-#endif
-
-// handles fadd,fmul,fsub,fsubr
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_ARITH1_EA(op)					\
-		Bit16u save_cw;						\
-		__asm__ volatile (					\
-			"fnstcw		%0				\n"	\
-			"fldcw		%3				\n"	\
-			"shll		$4, %1			\n"	\
-			"fldt		(%2, %1)		\n"	\
-			#op"						\n"	\
-			"fstpt		(%2, %1)		\n"	\
-			"fldcw		%0				"	\
-			:	"=m" (save_cw)		\
-			:	"r" (op1), "r" (fpu.p_regs), "m" (fpu.cw_mask_all)		\
-			:	"memory"				\
-		);
-#else
-#define FPUD_ARITH1_EA(op)					\
-		Bit16u new_sw,save_cw;				\
-		__asm__ volatile (					\
-			"fnstcw		%1				\n"	\
-			"fldcw		%4				\n"	\
-			"shll		$4, %2			\n"	\
-			"fldt		(%3, %2)		\n"	\
-			clx" 						\n"	\
-			#op"						\n"	\
-			"fnstsw		%0				\n"	\
-			"fstpt		(%3, %2)		\n"	\
-			"fldcw		%1				"	\
-			:	"=m" (new_sw), "=m" (save_cw)		\
-			:	"r" (op1), "r" (fpu.p_regs), "m" (fpu.cw_mask_all)		\
-			:	"memory"				\
-		);									\
-		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
-#endif
-
-// handles fsqrt,frndint
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_ARITH2(op)						\
-		Bit16u save_cw;						\
-		__asm__ volatile (					\
-			"fnstcw		%0				\n"	\
-			"fldcw		%3				\n"	\
-			"shll		$4, %1			\n"	\
-			"fldt		(%2, %1)		\n"	\
-			#op" 						\n"	\
-			"fstpt		(%2, %1)		\n"	\
-			"fldcw		%0				"	\
-			:	"=m" (save_cw)				\
-			:	"r" (TOP), "r" (fpu.p_regs), "m" (fpu.cw_mask_all)		\
-			:	"memory"				\
-		);
-#else
-#define FPUD_ARITH2(op)						\
-		Bit16u new_sw,save_cw;				\
-		__asm__ volatile (					\
-			"fnstcw		%1				\n"	\
-			"fldcw		%4				\n"	\
-			"shll		$4, %2			\n"	\
-			"fldt		(%3, %2)		\n"	\
-			clx" 						\n"	\
-			#op" 						\n"	\
-			"fnstsw		%0				\n"	\
-			"fstpt		(%3, %2)		\n"	\
-			"fldcw		%1				"	\
-			:	"=m" (new_sw), "=m" (save_cw)	\
-			:	"r" (TOP), "r" (fpu.p_regs), "m" (fpu.cw_mask_all)		\
-			:	"memory"				\
-		);										\
-		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
-#endif
-
-// handles fdiv,fdivr
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_ARITH3(op)						\
-		Bit16u save_cw;						\
-		__asm__ volatile (					\
-			"fnstcw		%0				\n"	\
-			"fldcw		%4				\n"	\
-			"shll		$4, %2			\n"	\
-			"shll		$4, %1			\n"	\
-			"fldt		(%3, %2)		\n"	\
-			"fldt		(%3, %1)		\n"	\
-			#op"						\n"	\
-			"fstpt		(%3, %1)		\n"	\
-			"fldcw		%0				"	\
-			:	"=m" (save_cw)				\
-			:	"r" (op1), "r" (op2), "r" (fpu.p_regs), "m" (fpu.cw_mask_all)		\
-			:	"memory"					\
-		);
-#else
-#define FPUD_ARITH3(op)						\
-		Bit16u new_sw,save_cw;				\
-		__asm__ volatile (					\
-			"fnstcw		%1				\n"	\
-			"fldcw		%5				\n"	\
-			"shll		$4, %3			\n"	\
-			"shll		$4, %2			\n"	\
-			"fldt		(%4, %3)		\n"	\
-			"fldt		(%4, %2)		\n"	\
-			"fclex						\n"	\
-			#op"						\n"	\
-			"fnstsw		%0				\n"	\
-			"fstpt		(%4, %2)		\n"	\
-			"fldcw		%1				"	\
-			:	"=m" (new_sw), "=m" (save_cw)		\
-			:	"r" (op1), "r" (op2), "r" (fpu.p_regs), "m" (fpu.cw_mask_all)		\
-			:	"memory"					\
-		);									\
-		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);
-#endif
-
-// handles fdiv,fdivr
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_ARITH3_EA(op)					\
-		Bit16u save_cw;						\
-		__asm__ volatile (					\
-			"fnstcw		%0				\n"	\
-			"fldcw		%3				\n"	\
-			"shll		$4, %1			\n"	\
-			"fldt		(%2, %1)		\n"	\
-			#op"						\n"	\
-			"fstpt		(%2, %1)		\n"	\
-			"fldcw		%0				"	\
-			:	"=m" (save_cw)				\
-			:	"r" (op1), "r" (fpu.p_regs), "m" (fpu.cw_mask_all)		\
-			:	"memory"					\
-		);
-#else
-#define FPUD_ARITH3_EA(op)					\
-		Bit16u new_sw,save_cw;				\
-		__asm__ volatile (					\
-			"fnstcw		%1				\n"	\
-			"fldcw		%4				\n"	\
-			"shll		$4, %2			\n"	\
-			"fldt		(%3, %2)		\n"	\
-			"fclex						\n"	\
-			#op"						\n"	\
-			"fnstsw		%0				\n"	\
-			"fstpt		(%3, %2)		\n"	\
-			"fldcw		%1				"	\
-			:	"=m" (new_sw), "=m" (save_cw)		\
-			:	"r" (op1), "r" (fpu.p_regs), "m" (fpu.cw_mask_all)		\
-			:	"memory"					\
-		);									\
-		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);
-#endif
-
-// handles fprem,fprem1,fscale
-#define FPUD_REMINDER(op)					\
-		Bit16u new_sw;						\
-		__asm__ volatile (					\
-			"movl		%1, %%eax		\n"	\
-			"incl		%%eax			\n"	\
-			"andl		$7, %%eax		\n"	\
-			"shll		$4, %%eax		\n"	\
-			"shll		$4, %1			\n"	\
-			"fldt		(%2, %%eax)		\n"	\
-			"fldt		(%2, %1)		\n"	\
-			"fclex						\n"	\
-			#op" 						\n"	\
-			"fnstsw		%0				\n"	\
-			"fstpt		(%2, %1)		\n"	\
-			"fstp		%%st(0)			"	\
-			:	"=m" (new_sw)				\
-			:	"r" (TOP), "r" (fpu.p_regs)	\
-			:	"eax", "memory"						\
-		);									\
-		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);
-
-// handles fcom,fucom
-#define FPUD_COMPARE(op)					\
-		Bit16u new_sw;						\
-		__asm__ volatile (					\
-			"shll		$4, %2			\n"	\
-			"shll		$4, %1			\n"	\
-			"fldt		(%3, %2)		\n"	\
-			"fldt		(%3, %1)		\n"	\
-			clx" 						\n"	\
-			#op" 						\n"	\
-			"fnstsw		%0				"	\
-			:	"=m" (new_sw)				\
-			:	"r" (op1), "r" (op2), "r" (fpu.p_regs) 		\
-			:	"memory"					\
-		);									\
-		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
-
-// handles fcom,fucom
-#define FPUD_COMPARE_EA(op)					\
-		Bit16u new_sw;						\
-		__asm__ volatile (					\
-			"shll		$4, %1			\n"	\
-			"fldt		(%2, %1)		\n"	\
-			clx" 						\n"	\
-			#op" 						\n"	\
-			"fnstsw		%0				"	\
-			:	"=m" (new_sw)				\
-			:	"r" (op1), "r" (fpu.p_regs) 		\
-			:	"memory"					\
-		);									\
-		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
-
-// handles fxam,ftst
-#define FPUD_EXAMINE(op)					\
-		Bit16u new_sw;						\
-		__asm__ volatile (					\
-			"shll		$4, %1			\n"	\
-			"fldt		(%2, %1)		\n"	\
-			clx" 						\n"	\
-			#op" 						\n"	\
-			"fnstsw		%0				\n"	\
-			"fstp		%%st(0)			"	\
-			:	"=m" (new_sw)				\
-			:	"r" (TOP), "r" (fpu.p_regs)	\
-			:	"memory"				\
-		);									\
-		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
-
-// handles fpatan,fyl2xp1
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_WITH_POP(op)					\
-		__asm__ volatile (					\
-			"movl		%0, %%eax		\n"	\
-			"incl		%%eax			\n"	\
-			"andl		$7, %%eax		\n"	\
-			"shll		$4, %%eax		\n"	\
-			"shll		$4, %0			\n"	\
-			"fldt		(%1, %%eax)		\n"	\
-			"fldt		(%1, %0)		\n"	\
-			#op" 						\n"	\
-			"fstpt		(%1, %%eax)		\n"	\
-			:								\
-			:	"r" (TOP), "r" (fpu.p_regs)	\
-			:	"eax", "memory"				\
-		);									\
-		FPU_FPOP();
-#else
-#define FPUD_WITH_POP(op)					\
-		Bit16u new_sw;						\
-		__asm__ volatile (					\
-			"movl		%1, %%eax		\n"	\
-			"incl		%%eax			\n"	\
-			"andl		$7, %%eax		\n"	\
-			"shll		$4, %%eax		\n"	\
-			"shll		$4, %1			\n"	\
-			"fldt		(%2, %%eax)		\n"	\
-			"fldt		(%2, %1)		\n"	\
-			"fclex						\n"	\
-			#op" 						\n"	\
-			"fnstsw		%0				\n"	\
-			"fstpt		(%2, %%eax)		\n"	\
-			:	"=m" (new_sw)				\
-			:	"r" (TOP), "r" (fpu.p_regs)	\
-			:	"eax", "memory"						\
-		);									\
-		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);		\
-		FPU_FPOP();
-#endif
-
-// handles fyl2x
-#ifdef WEAK_EXCEPTIONS
-#define FPUD_FYL2X(op)						\
-		__asm__ volatile (					\
-			"movl		%0, %%eax		\n"	\
-			"incl		%%eax			\n"	\
-			"andl		$7, %%eax		\n"	\
-			"shll		$4, %%eax		\n"	\
-			"shll		$4, %0			\n"	\
-			"fldt		(%1, %%eax)		\n"	\
-			"fldt		(%1, %0)		\n"	\
-			#op" 						\n"	\
-			"fstpt		(%1, %%eax)		\n"	\
-			:								\
-			:	"r" (TOP), "r" (fpu.p_regs)	\
-			:	"eax", "memory"				\
-		);									\
-		FPU_FPOP();
-#else
-#define FPUD_FYL2X(op)						\
-		Bit16u new_sw;						\
-		__asm__ volatile (					\
-			"movl		%1, %%eax		\n"	\
-			"incl		%%eax			\n"	\
-			"andl		$7, %%eax		\n"	\
-			"shll		$4, %%eax		\n"	\
-			"shll		$4, %1			\n"	\
-			"fldt		(%2, %%eax)		\n"	\
-			"fldt		(%2, %1)		\n"	\
-			"fclex						\n"	\
-			#op" 						\n"	\
-			"fnstsw		%0				\n"	\
-			"fstpt		(%2, %%eax)		\n"	\
-			:	"=m" (new_sw)				\
-			:	"r" (TOP), "r" (fpu.p_regs)	\
-			:	"eax", "memory"				\
-		);									\
-		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);		\
-		FPU_FPOP();
-#endif
-
-// load math constants
-#define FPUD_LOAD_CONST(op)				\
-		FPU_PREP_PUSH();					\
-		__asm__ volatile (					\
-			"shll		$4, %0			\n"	\
-			clx" 						\n"	\
-			#op" 						\n"	\
-			"fstpt		(%1, %0)		\n"	\
-			:								\
-			:	"r" (TOP), "r" (fpu.p_regs)	\
-			:	"memory"					\
-		);
-
-#endif
-
-#ifdef WEAK_EXCEPTIONS
-const Bit16u exc_mask=0x7f00;
-#else
-const Bit16u exc_mask=0xffbf;
-#endif
-
-static void FPU_FINIT(void) {
-	FPU_SetCW(0x37F);
-	fpu.sw=0;
-	TOP=FPU_GET_TOP();
-	fpu.tags[0]=TAG_Empty;
-	fpu.tags[1]=TAG_Empty;
-	fpu.tags[2]=TAG_Empty;
-	fpu.tags[3]=TAG_Empty;
-	fpu.tags[4]=TAG_Empty;
-	fpu.tags[5]=TAG_Empty;
-	fpu.tags[6]=TAG_Empty;
-	fpu.tags[7]=TAG_Empty;
-	fpu.tags[8]=TAG_Valid; // is only used by us
-}
-
-static void FPU_FCLEX(void){
-	fpu.sw&=0x7f00;				//should clear exceptions
-}
-
-static void FPU_FNOP(void){
-}
-
-static void FPU_PREP_PUSH(void){
-	TOP = (TOP - 1) &7;
-	fpu.tags[TOP]=TAG_Valid;
-}
-
-static void FPU_FPOP(void){
-	fpu.tags[TOP]=TAG_Empty;
-	TOP = ((TOP+1)&7);
-}
-
-static void FPU_FLD_F32(PhysPt addr,Bitu store_to) {
-	fpu.p_regs[8].m1 = mem_readd(addr);
-	FPUD_LOAD(fld,DWORD,s)
-}
-
-static void FPU_FLD_F32_EA(PhysPt addr) {
-	fpu.p_regs[8].m1 = mem_readd(addr);
-	FPUD_LOAD_EA(fld,DWORD,s)
-}
-
-static void FPU_FLD_F64(PhysPt addr,Bitu store_to) {
-	fpu.p_regs[8].m1 = mem_readd(addr);
-	fpu.p_regs[8].m2 = mem_readd(addr+4);
-	FPUD_LOAD(fld,QWORD,l)
-}
-
-static void FPU_FLD_F64_EA(PhysPt addr) {
-	fpu.p_regs[8].m1 = mem_readd(addr);
-	fpu.p_regs[8].m2 = mem_readd(addr+4);
-	FPUD_LOAD_EA(fld,QWORD,l)
-}
-
-static void FPU_FLD_F80(PhysPt addr) {
-	fpu.p_regs[TOP].m1 = mem_readd(addr);
-	fpu.p_regs[TOP].m2 = mem_readd(addr+4);
-	fpu.p_regs[TOP].m3 = mem_readw(addr+8);
-	FPU_SET_C1(0);
-}
-
-static void FPU_FLD_I16(PhysPt addr,Bitu store_to) {
-	fpu.p_regs[8].m1 = (Bit32u)mem_readw(addr);
-	FPUD_LOAD(fild,WORD,s)
-}
-
-static void FPU_FLD_I16_EA(PhysPt addr) {
-	fpu.p_regs[8].m1 = (Bit32u)mem_readw(addr);
-	FPUD_LOAD_EA(fild,WORD,s)
-}
-
-static void FPU_FLD_I32(PhysPt addr,Bitu store_to) {
-	fpu.p_regs[8].m1 = mem_readd(addr);
-	FPUD_LOAD(fild,DWORD,l)
-}
-
-static void FPU_FLD_I32_EA(PhysPt addr) {
-	fpu.p_regs[8].m1 = mem_readd(addr);
-	FPUD_LOAD_EA(fild,DWORD,l)
-}
-
-static void FPU_FLD_I64(PhysPt addr,Bitu store_to) {
-	fpu.p_regs[8].m1 = mem_readd(addr);
-	fpu.p_regs[8].m2 = mem_readd(addr+4);
-	FPUD_LOAD(fild,QWORD,q)
-}
-
-static void FPU_FBLD(PhysPt addr,Bitu store_to) {
-	fpu.p_regs[8].m1 = mem_readd(addr);
-	fpu.p_regs[8].m2 = mem_readd(addr+4);
-	fpu.p_regs[8].m3 = mem_readw(addr+8);
-	FPUD_LOAD(fbld,TBYTE,)
-}
-
-static void FPU_FST_F32(PhysPt addr) {
-	FPUD_STORE(fstp,DWORD,s)
-	mem_writed(addr,fpu.p_regs[8].m1);
-}
-
-static void FPU_FST_F64(PhysPt addr) {
-	FPUD_STORE(fstp,QWORD,l)
-	mem_writed(addr,fpu.p_regs[8].m1);
-	mem_writed(addr+4,fpu.p_regs[8].m2);
-}
-
-static void FPU_FST_F80(PhysPt addr) {
-	mem_writed(addr,fpu.p_regs[TOP].m1);
-	mem_writed(addr+4,fpu.p_regs[TOP].m2);
-	mem_writew(addr+8,fpu.p_regs[TOP].m3);
-	FPU_SET_C1(0);
-}
-
-static void FPU_FST_I16(PhysPt addr) {
-	FPUD_STORE(fistp,WORD,s)
-	mem_writew(addr,(Bit16u)fpu.p_regs[8].m1);
-}
-
-static void FPU_FST_I32(PhysPt addr) {
-	FPUD_STORE(fistp,DWORD,l)
-	mem_writed(addr,fpu.p_regs[8].m1);
-}
-
-static void FPU_FST_I64(PhysPt addr) {
-	FPUD_STORE(fistp,QWORD,ll)
-	mem_writed(addr,fpu.p_regs[8].m1);
-	mem_writed(addr+4,fpu.p_regs[8].m2);
-}
-
-static void FPU_FBST(PhysPt addr) {
-	FPUD_STORE(fbstp,TBYTE,)
-	mem_writed(addr,fpu.p_regs[8].m1);
-	mem_writed(addr+4,fpu.p_regs[8].m2);
-	mem_writew(addr+8,fpu.p_regs[8].m3);
-}
-
-
-static void FPU_FSIN(void){
-	FPUD_TRIG(fsin)
-}
-
-static void FPU_FSINCOS(void){
-	FPUD_SINCOS()
-}
-
-static void FPU_FCOS(void){
-	FPUD_TRIG(fcos)
-}
-
-static void FPU_FSQRT(void){
-	FPUD_ARITH2(fsqrt)
-}
-
-static void FPU_FPATAN(void){
-	FPUD_WITH_POP(fpatan)
-}
-
-static void FPU_FPTAN(void){
-	FPUD_PTAN()
-}
-
-
-static void FPU_FADD(Bitu op1, Bitu op2){
-	FPUD_ARITH1(faddp)
-}
-
-static void FPU_FADD_EA(Bitu op1){
-	FPUD_ARITH1_EA(faddp)
-}
-
-static void FPU_FDIV(Bitu op1, Bitu op2){
-	FPUD_ARITH3(fdivp)
-}
-
-static void FPU_FDIV_EA(Bitu op1){
-	FPUD_ARITH3_EA(fdivp)
-}
-
-static void FPU_FDIVR(Bitu op1, Bitu op2){
-	FPUD_ARITH3(fdivrp)
-}
-
-static void FPU_FDIVR_EA(Bitu op1){
-	FPUD_ARITH3_EA(fdivrp)
-}
-
-static void FPU_FMUL(Bitu op1, Bitu op2){
-	FPUD_ARITH1(fmulp)
-}
-
-static void FPU_FMUL_EA(Bitu op1){
-	FPUD_ARITH1_EA(fmulp)
-}
-
-static void FPU_FSUB(Bitu op1, Bitu op2){
-	FPUD_ARITH1(fsubp)
-}
-
-static void FPU_FSUB_EA(Bitu op1){
-	FPUD_ARITH1_EA(fsubp)
-}
-
-static void FPU_FSUBR(Bitu op1, Bitu op2){
-	FPUD_ARITH1(fsubrp)
-}
-
-static void FPU_FSUBR_EA(Bitu op1){
-	FPUD_ARITH1_EA(fsubrp)
-}
-
-static void FPU_FXCH(Bitu stv, Bitu other){
-	FPU_Tag tag = fpu.tags[other];
-	fpu.tags[other] = fpu.tags[stv];
-	fpu.tags[stv] = tag;
-
-	Bit32u m1s = fpu.p_regs[other].m1;
-	Bit32u m2s = fpu.p_regs[other].m2;
-	Bit16u m3s = fpu.p_regs[other].m3;
-	fpu.p_regs[other].m1 = fpu.p_regs[stv].m1;
-	fpu.p_regs[other].m2 = fpu.p_regs[stv].m2;
-	fpu.p_regs[other].m3 = fpu.p_regs[stv].m3;
-	fpu.p_regs[stv].m1 = m1s;
-	fpu.p_regs[stv].m2 = m2s;
-	fpu.p_regs[stv].m3 = m3s;
-
-	FPU_SET_C1(0);
-}
-
-static void FPU_FST(Bitu stv, Bitu other){
-	fpu.tags[other] = fpu.tags[stv];
-
-	fpu.p_regs[other].m1 = fpu.p_regs[stv].m1;
-	fpu.p_regs[other].m2 = fpu.p_regs[stv].m2;
-	fpu.p_regs[other].m3 = fpu.p_regs[stv].m3;
-
-	FPU_SET_C1(0);
-}
-
-
-static void FPU_FCOM(Bitu op1, Bitu op2){
-	FPUD_COMPARE(fcompp)
-}
-
-static void FPU_FCOM_EA(Bitu op1){
-	FPUD_COMPARE_EA(fcompp)
-}
-
-static void FPU_FUCOM(Bitu op1, Bitu op2){
-	FPUD_COMPARE(fucompp)
-}
-
-static void FPU_FRNDINT(void){
-	FPUD_ARITH2(frndint)
-}
-
-static void FPU_FPREM(void){
-	FPUD_REMINDER(fprem)
-}
-
-static void FPU_FPREM1(void){
-	FPUD_REMINDER(fprem1)
-}
-
-static void FPU_FXAM(void){
-	FPUD_EXAMINE(fxam)
-	// handle empty registers (C1 set to sign in any way!)
-	if(fpu.tags[TOP] == TAG_Empty) {
-		FPU_SET_C3(1);FPU_SET_C2(0);FPU_SET_C0(1);
-		return;
-	}
-}
-
-static void FPU_F2XM1(void){
-	FPUD_TRIG(f2xm1)
-}
-
-static void FPU_FYL2X(void){
-	FPUD_FYL2X(fyl2x)
-}
-
-static void FPU_FYL2XP1(void){
-	FPUD_WITH_POP(fyl2xp1)
-}
-
-static void FPU_FSCALE(void){
-	FPUD_REMINDER(fscale)
-}
-
-
-static void FPU_FSTENV(PhysPt addr){
-	FPU_SET_TOP(TOP);
-	if(!cpu.code.big) {
-		mem_writew(addr+0,static_cast<Bit16u>(fpu.cw));
-		mem_writew(addr+2,static_cast<Bit16u>(fpu.sw));
-		mem_writew(addr+4,static_cast<Bit16u>(FPU_GetTag()));
-	} else { 
-		mem_writed(addr+0,static_cast<Bit32u>(fpu.cw));
-		mem_writed(addr+4,static_cast<Bit32u>(fpu.sw));
-		mem_writed(addr+8,static_cast<Bit32u>(FPU_GetTag()));
-	}
-}
-
-static void FPU_FLDENV(PhysPt addr){
-	Bit16u tag;
-	Bit32u tagbig;
-	Bitu cw;
-	if(!cpu.code.big) {
-		cw     = mem_readw(addr+0);
-		fpu.sw = mem_readw(addr+2);
-		tag    = mem_readw(addr+4);
-	} else { 
-		cw     = mem_readd(addr+0);
-		fpu.sw = (Bit16u)mem_readd(addr+4);
-		tagbig = mem_readd(addr+8);
-		tag    = static_cast<Bit16u>(tagbig);
-	}
-	FPU_SetTag(tag);
-	FPU_SetCW(cw);
-	TOP=FPU_GET_TOP();
-}
-
-static void FPU_FSAVE(PhysPt addr){
-	FPU_FSTENV(addr);
-	Bitu start=(cpu.code.big?28:14);
-	for(Bitu i=0;i<8;i++){
-		mem_writed(addr+start,fpu.p_regs[STV(i)].m1);
-		mem_writed(addr+start+4,fpu.p_regs[STV(i)].m2);
-		mem_writew(addr+start+8,fpu.p_regs[STV(i)].m3);
-		start+=10;
-	}
-	FPU_FINIT();
-}
-
-static void FPU_FRSTOR(PhysPt addr){
-	FPU_FLDENV(addr);
-	Bitu start=(cpu.code.big?28:14);
-	for(Bitu i=0;i<8;i++){
-		fpu.p_regs[STV(i)].m1 = mem_readd(addr+start);
-		fpu.p_regs[STV(i)].m2 = mem_readd(addr+start+4);
-		fpu.p_regs[STV(i)].m3 = mem_readw(addr+start+8);
-		start+=10;
-	}
-}
-
-
-static void FPU_FXTRACT(void) {
-	FPUD_XTRACT
-}
-
-static void FPU_FCHS(void){
-	FPUD_TRIG(fchs)
-}
-
-static void FPU_FABS(void){
-	FPUD_TRIG(fabs)
-}
-
-static void FPU_FTST(void){
-	FPUD_EXAMINE(ftst)
-}
-
-static void FPU_FLD1(void){
-	FPUD_LOAD_CONST(fld1)
-}
-
-static void FPU_FLDL2T(void){
-	FPUD_LOAD_CONST(fldl2t)
-}
-
-static void FPU_FLDL2E(void){
-	FPUD_LOAD_CONST(fldl2e)
-}
-
-static void FPU_FLDPI(void){
-	FPUD_LOAD_CONST(fldpi)
-}
-
-static void FPU_FLDLG2(void){
-	FPUD_LOAD_CONST(fldlg2)
-}
-
-static void FPU_FLDLN2(void){
-	FPUD_LOAD_CONST(fldln2)
-}
-
-static void FPU_FLDZ(void){
-	FPUD_LOAD_CONST(fldz)
-	fpu.tags[TOP]=TAG_Zero;
-}
+/*
+ *  Copyright (C) 2002-2020  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef DOSBOX_FPU_H
+#include "fpu.h"
+#endif
+
+// #define WEAK_EXCEPTIONS
+
+
+#if defined (_MSC_VER)
+
+#ifdef WEAK_EXCEPTIONS
+#define clx
+#else
+#define clx fclex
+#endif
+
+#ifdef WEAK_EXCEPTIONS
+#define FPUD_LOAD(op,szI,szA)			\
+		__asm {							\
+		__asm	mov		ebx, store_to	\
+		__asm	shl		ebx, 4			\
+		__asm	op		szI PTR fpu.p_regs[128].m1		\
+		__asm	fstp	TBYTE PTR fpu.p_regs[ebx].m1	\
+		}
+#else
+#define FPUD_LOAD(op,szI,szA)			\
+		Bit16u new_sw;					\
+		__asm {							\
+		__asm	mov		eax, 8			\
+		__asm	shl		eax, 4			\
+		__asm	mov		ebx, store_to	\
+		__asm	shl		ebx, 4			\
+		__asm	fclex					\
+		__asm	op		szI PTR fpu.p_regs[eax].m1		\
+		__asm	fnstsw	new_sw			\
+		__asm	fstp	TBYTE PTR fpu.p_regs[ebx].m1	\
+		}								\
+		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);
+#endif
+
+#ifdef WEAK_EXCEPTIONS
+#define FPUD_LOAD_EA(op,szI,szA)		\
+		__asm {							\
+		__asm	op		szI PTR fpu.p_regs[128].m1		\
+		}
+#else
+#define FPUD_LOAD_EA(op,szI,szA)		\
+		Bit16u new_sw;					\
+		__asm {							\
+		__asm	mov		eax, 8			\
+		__asm	shl		eax, 4			\
+		__asm	fclex					\
+		__asm	op		szI PTR fpu.p_regs[eax].m1		\
+		__asm	fnstsw	new_sw			\
+		}								\
+		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);
+#endif
+
+#ifdef WEAK_EXCEPTIONS
+#define FPUD_STORE(op,szI,szA)				\
+		Bit16u save_cw;						\
+		__asm {								\
+		__asm	fnstcw	save_cw				\
+		__asm	mov		eax, TOP			\
+		__asm	fldcw	fpu.cw_mask_all		\
+		__asm	shl		eax, 4				\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	op		szI PTR fpu.p_regs[128].m1		\
+		__asm	fldcw	save_cw				\
+		}
+#else
+#define FPUD_STORE(op,szI,szA)				\
+		Bit16u new_sw,save_cw;				\
+		__asm {								\
+		__asm	fnstcw	save_cw				\
+		__asm	fldcw	fpu.cw_mask_all		\
+		__asm	mov		eax, TOP			\
+		__asm	shl		eax, 4				\
+		__asm	mov		ebx, 8				\
+		__asm	shl		ebx, 4				\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	clx							\
+		__asm	op		szI PTR fpu.p_regs[ebx].m1		\
+		__asm	fnstsw	new_sw				\
+		__asm	fldcw	save_cw				\
+		}									\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
+#endif
+
+// handles fsin,fcos,f2xm1,fchs,fabs
+#define FPUD_TRIG(op)				\
+		Bit16u new_sw;				\
+		__asm {						\
+		__asm	mov		eax, TOP	\
+		__asm	shl		eax, 4		\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	clx					\
+		__asm	op					\
+		__asm	fnstsw	new_sw		\
+		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	\
+		}							\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
+
+// handles fsincos
+#define FPUD_SINCOS()				\
+		Bit16u new_sw;					\
+		__asm {							\
+		__asm	mov		eax, TOP		\
+		__asm	mov		ebx, eax		\
+		__asm	dec     ebx				\
+		__asm	and     ebx, 7			\
+		__asm	shl		eax, 4			\
+		__asm	shl		ebx, 4			\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	clx						\
+		__asm	fsincos					\
+		__asm	fnstsw	new_sw			\
+		__asm	mov		cx, new_sw		\
+		__asm	and		ch, 0x04 		\
+		__asm	jnz		argument_too_large1				\
+		__asm	fstp	TBYTE PTR fpu.p_regs[ebx].m1	\
+		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	jmp		end_sincos		\
+		__asm	argument_too_large1:	\
+		__asm	fstp	st(0)			\
+		__asm	end_sincos:				\
+		}												\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);		\
+		if ((new_sw&0x0400)==0) FPU_PREP_PUSH();
+
+// handles fptan
+#define FPUD_PTAN()					\
+		Bit16u new_sw;					\
+		__asm {							\
+		__asm	mov		eax, TOP		\
+		__asm	mov		ebx, eax		\
+		__asm	dec     ebx				\
+		__asm	and     ebx, 7			\
+		__asm	shl		eax, 4			\
+		__asm	shl		ebx, 4			\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	clx					\
+		__asm	fptan					\
+		__asm	fnstsw	new_sw			\
+		__asm	mov		cx, new_sw		\
+		__asm	and		ch, 0x04 		\
+		__asm	jnz		argument_too_large2				\
+		__asm	fstp	TBYTE PTR fpu.p_regs[ebx].m1	\
+		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	jmp		end_ptan		\
+		__asm	argument_too_large2:	\
+		__asm	fstp	st(0)			\
+		__asm	end_ptan:				\
+		}												\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);		\
+		if ((new_sw&0x0400)==0) FPU_PREP_PUSH();
+
+// handles fxtract
+#ifdef WEAK_EXCEPTIONS
+#define FPUD_XTRACT						\
+		__asm {							\
+		__asm	mov		eax, TOP		\
+		__asm	mov		ebx, eax		\
+		__asm	dec     ebx				\
+		__asm	and     ebx, 7			\
+		__asm	shl		eax, 4			\
+		__asm	shl		ebx, 4			\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	fxtract					\
+		__asm	fstp	TBYTE PTR fpu.p_regs[ebx].m1	\
+		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	\
+		}												\
+		FPU_PREP_PUSH();
+#else
+#define FPUD_XTRACT						\
+		Bit16u new_sw;					\
+		__asm {							\
+		__asm	mov		eax, TOP		\
+		__asm	mov		ebx, eax		\
+		__asm	dec     ebx				\
+		__asm	and     ebx, 7			\
+		__asm	shl		eax, 4			\
+		__asm	shl		ebx, 4			\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	fclex					\
+		__asm	fxtract					\
+		__asm	fnstsw	new_sw			\
+		__asm	fstp	TBYTE PTR fpu.p_regs[ebx].m1	\
+		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	\
+		}												\
+		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);			\
+		FPU_PREP_PUSH();
+#endif
+
+// handles fadd,fmul,fsub,fsubr
+#ifdef WEAK_EXCEPTIONS
+#define FPUD_ARITH1(op)						\
+		Bit16u save_cw;						\
+		__asm {								\
+		__asm	fnstcw	save_cw				\
+		__asm	mov		eax, op1			\
+		__asm	shl		eax, 4				\
+		__asm	fldcw	fpu.cw_mask_all		\
+		__asm	mov		ebx, op2			\
+		__asm	shl		ebx, 4				\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	fld		TBYTE PTR fpu.p_regs[ebx].m1	\
+		__asm	op		st(1), st(0)		\
+		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	 \
+		__asm	fldcw	save_cw				\
+		}
+#else
+#define FPUD_ARITH1(op)						\
+		Bit16u new_sw,save_cw;				\
+		__asm {								\
+		__asm	fnstcw	save_cw				\
+		__asm	fldcw	fpu.cw_mask_all		\
+		__asm	mov		eax, op1			\
+		__asm	shl		eax, 4				\
+		__asm	mov		ebx, op2			\
+		__asm	shl		ebx, 4				\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	fld		TBYTE PTR fpu.p_regs[ebx].m1	\
+		__asm	clx							\
+		__asm	op		st(1), st(0)		\
+		__asm	fnstsw	new_sw				\
+		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	 \
+		__asm	fldcw	save_cw				\
+		}									\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
+#endif
+
+// handles fadd,fmul,fsub,fsubr
+#ifdef WEAK_EXCEPTIONS
+#define FPUD_ARITH1_EA(op)					\
+		Bit16u save_cw;						\
+		__asm {								\
+		__asm	fnstcw	save_cw				\
+		__asm	mov		eax, op1			\
+		__asm	fldcw	fpu.cw_mask_all		\
+		__asm	shl		eax, 4				\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	fxch	\
+		__asm	op		st(1), st(0)		\
+		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	 \
+		__asm	fldcw	save_cw				\
+		}
+#else
+#define FPUD_ARITH1_EA(op)					\
+		Bit16u new_sw,save_cw;				\
+		__asm {								\
+		__asm	fnstcw	save_cw				\
+		__asm	fldcw	fpu.cw_mask_all		\
+		__asm	mov		eax, op1			\
+		__asm	shl		eax, 4				\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	fxch	\
+		__asm	clx							\
+		__asm	op		st(1), st(0)		\
+		__asm	fnstsw	new_sw				\
+		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	 \
+		__asm	fldcw	save_cw				\
+		}									\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
+#endif
+
+// handles fsqrt,frndint
+#ifdef WEAK_EXCEPTIONS
+#define FPUD_ARITH2(op)						\
+		Bit16u save_cw;						\
+		__asm {								\
+		__asm	fnstcw	save_cw				\
+		__asm	mov		eax, TOP			\
+		__asm	fldcw	fpu.cw_mask_all		\
+		__asm	shl		eax, 4				\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	op							\
+		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	 \
+		__asm	fldcw	save_cw				\
+		}
+#else
+#define FPUD_ARITH2(op)						\
+		Bit16u new_sw,save_cw;				\
+		__asm {								\
+		__asm	fnstcw	save_cw				\
+		__asm	fldcw	fpu.cw_mask_all		\
+		__asm	mov		eax, TOP			\
+		__asm	shl		eax, 4				\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	clx							\
+		__asm	op							\
+		__asm	fnstsw	new_sw				\
+		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	 \
+		__asm	fldcw	save_cw				\
+		}									\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
+#endif
+
+// handles fdiv,fdivr
+// (This is identical to FPUD_ARITH1 but without a WEAK_EXCEPTIONS variant)
+#define FPUD_ARITH3(op)						\
+		Bit16u new_sw,save_cw;				\
+		__asm {								\
+		__asm	fnstcw	save_cw				\
+		__asm	fldcw	fpu.cw_mask_all		\
+		__asm	mov		eax, op1			\
+		__asm	shl		eax, 4				\
+		__asm	mov		ebx, op2			\
+		__asm	shl		ebx, 4				\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	fld		TBYTE PTR fpu.p_regs[ebx].m1	\
+		__asm	fclex						\
+		__asm	op		st(1), st(0)		\
+		__asm	fnstsw	new_sw				\
+		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	 \
+		__asm	fldcw	save_cw				\
+		}									\
+		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);
+
+// handles fdiv,fdivr
+// (This is identical to FPUD_ARITH1_EA but without a WEAK_EXCEPTIONS variant)
+#define FPUD_ARITH3_EA(op)					\
+		Bit16u new_sw,save_cw;				\
+		__asm {								\
+		__asm	fnstcw	save_cw				\
+		__asm	mov		eax, op1			\
+		__asm	fldcw	fpu.cw_mask_all		\
+		__asm	shl		eax, 4				\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	fxch	\
+		__asm	fclex						\
+		__asm	op		st(1), st(0)		\
+		__asm	fnstsw	new_sw				\
+		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	 \
+		__asm	fldcw	save_cw				\
+		}									\
+		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);
+
+// handles fprem,fprem1,fscale
+#define FPUD_REMAINDER(op)			\
+		Bit16u new_sw;				\
+		__asm {						\
+		__asm	mov		eax, TOP	\
+		__asm	mov		ebx, eax	\
+		__asm	inc     ebx			\
+		__asm	and     ebx, 7		\
+		__asm	shl		ebx, 4		\
+		__asm	shl		eax, 4		\
+		__asm	fld		TBYTE PTR fpu.p_regs[ebx].m1	\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	fclex				\
+		__asm	op					\
+		__asm	fnstsw	new_sw		\
+		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	fstp	st(0)		\
+		}							\
+		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);
+
+// handles fcom,fucom
+#define FPUD_COMPARE(op)			\
+		Bit16u new_sw;				\
+		__asm {						\
+		__asm	mov		ebx, op2	\
+		__asm	mov		eax, op1	\
+		__asm	shl		ebx, 4		\
+		__asm	shl		eax, 4		\
+		__asm	fld		TBYTE PTR fpu.p_regs[ebx].m1	\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	clx					\
+		__asm	op					\
+		__asm	fnstsw	new_sw		\
+		}							\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
+
+#define FPUD_COMPARE_EA(op)			\
+		Bit16u new_sw;				\
+		__asm {						\
+		__asm	mov		eax, op1	\
+		__asm	shl		eax, 4		\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	clx					\
+		__asm	op					\
+		__asm	fnstsw	new_sw		\
+		}							\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
+
+// handles fxam,ftst
+#define FPUD_EXAMINE(op)			\
+		Bit16u new_sw;				\
+		__asm {						\
+		__asm	mov		eax, TOP	\
+		__asm	shl		eax, 4		\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	clx					\
+		__asm	op					\
+		__asm	fnstsw	new_sw		\
+		__asm	fstp	st(0)		\
+		}							\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
+
+// handles fpatan,fyl2xp1
+#ifdef WEAK_EXCEPTIONS
+#define FPUD_WITH_POP(op)			\
+		__asm {						\
+		__asm	mov		eax, TOP	\
+		__asm	mov		ebx, eax	\
+		__asm	inc     ebx			\
+		__asm	and     ebx, 7		\
+		__asm	shl		ebx, 4		\
+		__asm	shl		eax, 4		\
+		__asm	fld		TBYTE PTR fpu.p_regs[ebx].m1	\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	op					\
+		__asm	fstp	TBYTE PTR fpu.p_regs[ebx].m1	\
+		}							\
+		FPU_FPOP();
+#else
+#define FPUD_WITH_POP(op)			\
+		Bit16u new_sw;				\
+		__asm {						\
+		__asm	mov		eax, TOP	\
+		__asm	mov		ebx, eax	\
+		__asm	inc     ebx			\
+		__asm	and     ebx, 7		\
+		__asm	shl		ebx, 4		\
+		__asm	shl		eax, 4		\
+		__asm	fld		TBYTE PTR fpu.p_regs[ebx].m1	\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	fclex				\
+		__asm	op					\
+		__asm	fnstsw	new_sw		\
+		__asm	fstp	TBYTE PTR fpu.p_regs[ebx].m1	\
+		}								\
+		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);	\
+		FPU_FPOP();
+#endif
+
+// handles fyl2x
+#ifdef WEAK_EXCEPTIONS
+#define FPUD_FYL2X(op)				\
+		__asm {						\
+		__asm	mov		eax, TOP	\
+		__asm	mov		ebx, eax	\
+		__asm	inc     ebx			\
+		__asm	and     ebx, 7		\
+		__asm	shl		ebx, 4		\
+		__asm	shl		eax, 4		\
+		__asm	fld		TBYTE PTR fpu.p_regs[ebx].m1	\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	op					\
+		__asm	fstp	TBYTE PTR fpu.p_regs[ebx].m1	\
+		}								\
+		FPU_FPOP();
+#else
+#define FPUD_FYL2X(op)				\
+		Bit16u new_sw;				\
+		__asm {						\
+		__asm	mov		eax, TOP	\
+		__asm	mov		ebx, eax	\
+		__asm	inc     ebx			\
+		__asm	and     ebx, 7		\
+		__asm	shl		ebx, 4		\
+		__asm	shl		eax, 4		\
+		__asm	fld		TBYTE PTR fpu.p_regs[ebx].m1	\
+		__asm	fld		TBYTE PTR fpu.p_regs[eax].m1	\
+		__asm	fclex				\
+		__asm	op					\
+		__asm	fnstsw	new_sw		\
+		__asm	fstp	TBYTE PTR fpu.p_regs[ebx].m1	\
+		}								\
+		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);	\
+		FPU_FPOP();
+#endif
+
+// load math constants
+#define FPUD_LOAD_CONST(op)		\
+		FPU_PREP_PUSH();			\
+		__asm {						\
+		__asm	mov		eax, TOP	\
+		__asm	shl		eax, 4		\
+		__asm	clx					\
+		__asm	op					\
+		__asm	fstp	TBYTE PTR fpu.p_regs[eax].m1	\
+		}							\
+
+#else
+
+// !defined _MSC_VER
+
+#ifdef WEAK_EXCEPTIONS
+#define clx
+#else
+#define clx "fclex"
+#endif
+
+#ifdef WEAK_EXCEPTIONS
+#define FPUD_LOAD(op,szI,szA)				\
+		__asm__ volatile (					\
+			#op #szA "	%1				\n"	\
+			"fstpt		%0				"	\
+			:	"=m" (fpu.p_regs[store_to])	\
+			:	"m" (fpu.p_regs[8])			\
+		);
+#else
+#define FPUD_LOAD(op,szI,szA)				\
+		Bit16u new_sw;						\
+		__asm__ volatile (					\
+			"fclex						\n"	\
+			#op #szA "	%2				\n"	\
+			"fnstsw		%0				\n"	\
+			"fstpt		%1				"	\
+			:	"=&am" (new_sw), "=m" (fpu.p_regs[store_to])		\
+			:	"m" (fpu.p_regs[8])			\
+		);									\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
+#endif
+
+#ifdef WEAK_EXCEPTIONS
+#define FPUD_LOAD_EA(op,szI,szA)			\
+		__asm__ volatile (					\
+			#op #szA "	%0				\n"	\
+			:								\
+			:	"m" (fpu.p_regs[8])			\
+		);
+#else
+#define FPUD_LOAD_EA(op,szI,szA)			\
+		Bit16u new_sw;						\
+		__asm__ volatile (					\
+			"fclex						\n"	\
+			#op #szA "	%1				\n"	\
+			"fnstsw		%0				\n"	\
+			:	"=&am" (new_sw)				\
+			:	"m" (fpu.p_regs[8])			\
+			:								\
+		);									\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
+#endif
+
+#ifdef WEAK_EXCEPTIONS
+#define FPUD_STORE(op,szI,szA)				\
+		Bit16u save_cw;						\
+		__asm__ volatile (					\
+			"fnstcw		%0				\n"	\
+			"fldcw		%3				\n"	\
+			"fldt		%2				\n"	\
+			#op #szA "	%1				\n"	\
+			"fldcw		%0				"	\
+			:	"=m" (save_cw), "=m" (fpu.p_regs[8])	\
+			:	"m" (fpu.p_regs[TOP]), "m" (fpu.cw_mask_all)		\
+		);
+#else
+#define FPUD_STORE(op,szI,szA)				\
+		Bit16u new_sw,save_cw;				\
+		__asm__ volatile (					\
+			"fnstcw		%1				\n"	\
+			"fldcw		%4				\n"	\
+			"fldt		%3				\n"	\
+			"fclex 						\n"	\
+			#op #szA "	%2				\n"	\
+			"fnstsw		%0				\n"	\
+			"fldcw		%1				"	\
+			:	"=&am" (new_sw), "=m" (save_cw), "=m" (fpu.p_regs[8])	\
+			:	"m" (fpu.p_regs[TOP]), "m" (fpu.cw_mask_all)			\
+		);									\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
+#endif
+
+// handles fsin,fcos,f2xm1,fchs,fabs
+#define FPUD_TRIG(op)						\
+		Bit16u new_sw;						\
+		__asm__ volatile (					\
+			"fldt		%1				\n"	\
+			clx" 						\n"	\
+			#op" 						\n"	\
+			"fnstsw		%0				\n"	\
+			"fstpt		%1				"	\
+			:	"=&am" (new_sw), "+m" (fpu.p_regs[TOP])		\
+		);									\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
+
+// handles fsincos
+#define FPUD_SINCOS()					\
+		Bit16u new_sw;						\
+		__asm__ volatile (					\
+			"fldt		%1				\n"	\
+			clx" 						\n"	\
+			"fsincos					\n"	\
+			"fnstsw		%0				\n"	\
+			"fstpt		%2				\n"	\
+			"movw		%0, %%ax		\n"	\
+			"sahf						\n"	\
+			"jp			1f				\n"	\
+			"fstpt		%1				\n"	\
+			"1:							"	\
+			:	"=m" (new_sw), "+m" (fpu.p_regs[TOP]),	\
+				"=m" (fpu.p_regs[(TOP-1)&7])			\
+			:								\
+			:	"ax", "cc"					\
+		);									\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);		\
+		if ((new_sw&0x0400)==0) FPU_PREP_PUSH();
+
+// handles fptan
+#define FPUD_PTAN()						\
+		Bit16u new_sw;						\
+		__asm__ volatile (					\
+			"fldt		%1				\n"	\
+			clx" 						\n"	\
+			"fptan 						\n"	\
+			"fnstsw		%0				\n"	\
+			"fstpt		%2				\n"	\
+			"movw		%0, %%ax		\n"	\
+			"sahf						\n"	\
+			"jp			1f				\n"	\
+			"fstpt		%1				\n"	\
+			"1:							"	\
+			:	"=m" (new_sw), "+m" (fpu.p_regs[TOP]),	\
+				"=m" (fpu.p_regs[(TOP-1)&7])			\
+			:								\
+			:	"ax", "cc"					\
+		);									\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);		\
+		if ((new_sw&0x0400)==0) FPU_PREP_PUSH();
+
+// handles fxtract
+#ifdef WEAK_EXCEPTIONS
+#define FPUD_XTRACT						\
+		__asm__ volatile (					\
+			"fldt		%0				\n"	\
+			"fxtract					\n"	\
+			"fstpt		%1				\n"	\
+			"fstpt		%0				"	\
+			:	"+m" (fpu.p_regs[TOP]), "=m" (fpu.p_regs[(TOP-1)&7])	\
+		);									\
+		FPU_PREP_PUSH();
+#else
+#define FPUD_XTRACT						\
+		Bit16u new_sw;						\
+		__asm__ volatile (					\
+			"fldt		%1				\n"	\
+			"fclex						\n"	\
+			"fxtract					\n"	\
+			"fnstsw		%0				\n"	\
+			"fstpt		%2				\n"	\
+			"fstpt		%1				"	\
+			:	"=&am" (new_sw), "+m" (fpu.p_regs[TOP]),	\
+				"=m" (fpu.p_regs[(TOP-1)&7])			\
+		);									\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);		\
+		FPU_PREP_PUSH();
+#endif
+
+// handles fadd,fmul,fsub,fsubr
+#ifdef WEAK_EXCEPTIONS
+#define FPUD_ARITH1(op)						\
+		Bit16u save_cw;						\
+		__asm__ volatile (					\
+			"fnstcw		%0				\n"	\
+			"fldcw		%3				\n"	\
+			"fldt		%2				\n"	\
+			"fldt		%1				\n"	\
+			#op"						\n"	\
+			"fstpt		%1				\n"	\
+			"fldcw		%0				"	\
+			:	"=m" (save_cw), "+m" (fpu.p_regs[op1])				\
+			:	"m" (fpu.p_regs[op2]), "m" (fpu.cw_mask_all)		\
+		);
+#else
+#define FPUD_ARITH1(op)						\
+		Bit16u new_sw,save_cw;				\
+		__asm__ volatile (					\
+			"fnstcw		%1				\n"	\
+			"fldcw		%4				\n"	\
+			"fldt		%3				\n"	\
+			"fldt		%2				\n"	\
+			"fclex 						\n"	\
+			#op"						\n"	\
+			"fnstsw		%0				\n"	\
+			"fstpt		%2				\n"	\
+			"fldcw		%1				"	\
+			:	"=&am" (new_sw), "=m" (save_cw), "+m" (fpu.p_regs[op1])	\
+			:	"m" (fpu.p_regs[op2]), "m" (fpu.cw_mask_all)		\
+		);									\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
+#endif
+
+// handles fadd,fmul,fsub,fsubr
+#ifdef WEAK_EXCEPTIONS
+#define FPUD_ARITH1_EA(op)					\
+		Bit16u save_cw;						\
+		__asm__ volatile (					\
+			"fnstcw		%0				\n"	\
+			"fldcw		%2				\n"	\
+			"fldt		%1				\n"	\
+			#op"						\n"	\
+			"fstpt		%1				\n"	\
+			"fldcw		%0				"	\
+			:	"=m" (save_cw), "+m" (fpu.p_regs[op1])		\
+			:	"m" (fpu.cw_mask_all)		\
+		);
+#else
+#define FPUD_ARITH1_EA(op)					\
+		Bit16u new_sw,save_cw;				\
+		__asm__ volatile (					\
+			"fnstcw		%1				\n"	\
+			"fldcw		%3				\n"	\
+			"fldt		%2				\n"	\
+			"fclex 						\n"	\
+			#op"						\n"	\
+			"fnstsw		%0				\n"	\
+			"fstpt		%2				\n"	\
+			"fldcw		%1				"	\
+			:	"=&am" (new_sw), "=m" (save_cw), "+m" (fpu.p_regs[op1])	\
+			:	"m" (fpu.cw_mask_all)		\
+		);									\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
+#endif
+
+// handles fsqrt,frndint
+#ifdef WEAK_EXCEPTIONS
+#define FPUD_ARITH2(op)						\
+		Bit16u save_cw;						\
+		__asm__ volatile (					\
+			"fnstcw		%0				\n"	\
+			"fldcw		%2				\n"	\
+			"fldt		%1				\n"	\
+			#op" 						\n"	\
+			"fstpt		%1				\n"	\
+			"fldcw		%0				"	\
+			:	"=m" (save_cw), "+m" (fpu.p_regs[TOP])		\
+			:	"m" (fpu.cw_mask_all)		\
+		);
+#else
+#define FPUD_ARITH2(op)						\
+		Bit16u new_sw,save_cw;				\
+		__asm__ volatile (					\
+			"fnstcw		%1				\n"	\
+			"fldcw		%3				\n"	\
+			"fldt		%2				\n"	\
+			"fclex 						\n"	\
+			#op" 						\n"	\
+			"fnstsw		%0				\n"	\
+			"fstpt		%2				\n"	\
+			"fldcw		%1				"	\
+			:	"=&am" (new_sw), "=m" (save_cw), "+m" (fpu.p_regs[TOP])	\
+			:	"m" (fpu.cw_mask_all)		\
+		);										\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
+#endif
+
+// handles fdiv,fdivr
+// (This is identical to FPUD_ARITH1 but without a WEAK_EXCEPTIONS variant)
+#define FPUD_ARITH3(op)						\
+		Bit16u new_sw,save_cw;				\
+		__asm__ volatile (					\
+			"fnstcw		%1				\n"	\
+			"fldcw		%4				\n"	\
+			"fldt		%3				\n"	\
+			"fldt		%2				\n"	\
+			"fclex 						\n"	\
+			#op"						\n"	\
+			"fnstsw		%0				\n"	\
+			"fstpt		%2				\n"	\
+			"fldcw		%1				"	\
+			:	"=&am" (new_sw), "=m" (save_cw), "+m" (fpu.p_regs[op1])	\
+			:	"m" (fpu.p_regs[op2]), "m" (fpu.cw_mask_all)		\
+		);									\
+		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);
+
+// handles fdiv,fdivr
+// (This is identical to FPUD_ARITH1_EA but without a WEAK_EXCEPTIONS variant)
+#define FPUD_ARITH3_EA(op)					\
+		Bit16u new_sw,save_cw;				\
+		__asm__ volatile (					\
+			"fnstcw		%1				\n"	\
+			"fldcw		%3				\n"	\
+			"fldt		%2				\n"	\
+			"fclex 						\n"	\
+			#op"						\n"	\
+			"fnstsw		%0				\n"	\
+			"fstpt		%2				\n"	\
+			"fldcw		%1				"	\
+			:	"=&am" (new_sw), "=m" (save_cw), "+m" (fpu.p_regs[op1])	\
+			:	"m" (fpu.cw_mask_all)		\
+		);									\
+		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);
+
+// handles fprem,fprem1,fscale
+#define FPUD_REMAINDER(op)					\
+		Bit16u new_sw;						\
+		__asm__ volatile (					\
+			"fldt		%2				\n"	\
+			"fldt		%1				\n"	\
+			"fclex						\n"	\
+			#op" 						\n"	\
+			"fnstsw		%0				\n"	\
+			"fstpt		%1				\n"	\
+			"fstp		%%st(0)			"	\
+			:	"=&am" (new_sw), "+m" (fpu.p_regs[TOP])	\
+			:	"m" (fpu.p_regs[(TOP+1)&7])				\
+		);									\
+		fpu.sw=(new_sw&0xffbf)|(fpu.sw&0x80ff);
+
+// handles fcom,fucom
+#define FPUD_COMPARE(op)					\
+		Bit16u new_sw;						\
+		__asm__ volatile (					\
+			"fldt		%2				\n"	\
+			"fldt		%1				\n"	\
+			clx" 						\n"	\
+			#op" 						\n"	\
+			"fnstsw		%0				"	\
+			:	"=&am" (new_sw)				\
+			:	"m" (fpu.p_regs[op1]), "m" (fpu.p_regs[op2])	\
+		);									\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
+
+// handles fcom,fucom
+#define FPUD_COMPARE_EA(op)					\
+		Bit16u new_sw;						\
+		__asm__ volatile (					\
+			"fldt		%1				\n"	\
+			clx" 						\n"	\
+			#op" 						\n"	\
+			"fnstsw		%0				"	\
+			:	"=&am" (new_sw)				\
+			:	"m" (fpu.p_regs[op1])		\
+		);									\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
+
+// handles fxam,ftst
+#define FPUD_EXAMINE(op)					\
+		Bit16u new_sw;						\
+		__asm__ volatile (					\
+			"fldt		%1				\n"	\
+			clx" 						\n"	\
+			#op" 						\n"	\
+			"fnstsw		%0				\n"	\
+			"fstp		%%st(0)			"	\
+			:	"=&am" (new_sw)				\
+			:	"m" (fpu.p_regs[TOP])		\
+		);									\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);
+
+// handles fpatan,fyl2xp1
+#ifdef WEAK_EXCEPTIONS
+#define FPUD_WITH_POP(op)					\
+		__asm__ volatile (					\
+			"fldt		%0				\n"	\
+			"fldt		%1				\n"	\
+			#op" 						\n"	\
+			"fstpt		%0				\n"	\
+			:	"+m" (fpu.p_regs[(TOP+1)&7])	\
+			:	"m" (fpu.p_regs[TOP])		\
+		);									\
+		FPU_FPOP();
+#else
+#define FPUD_WITH_POP(op)					\
+		Bit16u new_sw;						\
+		__asm__ volatile (					\
+			"fldt		%1				\n"	\
+			"fldt		%2				\n"	\
+			"fclex						\n"	\
+			#op" 						\n"	\
+			"fnstsw		%0				\n"	\
+			"fstpt		%1				\n"	\
+			:	"=&am" (new_sw), "+m" (fpu.p_regs[(TOP+1)&7])		\
+			:	"m" (fpu.p_regs[TOP])		\
+		);									\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);		\
+		FPU_FPOP();
+#endif
+
+// handles fyl2x
+#ifdef WEAK_EXCEPTIONS
+#define FPUD_FYL2X(op)						\
+		__asm__ volatile (					\
+			"fldt		%0				\n"	\
+			"fldt		%1				\n"	\
+			#op" 						\n"	\
+			"fstpt		%0				\n"	\
+			:	"+m" (fpu.p_regs[(TOP+1)&7])	\
+			:	"m" (fpu.p_regs[TOP]) 		\
+		);									\
+		FPU_FPOP();
+#else
+#define FPUD_FYL2X(op)						\
+		Bit16u new_sw;						\
+		__asm__ volatile (					\
+			"fldt		%1				\n"	\
+			"fldt		%2				\n"	\
+			"fclex						\n"	\
+			#op" 						\n"	\
+			"fnstsw		%0				\n"	\
+			"fstpt		%1				\n"	\
+			:	"=&am" (new_sw), "+m" (fpu.p_regs[(TOP+1)&7])		\
+			:	"m" (fpu.p_regs[TOP]) 		\
+		);									\
+		fpu.sw=(new_sw&exc_mask)|(fpu.sw&0x80ff);		\
+		FPU_FPOP();
+#endif
+
+// load math constants
+#define FPUD_LOAD_CONST(op)				\
+		FPU_PREP_PUSH();					\
+		__asm__ volatile (					\
+			clx" 						\n"	\
+			#op" 						\n"	\
+			"fstpt		%0				\n"	\
+			:	"=m" (fpu.p_regs[TOP])		\
+		);
+
+#endif
+
+#ifdef WEAK_EXCEPTIONS
+const Bit16u exc_mask=0x7f00;
+#else
+const Bit16u exc_mask=0xffbf;
+#endif
+
+static void FPU_FINIT(void) {
+	FPU_SetCW(0x37F);
+	fpu.sw=0;
+	TOP=FPU_GET_TOP();
+	fpu.tags[0]=TAG_Empty;
+	fpu.tags[1]=TAG_Empty;
+	fpu.tags[2]=TAG_Empty;
+	fpu.tags[3]=TAG_Empty;
+	fpu.tags[4]=TAG_Empty;
+	fpu.tags[5]=TAG_Empty;
+	fpu.tags[6]=TAG_Empty;
+	fpu.tags[7]=TAG_Empty;
+	fpu.tags[8]=TAG_Valid; // is only used by us
+}
+
+static void FPU_FCLEX(void){
+	fpu.sw&=0x7f00;				//should clear exceptions
+}
+
+static void FPU_FNOP(void){
+}
+
+static void FPU_PREP_PUSH(void){
+	TOP = (TOP - 1) &7;
+#if DB_FPU_STACK_CHECK_PUSH > DB_FPU_STACK_CHECK_NONE
+	if (GCC_UNLIKELY(fpu.tags[TOP] != TAG_Empty)) {
+#if DB_FPU_STACK_CHECK_PUSH == DB_FPU_STACK_CHECK_EXIT
+		E_Exit("FPU stack overflow");
+#else
+		if (fpu.cw&1) { // Masked ?
+			fpu.sw |= 0x1; //Invalid Operation
+			fpu.sw |= 0x40; //Stack Fault
+			FPU_SET_C1(1); //Register is used.
+			//No need to set 0x80 as the exception is masked.
+			LOG(LOG_FPU,LOG_ERROR)("Masked stack overflow encountered!");
+		} else {
+			E_Exit("FPU stack overflow"); //Exit as this is bad
+		}
+#endif
+	}
+#endif
+	fpu.tags[TOP] = TAG_Valid;
+}
+
+static void FPU_FPOP(void){
+#if DB_FPU_STACK_CHECK_POP > DB_FPU_STACK_CHECK_NONE
+	if (GCC_UNLIKELY(fpu.tags[TOP] == TAG_Empty)) {
+#if DB_FPU_STACK_CHECK_POP == DB_FPU_STACK_CHECK_EXIT
+		E_Exit("FPU stack underflow");
+#else
+		if (fpu.cw&1) { // Masked ?
+			fpu.sw |= 0x1; //Invalid Operation
+			fpu.sw |= 0x40; //Stack Fault
+			FPU_SET_C1(0); //Register is free.
+			//No need to set 0x80 as the exception is masked.
+			LOG(LOG_FPU,LOG_ERROR)("Masked stack underflow encountered!");
+		} else {
+			LOG_MSG("Unmasked Stack underflow!");
+		}
+#endif
+	}
+#endif
+	fpu.tags[TOP] = TAG_Empty;
+	TOP = ((TOP+1)&7);
+}
+
+static void FPU_FLD_F32(PhysPt addr,Bitu store_to) {
+	fpu.p_regs[8].m1 = mem_readd(addr);
+	FPUD_LOAD(fld,DWORD,s)
+}
+
+static void FPU_FLD_F32_EA(PhysPt addr) {
+	fpu.p_regs[8].m1 = mem_readd(addr);
+	FPUD_LOAD_EA(fld,DWORD,s)
+}
+
+static void FPU_FLD_F64(PhysPt addr,Bitu store_to) {
+	fpu.p_regs[8].m1 = mem_readd(addr);
+	fpu.p_regs[8].m2 = mem_readd(addr+4);
+	FPUD_LOAD(fld,QWORD,l)
+}
+
+static void FPU_FLD_F64_EA(PhysPt addr) {
+	fpu.p_regs[8].m1 = mem_readd(addr);
+	fpu.p_regs[8].m2 = mem_readd(addr+4);
+	FPUD_LOAD_EA(fld,QWORD,l)
+}
+
+static void FPU_FLD_F80(PhysPt addr) {
+	fpu.p_regs[TOP].m1 = mem_readd(addr);
+	fpu.p_regs[TOP].m2 = mem_readd(addr+4);
+	fpu.p_regs[TOP].m3 = mem_readw(addr+8);
+	FPU_SET_C1(0);
+}
+
+static void FPU_FLD_I16(PhysPt addr,Bitu store_to) {
+	fpu.p_regs[8].m1 = (Bit32u)mem_readw(addr);
+	FPUD_LOAD(fild,WORD,s)
+}
+
+static void FPU_FLD_I16_EA(PhysPt addr) {
+	fpu.p_regs[8].m1 = (Bit32u)mem_readw(addr);
+	FPUD_LOAD_EA(fild,WORD,s)
+}
+
+static void FPU_FLD_I32(PhysPt addr,Bitu store_to) {
+	fpu.p_regs[8].m1 = mem_readd(addr);
+	FPUD_LOAD(fild,DWORD,l)
+}
+
+static void FPU_FLD_I32_EA(PhysPt addr) {
+	fpu.p_regs[8].m1 = mem_readd(addr);
+	FPUD_LOAD_EA(fild,DWORD,l)
+}
+
+static void FPU_FLD_I64(PhysPt addr,Bitu store_to) {
+	fpu.p_regs[8].m1 = mem_readd(addr);
+	fpu.p_regs[8].m2 = mem_readd(addr+4);
+	FPUD_LOAD(fild,QWORD,q)
+}
+
+static void FPU_FBLD(PhysPt addr,Bitu store_to) {
+	fpu.p_regs[8].m1 = mem_readd(addr);
+	fpu.p_regs[8].m2 = mem_readd(addr+4);
+	fpu.p_regs[8].m3 = mem_readw(addr+8);
+	FPUD_LOAD(fbld,TBYTE,)
+}
+
+static void FPU_FST_F32(PhysPt addr) {
+	FPUD_STORE(fstp,DWORD,s)
+	mem_writed(addr,fpu.p_regs[8].m1);
+}
+
+static void FPU_FST_F64(PhysPt addr) {
+	FPUD_STORE(fstp,QWORD,l)
+	mem_writed(addr,fpu.p_regs[8].m1);
+	mem_writed(addr+4,fpu.p_regs[8].m2);
+}
+
+static void FPU_FST_F80(PhysPt addr) {
+	mem_writed(addr,fpu.p_regs[TOP].m1);
+	mem_writed(addr+4,fpu.p_regs[TOP].m2);
+	mem_writew(addr+8,fpu.p_regs[TOP].m3);
+	FPU_SET_C1(0);
+}
+
+static void FPU_FST_I16(PhysPt addr) {
+	FPUD_STORE(fistp,WORD,s)
+	mem_writew(addr,(Bit16u)fpu.p_regs[8].m1);
+}
+
+static void FPU_FST_I32(PhysPt addr) {
+	FPUD_STORE(fistp,DWORD,l)
+	mem_writed(addr,fpu.p_regs[8].m1);
+}
+
+static void FPU_FST_I64(PhysPt addr) {
+	FPUD_STORE(fistp,QWORD,q)
+	mem_writed(addr,fpu.p_regs[8].m1);
+	mem_writed(addr+4,fpu.p_regs[8].m2);
+}
+
+static void FPU_FBST(PhysPt addr) {
+	FPUD_STORE(fbstp,TBYTE,)
+	mem_writed(addr,fpu.p_regs[8].m1);
+	mem_writed(addr+4,fpu.p_regs[8].m2);
+	mem_writew(addr+8,fpu.p_regs[8].m3);
+}
+
+
+static void FPU_FSIN(void){
+	FPUD_TRIG(fsin)
+}
+
+static void FPU_FSINCOS(void){
+	FPUD_SINCOS()
+}
+
+static void FPU_FCOS(void){
+	FPUD_TRIG(fcos)
+}
+
+static void FPU_FSQRT(void){
+	FPUD_ARITH2(fsqrt)
+}
+
+static void FPU_FPATAN(void){
+	FPUD_WITH_POP(fpatan)
+}
+
+static void FPU_FPTAN(void){
+	FPUD_PTAN()
+}
+
+
+static void FPU_FADD(Bitu op1, Bitu op2){
+	FPUD_ARITH1(faddp)
+}
+
+static void FPU_FADD_EA(Bitu op1){
+	FPUD_ARITH1_EA(faddp)
+}
+
+static void FPU_FDIV(Bitu op1, Bitu op2){
+	FPUD_ARITH3(fdivp)
+}
+
+static void FPU_FDIV_EA(Bitu op1){
+	FPUD_ARITH3_EA(fdivp)
+}
+
+static void FPU_FDIVR(Bitu op1, Bitu op2){
+	FPUD_ARITH3(fdivrp)
+}
+
+static void FPU_FDIVR_EA(Bitu op1){
+	FPUD_ARITH3_EA(fdivrp)
+}
+
+static void FPU_FMUL(Bitu op1, Bitu op2){
+	FPUD_ARITH1(fmulp)
+}
+
+static void FPU_FMUL_EA(Bitu op1){
+	FPUD_ARITH1_EA(fmulp)
+}
+
+static void FPU_FSUB(Bitu op1, Bitu op2){
+	FPUD_ARITH1(fsubp)
+}
+
+static void FPU_FSUB_EA(Bitu op1){
+	FPUD_ARITH1_EA(fsubp)
+}
+
+static void FPU_FSUBR(Bitu op1, Bitu op2){
+	FPUD_ARITH1(fsubrp)
+}
+
+static void FPU_FSUBR_EA(Bitu op1){
+	FPUD_ARITH1_EA(fsubrp)
+}
+
+static void FPU_FXCH(Bitu stv, Bitu other){
+	FPU_Tag tag = fpu.tags[other];
+	fpu.tags[other] = fpu.tags[stv];
+	fpu.tags[stv] = tag;
+
+	Bit32u m1s = fpu.p_regs[other].m1;
+	Bit32u m2s = fpu.p_regs[other].m2;
+	Bit16u m3s = fpu.p_regs[other].m3;
+	fpu.p_regs[other].m1 = fpu.p_regs[stv].m1;
+	fpu.p_regs[other].m2 = fpu.p_regs[stv].m2;
+	fpu.p_regs[other].m3 = fpu.p_regs[stv].m3;
+	fpu.p_regs[stv].m1 = m1s;
+	fpu.p_regs[stv].m2 = m2s;
+	fpu.p_regs[stv].m3 = m3s;
+
+	FPU_SET_C1(0);
+}
+
+static void FPU_FST(Bitu stv, Bitu other){
+	fpu.tags[other] = fpu.tags[stv];
+
+	fpu.p_regs[other].m1 = fpu.p_regs[stv].m1;
+	fpu.p_regs[other].m2 = fpu.p_regs[stv].m2;
+	fpu.p_regs[other].m3 = fpu.p_regs[stv].m3;
+
+	FPU_SET_C1(0);
+}
+
+
+static void FPU_FCOM(Bitu op1, Bitu op2){
+	FPUD_COMPARE(fcompp)
+}
+
+static void FPU_FCOM_EA(Bitu op1){
+	FPUD_COMPARE_EA(fcompp)
+}
+
+static void FPU_FUCOM(Bitu op1, Bitu op2){
+	FPUD_COMPARE(fucompp)
+}
+
+static void FPU_FRNDINT(void){
+	FPUD_ARITH2(frndint)
+}
+
+static void FPU_FPREM(void){
+	FPUD_REMAINDER(fprem)
+}
+
+static void FPU_FPREM1(void){
+	FPUD_REMAINDER(fprem1)
+}
+
+static void FPU_FXAM(void){
+	FPUD_EXAMINE(fxam)
+	// handle empty registers (C1 set to sign in any way!)
+	if(fpu.tags[TOP] == TAG_Empty) {
+		FPU_SET_C3(1);FPU_SET_C2(0);FPU_SET_C0(1);
+		return;
+	}
+}
+
+static void FPU_F2XM1(void){
+	FPUD_TRIG(f2xm1)
+}
+
+static void FPU_FYL2X(void){
+	FPUD_FYL2X(fyl2x)
+}
+
+static void FPU_FYL2XP1(void){
+	FPUD_WITH_POP(fyl2xp1)
+}
+
+static void FPU_FSCALE(void){
+	FPUD_REMAINDER(fscale)
+}
+
+
+static void FPU_FSTENV(PhysPt addr){
+	FPU_SET_TOP(TOP);
+	if(!cpu.code.big) {
+		mem_writew(addr+0,static_cast<Bit16u>(fpu.cw));
+		mem_writew(addr+2,static_cast<Bit16u>(fpu.sw));
+		mem_writew(addr+4,static_cast<Bit16u>(FPU_GetTag()));
+	} else {
+		mem_writed(addr+0,static_cast<Bit32u>(fpu.cw));
+		mem_writed(addr+4,static_cast<Bit32u>(fpu.sw));
+		mem_writed(addr+8,static_cast<Bit32u>(FPU_GetTag()));
+	}
+}
+
+static void FPU_FLDENV(PhysPt addr){
+	Bit16u tag;
+	Bit32u tagbig;
+	Bitu cw;
+	if(!cpu.code.big) {
+		cw     = mem_readw(addr+0);
+		fpu.sw = mem_readw(addr+2);
+		tag    = mem_readw(addr+4);
+	} else {
+		cw     = mem_readd(addr+0);
+		fpu.sw = (Bit16u)mem_readd(addr+4);
+		tagbig = mem_readd(addr+8);
+		tag    = static_cast<Bit16u>(tagbig);
+	}
+	FPU_SetTag(tag);
+	FPU_SetCW(cw);
+	TOP=FPU_GET_TOP();
+}
+
+static void FPU_FSAVE(PhysPt addr){
+	FPU_FSTENV(addr);
+	Bitu start=(cpu.code.big?28:14);
+	for(Bitu i=0;i<8;i++){
+		mem_writed(addr+start,fpu.p_regs[STV(i)].m1);
+		mem_writed(addr+start+4,fpu.p_regs[STV(i)].m2);
+		mem_writew(addr+start+8,fpu.p_regs[STV(i)].m3);
+		start+=10;
+	}
+	FPU_FINIT();
+}
+
+static void FPU_FRSTOR(PhysPt addr){
+	FPU_FLDENV(addr);
+	Bitu start=(cpu.code.big?28:14);
+	for(Bitu i=0;i<8;i++){
+		fpu.p_regs[STV(i)].m1 = mem_readd(addr+start);
+		fpu.p_regs[STV(i)].m2 = mem_readd(addr+start+4);
+		fpu.p_regs[STV(i)].m3 = mem_readw(addr+start+8);
+		start+=10;
+	}
+}
+
+
+static void FPU_FXTRACT(void) {
+	FPUD_XTRACT
+}
+
+static void FPU_FCHS(void){
+	FPUD_TRIG(fchs)
+}
+
+static void FPU_FABS(void){
+	FPUD_TRIG(fabs)
+}
+
+static void FPU_FTST(void){
+	FPUD_EXAMINE(ftst)
+}
+
+static void FPU_FLD1(void){
+	FPUD_LOAD_CONST(fld1)
+}
+
+static void FPU_FLDL2T(void){
+	FPUD_LOAD_CONST(fldl2t)
+}
+
+static void FPU_FLDL2E(void){
+	FPUD_LOAD_CONST(fldl2e)
+}
+
+static void FPU_FLDPI(void){
+	FPUD_LOAD_CONST(fldpi)
+}
+
+static void FPU_FLDLG2(void){
+	FPUD_LOAD_CONST(fldlg2)
+}
+
+static void FPU_FLDLN2(void){
+	FPUD_LOAD_CONST(fldln2)
+}
+
+static void FPU_FLDZ(void){
+	FPUD_LOAD_CONST(fldz)
+	fpu.tags[TOP]=TAG_Zero;
+}
diff --git a/src/hardware/mixer.cpp b/src/hardware/mixer.cpp
index 5598acc1..cf5917db 100644
--- a/src/hardware/mixer.cpp
+++ b/src/hardware/mixer.cpp
@@ -18,11 +18,13 @@
 
 /* $Id: mixer.cpp,v 1.54 2009-09-05 11:10:04 qbix79 Exp $ */
 
-/* 
+/*
 	Remove the sdl code from here and have it handeld in the sdlmain.
 	That should call the mixer start from there or something.
 */
 
+#include "mixer.h"
+
 #include <string.h>
 #include <sys/types.h>
 #include <math.h>
@@ -269,7 +271,7 @@ thestart:
 
 void MixerChannel::AddStretched(Bitu len,Bit16s * data) {
 	if (done>=needed) {
-		LOG_MSG("Can't add, buffer full");	
+		LOG_MSG("Can't add, buffer full");
 		return;
 	}
 	Bitu outlen=needed-done;Bits diff;
@@ -357,7 +359,7 @@ void MixerChannel::FillUp(void) {
 
 extern bool ticksLocked;
 static inline bool Mixer_irq_important(void) {
-	/* In some states correct timing of the irqs is more important then 
+	/* In some states correct timing of the irqs is more important then
 	 * non stuttering audo */
 	return (ticksLocked || (CaptureState & (CAPTURE_WAVE|CAPTURE_VIDEO)));
 }
@@ -372,7 +374,7 @@ static void MIXER_MixData(Bitu needed) {
 	if (CaptureState & (CAPTURE_WAVE|CAPTURE_VIDEO)) {
 		Bit16s convert[1024][2];
 		Bitu added=needed-mixer.done;
-		if (added>1024) 
+		if (added>1024)
 			added=1024;
 		Bitu readpos=(mixer.pos+mixer.done)&MIXER_BUFMASK;
 		for (Bitu i=0;i<added;i++) {
@@ -473,7 +475,7 @@ static void MIXER_CallBack(void * userdata, Uint8 *stream, int len) {
 //		LOG_MSG("overflow run need %d, have %d, min %d", need, mixer.done, mixer.min_needed);
 		if (mixer.done > MIXER_BUFSIZE)
 			index_add = MIXER_BUFSIZE - 2*mixer.min_needed;
-		else 
+		else
 			index_add = mixer.done - 2*mixer.min_needed;
 		index_add = (index_add << MIXER_SHIFT) / need;
 		reduce = mixer.done - 2* mixer.min_needed;
@@ -484,7 +486,7 @@ static void MIXER_CallBack(void * userdata, Uint8 *stream, int len) {
 		if (chan->done>reduce) chan->done-=reduce;
 		else chan->done=0;
 	}
-   
+
 	// Reset mixer.tick_add when irqs are important
 	if( Mixer_irq_important() )
 		mixer.tick_add=(mixer.freq<< MIXER_SHIFT)/1000;
@@ -577,7 +579,7 @@ public:
 		//ShowVolume("MASTER",mixer.mastervol[0],mixer.mastervol[1]);
         ShowVolume("MASTER", boxer_masterVolume(BXLeftChannel), boxer_masterVolume(BXRightChannel));
         //--End of modifications
-		for (chan=mixer.channels;chan;chan=chan->next) 
+		for (chan=mixer.channels;chan;chan=chan->next)
 			ShowVolume(chan->name,chan->volmain[0],chan->volmain[1]);
 	}
 private:
@@ -590,7 +592,7 @@ private:
 
 	void ListMidi(){
 #if defined (WIN32)
-		unsigned int total = midiOutGetNumDevs();	
+		unsigned int total = midiOutGetNumDevs();
 		for(unsigned int i=0;i<total;i++) {
 			MIDIOUTCAPS mididev;
 			midiOutGetDevCaps(i, &mididev, sizeof(MIDIOUTCAPS));
@@ -638,7 +640,7 @@ void MIXER_Init(Section* sec) {
 	mixer.pos=0;
 	mixer.done=0;
 	memset(mixer.work,0,sizeof(mixer.work));
-	
+
     mixer.mastervol[0]=1.0f;
 	mixer.mastervol[1]=1.0f;
 
diff --git a/src/hardware/parport/printer_charmaps.cpp b/src/hardware/parport/printer_charmaps.cpp
index 3d136cff..c00b3c39 100644
--- a/src/hardware/parport/printer_charmaps.cpp
+++ b/src/hardware/parport/printer_charmaps.cpp
@@ -307,3 +307,17 @@ const Bit16u intCharSets[15][12] =
 	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
 	{0x0023, 0x0024, 0x00a7, 0x00c4, 0x0027, 0x0022, 0x00b6, 0x0060, 0x00a9, 0x00ae, 0x2020, 0x2122} // Legal
 };
+
+//--Added 2024-02-15 by Ismail Khatib
+uint16_t* boxer_PRINTER_get_charmap_for_codepage(uint16_t codepage)
+{
+	uint8_t i = 0;
+  while (charmap[i].codepage != 0) {
+	  if (charmap[i].codepage == codepage) {
+		  return (uint16_t*)charmap[i].map;
+		}
+	  i++;
+  }
+  return nullptr;
+}
+//--End of modifications
diff --git a/src/hardware/vga_draw.cpp b/src/hardware/vga_draw.cpp
index c8e3ef2e..e04bc751 100644
--- a/src/hardware/vga_draw.cpp
+++ b/src/hardware/vga_draw.cpp
@@ -87,8 +87,8 @@ static Bit8u * VGA_Draw_CGA16_Line(Bitu vidstart, Bitu line) {
 	Bit32u * draw=(Bit32u *)TempLine;
 	//Generate a temporary bitline to calculate the avarage
 	//over bit-2  bit-1  bit  bit+1.
-	//Combine this number with the current colour to get 
-	//an unigue index in the pallete. Or it with bit 7 as they are stored 
+	//Combine this number with the current colour to get
+	//an unigue index in the pallete. Or it with bit 7 as they are stored
 	//in the upperpart to keep them from interfering the regular cga stuff
 
 	for(Bitu x = 0; x < 640; x++)
@@ -106,6 +106,8 @@ static Bit8u * VGA_Draw_CGA16_Line(Bitu vidstart, Bitu line) {
 		temp4 = temp[i] + temp[i+1] + temp[i+2] + temp[i+3]; i++;
 
 		//--Modified 2011-04-19 by Alun Bestor to fix swapped pixel columns on PowerPC Macs
+		//--Commented 2021-01-09 by Ismail Khatib
+		/*
 		*draw++ = CFSwapInt32HostToLittle(0x80808080|(temp1|val1) |
 		          ((temp2|val1) << 8) |
 		          ((temp3|val1) <<16) |
@@ -118,6 +120,7 @@ static Bit8u * VGA_Draw_CGA16_Line(Bitu vidstart, Bitu line) {
 		          ((temp2|val2) << 8) |
 		          ((temp3|val2) <<16) |
 		          ((temp4|val2) <<24));
+		*/
 		//--End of modifications
 	}
 	return TempLine;
@@ -131,12 +134,15 @@ static Bit8u * VGA_Draw_4BPP_Line(Bitu vidstart, Bitu line) {
 		++vidstart;
 		Bitu val2 = base[vidstart & vga.tandy.addr_mask];
 		++vidstart;
-		
+
 		//--Modified 2011-04-19 by Alun Bestor to fix swapped pixel columns on PowerPC Macs
+		//--Commented 2021-01-09 by Ismail Khatib
+		/*
 		*draw++=CFSwapInt32HostToLittle((val1 & 0x0f) << 8  |
 				(val1 & 0xf0) >> 4  |
 				(val2 & 0x0f) << 24 |
 				(val2 & 0xf0) << 12);
+		*/
 		//--End of modifications
 	}
 	return TempLine;
@@ -148,12 +154,15 @@ static Bit8u * VGA_Draw_4BPP_Line_Double(Bitu vidstart, Bitu line) {
 	for (Bitu x=0;x<vga.draw.blocks;x++) {
 		Bitu val = base[vidstart & vga.tandy.addr_mask];
 		++vidstart;
-		
+
 		//--Modified 2011-04-19 by Alun Bestor to fix swapped pixel columns on PowerPC Macs
+		//--Commented 2021-01-09 by Ismail Khatib
+		/*
 		*draw++=CFSwapInt32HostToLittle((val & 0xf0) >> 4  |
 				(val & 0xf0) << 4  |
 				(val & 0x0f) << 16 |
 				(val & 0x0f) << 24);
+		*/
 		//--End of modifications
 	}
 	return TempLine;
@@ -237,7 +246,7 @@ static Bit8u * VGA_Draw_VGA_Line_HWMouse( Bitu vidstart, Bitu /*line*/) {
 
 	Bitu lineat = (vidstart-(vga.config.real_start<<2)) / vga.draw.width;
 	if ((vga.s3.hgc.posx >= vga.draw.width) ||
-		(lineat < vga.s3.hgc.originy) || 
+		(lineat < vga.s3.hgc.originy) ||
 		(lineat > (vga.s3.hgc.originy + (63U-vga.s3.hgc.posy))) ) {
 		// the mouse cursor *pattern* is not on this line
 		return &vga.mem.linear[ vidstart ];
@@ -249,7 +258,7 @@ static Bit8u * VGA_Draw_VGA_Line_HWMouse( Bitu vidstart, Bitu /*line*/) {
 		// AB bits corresponding to a cursor pixel. The whole map is 8kB in size.
 		memcpy(TempLine, &vga.mem.linear[ vidstart ], vga.draw.width);
 		// the index of the bit inside the cursor bitmap we start at:
-		Bitu sourceStartBit = ((lineat - vga.s3.hgc.originy) + vga.s3.hgc.posy)*64 + vga.s3.hgc.posx; 
+		Bitu sourceStartBit = ((lineat - vga.s3.hgc.originy) + vga.s3.hgc.posy)*64 + vga.s3.hgc.posx;
 		// convert to video memory addr and bit index
 		// start adjusted to the pattern structure (thus shift address by 2 instead of 3)
 		// Need to get rid of the third bit, so "/8 *2" becomes ">> 2 & ~1"
@@ -287,12 +296,12 @@ static Bit8u * VGA_Draw_LIN16_Line_HWMouse(Bitu vidstart, Bitu /*line*/) {
 
 	Bitu lineat = ((vidstart-(vga.config.real_start<<2)) >> 1) / vga.draw.width;
 	if ((vga.s3.hgc.posx >= vga.draw.width) ||
-		(lineat < vga.s3.hgc.originy) || 
+		(lineat < vga.s3.hgc.originy) ||
 		(lineat > (vga.s3.hgc.originy + (63U-vga.s3.hgc.posy))) ) {
 		return &vga.mem.linear[vidstart];
 	} else {
 		memcpy(TempLine, &vga.mem.linear[ vidstart ], vga.draw.width*2);
-		Bitu sourceStartBit = ((lineat - vga.s3.hgc.originy) + vga.s3.hgc.posy)*64 + vga.s3.hgc.posx; 
+		Bitu sourceStartBit = ((lineat - vga.s3.hgc.originy) + vga.s3.hgc.posy)*64 + vga.s3.hgc.posx;
  		Bitu cursorMemStart = ((sourceStartBit >> 2)& ~1) + (((Bit32u)vga.s3.hgc.startaddr) << 10);
 		Bitu cursorStartBit = sourceStartBit & 0x7;
 		if (cursorMemStart & 0x2) cursorMemStart--;
@@ -310,7 +319,7 @@ static Bit8u * VGA_Draw_LIN16_Line_HWMouse(Bitu vidstart, Bitu /*line*/) {
 					if (bitsB&bit) *xat ^= ~0U;
 					//else Transparent
 				} else if (bitsB&bit) {
-					// Source as well as destination are Bit8u arrays, 
+					// Source as well as destination are Bit8u arrays,
 					// so this should work out endian-wise?
 					*xat = *(Bit16u*)vga.s3.hgc.forestack;
 				} else {
@@ -329,12 +338,12 @@ static Bit8u * VGA_Draw_LIN32_Line_HWMouse(Bitu vidstart, Bitu /*line*/) {
 
 	Bitu lineat = ((vidstart-(vga.config.real_start<<2)) >> 2) / vga.draw.width;
 	if ((vga.s3.hgc.posx >= vga.draw.width) ||
-		(lineat < vga.s3.hgc.originy) || 
+		(lineat < vga.s3.hgc.originy) ||
 		(lineat > (vga.s3.hgc.originy + (63U-vga.s3.hgc.posy))) ) {
 		return &vga.mem.linear[ vidstart ];
 	} else {
 		memcpy(TempLine, &vga.mem.linear[ vidstart ], vga.draw.width*4);
-		Bitu sourceStartBit = ((lineat - vga.s3.hgc.originy) + vga.s3.hgc.posy)*64 + vga.s3.hgc.posx; 
+		Bitu sourceStartBit = ((lineat - vga.s3.hgc.originy) + vga.s3.hgc.posy)*64 + vga.s3.hgc.posx;
 		Bitu cursorMemStart = ((sourceStartBit >> 2)& ~1) + (((Bit32u)vga.s3.hgc.startaddr) << 10);
 		Bitu cursorStartBit = sourceStartBit & 0x7;
 		if (cursorMemStart & 0x2) cursorMemStart--;
@@ -472,7 +481,7 @@ static Bit8u * VGA_TEXT_Xlat16_Draw_Line(Bitu vidstart, Bitu line) {
 		Bit32u mask2=TXT_Font_Table[font&0xf] & FontMask[col >> 7];
 		Bit32u fg=TXT_FG_Table[col&0xf];
 		Bit32u bg=TXT_BG_Table[col>>4];
-		
+
 		mask1=(fg&mask1) | (bg&~mask1);
 		mask2=(fg&mask2) | (bg&~mask2);
 
@@ -597,8 +606,8 @@ static Bit8u * VGA_TEXT_Xlat16_Draw_Line_9(Bitu vidstart, Bitu line) {
 		}
 		Bit16u lastval=vga.dac.xlat16[font&mask?fg:bg];
 		*draw++=lastval;
-		*draw++=(((vga.attr.mode_control&0x04) && ((chr<0xc0) || (chr>0xdf))) && 
-			!(underline && ((col&0x07) == 0x01))) ? 
+		*draw++=(((vga.attr.mode_control&0x04) && ((chr<0xc0) || (chr>0xdf))) &&
+			!(underline && ((col&0x07) == 0x01))) ?
 			(vga.dac.xlat16[bg]) : lastval;
 		if (pel_pan) {
 			if (underline && ((col&0x07) == 0x01)) font=0xff;
@@ -615,7 +624,7 @@ static Bit8u * VGA_TEXT_Xlat16_Draw_Line_9(Bitu vidstart, Bitu line) {
 		for(int i = 0; i < 8; i++) {
 			*draw++ = vga.dac.xlat16[fg];
 		}
-		//if(underline && ((col&0x07) == 0x01)) 
+		//if(underline && ((col&0x07) == 0x01))
 		//	*draw = vga.dac.xlat16[fg];
 	}
 skip_cursor:
@@ -659,7 +668,7 @@ static void VGA_DrawSingleLine(Bitu /*blah*/) {
 		memset(TempLine, 0, sizeof(TempLine));
 		RENDER_DrawLine(TempLine);
 	} else {
-		Bit8u * data=VGA_DrawLine( vga.draw.address, vga.draw.address_line );	
+		Bit8u * data=VGA_DrawLine( vga.draw.address, vga.draw.address_line );
 		RENDER_DrawLine(data);
 	}
 
@@ -760,7 +769,7 @@ static void VGA_DisplayStartLatch(Bitu /*val*/) {
 	vga.config.real_start=vga.config.display_start & (vga.vmemwrap-1);
 	vga.draw.bytes_skip = vga.config.bytes_skip;
 }
- 
+
 static void VGA_PanningLatch(Bitu /*val*/) {
 	vga.draw.panning = vga.config.pel_panning;
 }
@@ -768,7 +777,7 @@ static void VGA_PanningLatch(Bitu /*val*/) {
 static void VGA_VerticalTimer(Bitu /*val*/) {
 	vga.draw.delay.framestart = PIC_FullIndex();
 	PIC_AddEvent( VGA_VerticalTimer, (float)vga.draw.delay.vtotal );
-	
+
 	switch(machine) {
 	case MCH_PCJR:
 	case MCH_TANDY:
@@ -903,7 +912,7 @@ static void VGA_VerticalTimer(Bitu /*val*/) {
 		break;
 	case LINE:
 		if (GCC_UNLIKELY(vga.draw.lines_done < vga.draw.lines_total)) {
-			LOG(LOG_VGAMISC,LOG_NORMAL)( "Lines left: %d", 
+			LOG(LOG_VGAMISC,LOG_NORMAL)( "Lines left: %d",
 				vga.draw.lines_total-vga.draw.lines_done);
 			PIC_RemoveEvents(VGA_DrawSingleLine);
 			RENDER_EndUpdate(true);
@@ -1005,7 +1014,7 @@ void VGA_SetupDrawing(Bitu /*val*/) {
 		vga.draw.mode = PART;
 		break;
 	}
-	
+
 	/* Calculate the FPS for this screen */
 	double fps; Bitu clock;
 	Bitu htotal, hdend, hbstart, hbend, hrstart, hrend;
@@ -1022,7 +1031,7 @@ void VGA_SetupDrawing(Bitu /*val*/) {
 		vdend = vga.crtc.vertical_display_end | ((vga.crtc.overflow & 2)<<7);
 		vbstart = vga.crtc.start_vertical_blanking | ((vga.crtc.overflow & 0x08) << 5);
 		vrstart = vga.crtc.vertical_retrace_start + ((vga.crtc.overflow & 0x04) << 6);
-		
+
 		if (IS_VGA_ARCH) {
 			// additional bits only present on vga cards
 			htotal |= (vga.s3.ex_hor_overflow & 0x1) << 8;
@@ -1031,10 +1040,10 @@ void VGA_SetupDrawing(Bitu /*val*/) {
 			hbend |= (vga.crtc.end_horizontal_retrace&0x80) >> 2;
 			hbstart |= (vga.s3.ex_hor_overflow & 0x4) << 6;
 			hrstart |= (vga.s3.ex_hor_overflow & 0x10) << 4;
-			
+
 			vtotal |= (vga.crtc.overflow & 0x20) << 4;
 			vtotal |= (vga.s3.ex_ver_overflow & 0x1) << 10;
-			vdend |= (vga.crtc.overflow & 0x40) << 3; 
+			vdend |= (vga.crtc.overflow & 0x40) << 3;
 			vdend |= (vga.s3.ex_ver_overflow & 0x2) << 9;
 			vbstart |= (vga.crtc.maximum_scan_line & 0x20) << 4;
 			vbstart |= (vga.s3.ex_ver_overflow & 0x4) << 8;
@@ -1053,13 +1062,13 @@ void VGA_SetupDrawing(Bitu /*val*/) {
 		hbend = hbstart + ((hbend - hbstart) & 0x3F);
 		hrend = vga.crtc.end_horizontal_retrace & 0x1f;
 		hrend = (hrend - hrstart) & 0x1f;
-		
+
 		if ( !hrend ) hrend = hrstart + 0x1f + 1;
 		else hrend = hrstart + hrend;
 
 		vrend = vga.crtc.vertical_retrace_end & 0xF;
 		vrend = ( vrend - vrstart)&0xF;
-		
+
 		if ( !vrend) vrend = vrstart + 0xf + 1;
 		else vrend = vrstart + vrend;
 
@@ -1068,12 +1077,12 @@ void VGA_SetupDrawing(Bitu /*val*/) {
 		else vbend = vbstart + vbend;
 
 		vbend++;
-			
+
 		if (svga.get_clock) {
 			clock = svga.get_clock();
 		} else {
 			switch ((vga.misc_output >> 2) & 3) {
-			case 0:	
+			case 0:
 				clock = (machine==MCH_EGA) ? 14318180 : 25175000;
 				break;
 			case 1:
@@ -1093,7 +1102,7 @@ void VGA_SetupDrawing(Bitu /*val*/) {
 		if(IS_VGA_ARCH && (svgaCard==SVGA_None) && (vga.mode==M_EGA || vga.mode==M_VGA)) {
 			// vgaonly; can't use with CGA because these use address_line for their
 			// own purposes.
-			// Set the low resolution modes to have as many lines as are scanned - 
+			// Set the low resolution modes to have as many lines as are scanned -
 			// Quite a few demos change the max_scanline register at display time
 			// to get SFX: Majic12 show, Magic circle, Copper, GBU, Party91
 			if( vga.crtc.maximum_scan_line&0x80) vga.draw.address_line_total*=2;
@@ -1140,14 +1149,14 @@ void VGA_SetupDrawing(Bitu /*val*/) {
 #endif
 	if (!htotal) return;
 	if (!vtotal) return;
-	
+
 	// The screen refresh frequency
 	fps=(double)clock/(vtotal*htotal);
 	// Horizontal total (that's how long a line takes with whistles and bells)
 	vga.draw.delay.htotal = htotal*1000.0/clock; //in milliseconds
 	// Start and End of horizontal blanking
 	vga.draw.delay.hblkstart = hbstart*1000.0/clock; //in milliseconds
-	vga.draw.delay.hblkend = hbend*1000.0/clock; 
+	vga.draw.delay.hblkend = hbend*1000.0/clock;
 	// Start and End of horizontal retrace
 	vga.draw.delay.hrstart = hrstart*1000.0/clock;
 	vga.draw.delay.hrend = hrend*1000.0/clock;
@@ -1164,11 +1173,11 @@ void VGA_SetupDrawing(Bitu /*val*/) {
 		if (vbend > vtotal) {
 			// blanking wraps to the start of the screen
 			vblank_skip = vbend&0x7f;
-			
+
 			// on blanking wrap to 0, the first line is not blanked
 			// this is used by the S3 BIOS and other S3 drivers in some SVGA modes
 			if((vbend&0x7f)==1) vblank_skip = 0;
-			
+
 			// it might also cut some lines off the bottom
 			if(vbstart < vdend) {
 				vdend = vbstart;
@@ -1420,14 +1429,14 @@ void VGA_SetupDrawing(Bitu /*val*/) {
 	}
 	VGA_CheckScanLength();
 	if (vga.draw.double_scan) {
-		if (IS_VGA_ARCH) { 
+		if (IS_VGA_ARCH) {
 			vga.draw.vblank_skip /= 2;
 			height/=2;
 		}
 		doubleheight=true;
 	}
 	vga.draw.vblank_skip = vblank_skip;
-		
+
 	if(!(IS_VGA_ARCH && (svgaCard==SVGA_None) && (vga.mode==M_EGA || vga.mode==M_VGA))) {
 		//Only check for extra double height in vga modes
 		//(line multiplying by address_line_total)
@@ -1445,7 +1454,7 @@ void VGA_SetupDrawing(Bitu /*val*/) {
 	vga.changes.frame = 0;
 	vga.changes.writeMask = 1;
 #endif
-    /* 
+    /*
 	   Cheap hack to just make all > 640x480 modes have 4:3 aspect ratio
 	*/
 	if ( width >= 640 && height >= 480 ) {
diff --git a/src/hardware/vga_other.cpp b/src/hardware/vga_other.cpp
index 49a3158e..66fbc1e5 100644
--- a/src/hardware/vga_other.cpp
+++ b/src/hardware/vga_other.cpp
@@ -224,7 +224,7 @@ static void IncreaseHue(bool pressed) {
 		return;
 	hue_offset += 5.0;
 	update_cga16_color();
-	LOG_MSG("Hue at %f",hue_offset); 
+	LOG_MSG("Hue at %f",hue_offset);
 }
 
 static void DecreaseHue(bool pressed) {
@@ -232,7 +232,7 @@ static void DecreaseHue(bool pressed) {
 		return;
 	hue_offset -= 5.0;
 	update_cga16_color();
-	LOG_MSG("Hue at %f",hue_offset); 
+	LOG_MSG("Hue at %f",hue_offset);
 }
 
 static void write_color_select(Bit8u val) {
@@ -269,9 +269,9 @@ static void write_color_select(Bit8u val) {
 
 static void TANDY_FindMode(void) {
 	if (vga.tandy.mode_control & 0x2) {
-		if (vga.tandy.gfx_control & 0x10) 
+		if (vga.tandy.gfx_control & 0x10)
 			VGA_SetMode(M_TANDY16);
-		else if (vga.tandy.gfx_control & 0x08) 
+		else if (vga.tandy.gfx_control & 0x08)
 			VGA_SetMode(M_TANDY4);
 		else if (vga.tandy.mode_control & 0x10)
 			VGA_SetMode(M_TANDY2);
@@ -360,7 +360,7 @@ static void write_tandy_reg(Bit8u val) {
 	case 0x1c: case 0x1d: case 0x1e: case 0x1f:
 		VGA_ATTR_SetPalette(vga.tandy.reg_index-0x10,val & 0xf);
 		break;
-	default:		
+	default:
 		LOG(LOG_VGAMISC,LOG_NORMAL)("Unhandled Write %2X to tandy reg %X",val,vga.tandy.reg_index);
 	}
 }
@@ -369,7 +369,7 @@ static void write_cga(Bitu port,Bitu val,Bitu /*iolen*/) {
 	switch (port) {
 	case 0x3d8:
 		vga.tandy.mode_control=(Bit8u)val;
-		vga.attr.disabled = (val&0x8)? 0: 1; 
+		vga.attr.disabled = (val&0x8)? 0: 1;
 		if (vga.tandy.mode_control & 0x2) {
 			if (vga.tandy.mode_control & 0x10) {
 				if (!(val & 0x4) && machine==MCH_CGA) {
@@ -410,11 +410,11 @@ static void write_tandy(Bitu port,Bitu val,Bitu /*iolen*/) {
 	case 0x3dc:	// Preset lightpen latch
 		if (!vga.other.lightpen_triggered) {
 			vga.other.lightpen_triggered = true; // TODO: this shows at port 3ba/3da bit 1
-			
+
 			double timeInFrame = PIC_FullIndex()-vga.draw.delay.framestart;
 			double timeInLine = fmod(timeInFrame,vga.draw.delay.htotal);
 			Bitu current_scanline = (Bitu)(timeInFrame / vga.draw.delay.htotal);
-			
+
 			vga.other.lightpen = (Bit16u)((vga.draw.address_add/2) * (current_scanline/2));
 			vga.other.lightpen += (Bit16u)((timeInLine / vga.draw.delay.hdend) *
 				((float)(vga.draw.address_add/2)));
@@ -463,8 +463,8 @@ static void CycleHercPal(bool pressed) {
 	Herc_Palette();
 	VGA_DAC_CombineColor(1,7);
 }
-	
-void Herc_Palette(void) {	
+
+void Herc_Palette(void) {
 	switch (herc_pal) {
 	case 0:	// White
 		VGA_DAC_SetEntry(0x7,0x2a,0x2a,0x2a);
@@ -484,7 +484,7 @@ void Herc_Palette(void) {
 static void write_hercules(Bitu port,Bitu val,Bitu /*iolen*/) {
 	switch (port) {
 	case 0x3b8: {
-		// the protected bits can always be cleared but only be set if the 
+		// the protected bits can always be cleared but only be set if the
 		// protection bits are set
 		if (vga.herc.mode_control&0x2) {
 			// already set
@@ -651,12 +651,55 @@ void boxer_setHerculesTintMode(Bit8u mode)
         herc_pal = mode % 3;
         if (machine == MCH_HERC)
         {
-            Herc_Palette();
+			//--Modified 2021-01-09 by Ismail Khatib
+            // Herc_Palette();
+			switch (herc_pal) {
+			case 0:	// White
+				VGA_DAC_SetEntry(0x7,0x2a,0x2a,0x2a);
+				VGA_DAC_SetEntry(0xf,0x3f,0x3f,0x3f);
+				break;
+			case 1:	// Amber
+				VGA_DAC_SetEntry(0x7,0x34,0x20,0x00);
+				VGA_DAC_SetEntry(0xf,0x3f,0x34,0x00);
+				break;
+			case 2:	// Green
+				// VGA_DAC_SetEntry(0x7,0x00,0x26,0x00);
+				// VGA_DAC_SetEntry(0xf,0x00,0x3f,0x00);
+				VGA_DAC_SetEntry(0x7,0x0a,0xaa,0x48);
+				VGA_DAC_SetEntry(0xf,0x0c,0xcc,0x68);
+				break;
+			}
+			//--End of modifications
             VGA_DAC_CombineColor(1,7);
         }
     }
 }
 
+/*
+text: "Default Amber"
+  "brightness": 0.5,
+  "fontColor": "#ff8100",
+
+text: "Monochrome Green"
+  "brightness": 0.5,
+  "fontColor": "#0ccc68",
+
+text: "Green Scanlines"
+  "brightness": 0.5,
+  "fontColor": "#7cff4f",
+
+text: "Apple ]["
+  "brightness": 0.5,
+  "fontColor": "#00d56d",
+
+text: "Vintage"
+  "brightness": 0.5,
+  "fontColor": "#00ff3e",
+
+text: "IBM Dos"
+  "fontColor": "#00ff3e",
+*/
+
 double boxer_CGACompositeHueOffset()
 {
     return hue_offset;
-- 
2.34.1

